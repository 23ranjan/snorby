<!DOCTYPE html>

<html>
	
	<head>
		<% @severities ||= Severity.all %>

		<script type="text/javascript">
			<% @severities.each do |sev| %>
				var sev<%= sev.sig_id %>_bg_color = '<%= sev.bg_color %>';
			<% end %>
		</script>

		<script type="text/javascript">
			
			/*!
			 * jQuery JavaScript Library v1.4.2
			 * http://jquery.com/
			 *
			 * Copyright 2010, John Resig
			 * Dual licensed under the MIT or GPL Version 2 licenses.
			 * http://jquery.org/license
			 *
			 * Includes Sizzle.js
			 * http://sizzlejs.com/
			 * Copyright 2010, The Dojo Foundation
			 * Released under the MIT, BSD, and GPL Licenses.
			 *
			 * Date: Sat Feb 13 22:33:48 2010 -0500
			 */
			(function(A,w){function ma(){if(!c.isReady){try{s.documentElement.doScroll("left")}catch(a){setTimeout(ma,1);return}c.ready()}}function Qa(a,b){b.src?c.ajax({url:b.src,async:false,dataType:"script"}):c.globalEval(b.text||b.textContent||b.innerHTML||"");b.parentNode&&b.parentNode.removeChild(b)}function X(a,b,d,f,e,j){var i=a.length;if(typeof b==="object"){for(var o in b)X(a,o,b[o],f,e,d);return a}if(d!==w){f=!j&&f&&c.isFunction(d);for(o=0;o<i;o++)e(a[o],b,f?d.call(a[o],o,e(a[o],b)):d,j);return a}return i?
			e(a[0],b):w}function J(){return(new Date).getTime()}function Y(){return false}function Z(){return true}function na(a,b,d){d[0].type=a;return c.event.handle.apply(b,d)}function oa(a){var b,d=[],f=[],e=arguments,j,i,o,k,n,r;i=c.data(this,"events");if(!(a.liveFired===this||!i||!i.live||a.button&&a.type==="click")){a.liveFired=this;var u=i.live.slice(0);for(k=0;k<u.length;k++){i=u[k];i.origType.replace(O,"")===a.type?f.push(i.selector):u.splice(k--,1)}j=c(a.target).closest(f,a.currentTarget);n=0;for(r=
			j.length;n<r;n++)for(k=0;k<u.length;k++){i=u[k];if(j[n].selector===i.selector){o=j[n].elem;f=null;if(i.preType==="mouseenter"||i.preType==="mouseleave")f=c(a.relatedTarget).closest(i.selector)[0];if(!f||f!==o)d.push({elem:o,handleObj:i})}}n=0;for(r=d.length;n<r;n++){j=d[n];a.currentTarget=j.elem;a.data=j.handleObj.data;a.handleObj=j.handleObj;if(j.handleObj.origHandler.apply(j.elem,e)===false){b=false;break}}return b}}function pa(a,b){return"live."+(a&&a!=="*"?a+".":"")+b.replace(/\./g,"`").replace(/ /g,
			"&")}function qa(a){return!a||!a.parentNode||a.parentNode.nodeType===11}function ra(a,b){var d=0;b.each(function(){if(this.nodeName===(a[d]&&a[d].nodeName)){var f=c.data(a[d++]),e=c.data(this,f);if(f=f&&f.events){delete e.handle;e.events={};for(var j in f)for(var i in f[j])c.event.add(this,j,f[j][i],f[j][i].data)}}})}function sa(a,b,d){var f,e,j;b=b&&b[0]?b[0].ownerDocument||b[0]:s;if(a.length===1&&typeof a[0]==="string"&&a[0].length<512&&b===s&&!ta.test(a[0])&&(c.support.checkClone||!ua.test(a[0]))){e=
			true;if(j=c.fragments[a[0]])if(j!==1)f=j}if(!f){f=b.createDocumentFragment();c.clean(a,b,f,d)}if(e)c.fragments[a[0]]=j?f:1;return{fragment:f,cacheable:e}}function K(a,b){var d={};c.each(va.concat.apply([],va.slice(0,b)),function(){d[this]=a});return d}function wa(a){return"scrollTo"in a&&a.document?a:a.nodeType===9?a.defaultView||a.parentWindow:false}var c=function(a,b){return new c.fn.init(a,b)},Ra=A.jQuery,Sa=A.$,s=A.document,T,Ta=/^[^<]*(<[\w\W]+>)[^>]*$|^#([\w-]+)$/,Ua=/^.[^:#\[\.,]*$/,Va=/\S/,
			Wa=/^(\s|\u00A0)+|(\s|\u00A0)+$/g,Xa=/^<(\w+)\s*\/?>(?:<\/\1>)?$/,P=navigator.userAgent,xa=false,Q=[],L,$=Object.prototype.toString,aa=Object.prototype.hasOwnProperty,ba=Array.prototype.push,R=Array.prototype.slice,ya=Array.prototype.indexOf;c.fn=c.prototype={init:function(a,b){var d,f;if(!a)return this;if(a.nodeType){this.context=this[0]=a;this.length=1;return this}if(a==="body"&&!b){this.context=s;this[0]=s.body;this.selector="body";this.length=1;return this}if(typeof a==="string")if((d=Ta.exec(a))&&
			(d[1]||!b))if(d[1]){f=b?b.ownerDocument||b:s;if(a=Xa.exec(a))if(c.isPlainObject(b)){a=[s.createElement(a[1])];c.fn.attr.call(a,b,true)}else a=[f.createElement(a[1])];else{a=sa([d[1]],[f]);a=(a.cacheable?a.fragment.cloneNode(true):a.fragment).childNodes}return c.merge(this,a)}else{if(b=s.getElementById(d[2])){if(b.id!==d[2])return T.find(a);this.length=1;this[0]=b}this.context=s;this.selector=a;return this}else if(!b&&/^\w+$/.test(a)){this.selector=a;this.context=s;a=s.getElementsByTagName(a);return c.merge(this,
			a)}else return!b||b.jquery?(b||T).find(a):c(b).find(a);else if(c.isFunction(a))return T.ready(a);if(a.selector!==w){this.selector=a.selector;this.context=a.context}return c.makeArray(a,this)},selector:"",jquery:"1.4.2",length:0,size:function(){return this.length},toArray:function(){return R.call(this,0)},get:function(a){return a==null?this.toArray():a<0?this.slice(a)[0]:this[a]},pushStack:function(a,b,d){var f=c();c.isArray(a)?ba.apply(f,a):c.merge(f,a);f.prevObject=this;f.context=this.context;if(b===
			"find")f.selector=this.selector+(this.selector?" ":"")+d;else if(b)f.selector=this.selector+"."+b+"("+d+")";return f},each:function(a,b){return c.each(this,a,b)},ready:function(a){c.bindReady();if(c.isReady)a.call(s,c);else Q&&Q.push(a);return this},eq:function(a){return a===-1?this.slice(a):this.slice(a,+a+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(R.apply(this,arguments),"slice",R.call(arguments).join(","))},map:function(a){return this.pushStack(c.map(this,
			function(b,d){return a.call(b,d,b)}))},end:function(){return this.prevObject||c(null)},push:ba,sort:[].sort,splice:[].splice};c.fn.init.prototype=c.fn;c.extend=c.fn.extend=function(){var a=arguments[0]||{},b=1,d=arguments.length,f=false,e,j,i,o;if(typeof a==="boolean"){f=a;a=arguments[1]||{};b=2}if(typeof a!=="object"&&!c.isFunction(a))a={};if(d===b){a=this;--b}for(;b<d;b++)if((e=arguments[b])!=null)for(j in e){i=a[j];o=e[j];if(a!==o)if(f&&o&&(c.isPlainObject(o)||c.isArray(o))){i=i&&(c.isPlainObject(i)||
			c.isArray(i))?i:c.isArray(o)?[]:{};a[j]=c.extend(f,i,o)}else if(o!==w)a[j]=o}return a};c.extend({noConflict:function(a){A.$=Sa;if(a)A.jQuery=Ra;return c},isReady:false,ready:function(){if(!c.isReady){if(!s.body)return setTimeout(c.ready,13);c.isReady=true;if(Q){for(var a,b=0;a=Q[b++];)a.call(s,c);Q=null}c.fn.triggerHandler&&c(s).triggerHandler("ready")}},bindReady:function(){if(!xa){xa=true;if(s.readyState==="complete")return c.ready();if(s.addEventListener){s.addEventListener("DOMContentLoaded",
			L,false);A.addEventListener("load",c.ready,false)}else if(s.attachEvent){s.attachEvent("onreadystatechange",L);A.attachEvent("onload",c.ready);var a=false;try{a=A.frameElement==null}catch(b){}s.documentElement.doScroll&&a&&ma()}}},isFunction:function(a){return $.call(a)==="[object Function]"},isArray:function(a){return $.call(a)==="[object Array]"},isPlainObject:function(a){if(!a||$.call(a)!=="[object Object]"||a.nodeType||a.setInterval)return false;if(a.constructor&&!aa.call(a,"constructor")&&!aa.call(a.constructor.prototype,
			"isPrototypeOf"))return false;var b;for(b in a);return b===w||aa.call(a,b)},isEmptyObject:function(a){for(var b in a)return false;return true},error:function(a){throw a;},parseJSON:function(a){if(typeof a!=="string"||!a)return null;a=c.trim(a);if(/^[\],:{}\s]*$/.test(a.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,"@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,"]").replace(/(?:^|:|,)(?:\s*\[)+/g,"")))return A.JSON&&A.JSON.parse?A.JSON.parse(a):(new Function("return "+
			a))();else c.error("Invalid JSON: "+a)},noop:function(){},globalEval:function(a){if(a&&Va.test(a)){var b=s.getElementsByTagName("head")[0]||s.documentElement,d=s.createElement("script");d.type="text/javascript";if(c.support.scriptEval)d.appendChild(s.createTextNode(a));else d.text=a;b.insertBefore(d,b.firstChild);b.removeChild(d)}},nodeName:function(a,b){return a.nodeName&&a.nodeName.toUpperCase()===b.toUpperCase()},each:function(a,b,d){var f,e=0,j=a.length,i=j===w||c.isFunction(a);if(d)if(i)for(f in a){if(b.apply(a[f],
			d)===false)break}else for(;e<j;){if(b.apply(a[e++],d)===false)break}else if(i)for(f in a){if(b.call(a[f],f,a[f])===false)break}else for(d=a[0];e<j&&b.call(d,e,d)!==false;d=a[++e]);return a},trim:function(a){return(a||"").replace(Wa,"")},makeArray:function(a,b){b=b||[];if(a!=null)a.length==null||typeof a==="string"||c.isFunction(a)||typeof a!=="function"&&a.setInterval?ba.call(b,a):c.merge(b,a);return b},inArray:function(a,b){if(b.indexOf)return b.indexOf(a);for(var d=0,f=b.length;d<f;d++)if(b[d]===
			a)return d;return-1},merge:function(a,b){var d=a.length,f=0;if(typeof b.length==="number")for(var e=b.length;f<e;f++)a[d++]=b[f];else for(;b[f]!==w;)a[d++]=b[f++];a.length=d;return a},grep:function(a,b,d){for(var f=[],e=0,j=a.length;e<j;e++)!d!==!b(a[e],e)&&f.push(a[e]);return f},map:function(a,b,d){for(var f=[],e,j=0,i=a.length;j<i;j++){e=b(a[j],j,d);if(e!=null)f[f.length]=e}return f.concat.apply([],f)},guid:1,proxy:function(a,b,d){if(arguments.length===2)if(typeof b==="string"){d=a;a=d[b];b=w}else if(b&&
			!c.isFunction(b)){d=b;b=w}if(!b&&a)b=function(){return a.apply(d||this,arguments)};if(a)b.guid=a.guid=a.guid||b.guid||c.guid++;return b},uaMatch:function(a){a=a.toLowerCase();a=/(webkit)[ \/]([\w.]+)/.exec(a)||/(opera)(?:.*version)?[ \/]([\w.]+)/.exec(a)||/(msie) ([\w.]+)/.exec(a)||!/compatible/.test(a)&&/(mozilla)(?:.*? rv:([\w.]+))?/.exec(a)||[];return{browser:a[1]||"",version:a[2]||"0"}},browser:{}});P=c.uaMatch(P);if(P.browser){c.browser[P.browser]=true;c.browser.version=P.version}if(c.browser.webkit)c.browser.safari=
			true;if(ya)c.inArray=function(a,b){return ya.call(b,a)};T=c(s);if(s.addEventListener)L=function(){s.removeEventListener("DOMContentLoaded",L,false);c.ready()};else if(s.attachEvent)L=function(){if(s.readyState==="complete"){s.detachEvent("onreadystatechange",L);c.ready()}};(function(){c.support={};var a=s.documentElement,b=s.createElement("script"),d=s.createElement("div"),f="script"+J();d.style.display="none";d.innerHTML="   <link/><table></table><a href='/a' style='color:red;float:left;opacity:.55;'>a</a><input type='checkbox'/>";
			var e=d.getElementsByTagName("*"),j=d.getElementsByTagName("a")[0];if(!(!e||!e.length||!j)){c.support={leadingWhitespace:d.firstChild.nodeType===3,tbody:!d.getElementsByTagName("tbody").length,htmlSerialize:!!d.getElementsByTagName("link").length,style:/red/.test(j.getAttribute("style")),hrefNormalized:j.getAttribute("href")==="/a",opacity:/^0.55$/.test(j.style.opacity),cssFloat:!!j.style.cssFloat,checkOn:d.getElementsByTagName("input")[0].value==="on",optSelected:s.createElement("select").appendChild(s.createElement("option")).selected,
			parentNode:d.removeChild(d.appendChild(s.createElement("div"))).parentNode===null,deleteExpando:true,checkClone:false,scriptEval:false,noCloneEvent:true,boxModel:null};b.type="text/javascript";try{b.appendChild(s.createTextNode("window."+f+"=1;"))}catch(i){}a.insertBefore(b,a.firstChild);if(A[f]){c.support.scriptEval=true;delete A[f]}try{delete b.test}catch(o){c.support.deleteExpando=false}a.removeChild(b);if(d.attachEvent&&d.fireEvent){d.attachEvent("onclick",function k(){c.support.noCloneEvent=
			false;d.detachEvent("onclick",k)});d.cloneNode(true).fireEvent("onclick")}d=s.createElement("div");d.innerHTML="<input type='radio' name='radiotest' checked='checked'/>";a=s.createDocumentFragment();a.appendChild(d.firstChild);c.support.checkClone=a.cloneNode(true).cloneNode(true).lastChild.checked;c(function(){var k=s.createElement("div");k.style.width=k.style.paddingLeft="1px";s.body.appendChild(k);c.boxModel=c.support.boxModel=k.offsetWidth===2;s.body.removeChild(k).style.display="none"});a=function(k){var n=
			s.createElement("div");k="on"+k;var r=k in n;if(!r){n.setAttribute(k,"return;");r=typeof n[k]==="function"}return r};c.support.submitBubbles=a("submit");c.support.changeBubbles=a("change");a=b=d=e=j=null}})();c.props={"for":"htmlFor","class":"className",readonly:"readOnly",maxlength:"maxLength",cellspacing:"cellSpacing",rowspan:"rowSpan",colspan:"colSpan",tabindex:"tabIndex",usemap:"useMap",frameborder:"frameBorder"};var G="jQuery"+J(),Ya=0,za={};c.extend({cache:{},expando:G,noData:{embed:true,object:true,
			applet:true},data:function(a,b,d){if(!(a.nodeName&&c.noData[a.nodeName.toLowerCase()])){a=a==A?za:a;var f=a[G],e=c.cache;if(!f&&typeof b==="string"&&d===w)return null;f||(f=++Ya);if(typeof b==="object"){a[G]=f;e[f]=c.extend(true,{},b)}else if(!e[f]){a[G]=f;e[f]={}}a=e[f];if(d!==w)a[b]=d;return typeof b==="string"?a[b]:a}},removeData:function(a,b){if(!(a.nodeName&&c.noData[a.nodeName.toLowerCase()])){a=a==A?za:a;var d=a[G],f=c.cache,e=f[d];if(b){if(e){delete e[b];c.isEmptyObject(e)&&c.removeData(a)}}else{if(c.support.deleteExpando)delete a[c.expando];
			else a.removeAttribute&&a.removeAttribute(c.expando);delete f[d]}}}});c.fn.extend({data:function(a,b){if(typeof a==="undefined"&&this.length)return c.data(this[0]);else if(typeof a==="object")return this.each(function(){c.data(this,a)});var d=a.split(".");d[1]=d[1]?"."+d[1]:"";if(b===w){var f=this.triggerHandler("getData"+d[1]+"!",[d[0]]);if(f===w&&this.length)f=c.data(this[0],a);return f===w&&d[1]?this.data(d[0]):f}else return this.trigger("setData"+d[1]+"!",[d[0],b]).each(function(){c.data(this,
			a,b)})},removeData:function(a){return this.each(function(){c.removeData(this,a)})}});c.extend({queue:function(a,b,d){if(a){b=(b||"fx")+"queue";var f=c.data(a,b);if(!d)return f||[];if(!f||c.isArray(d))f=c.data(a,b,c.makeArray(d));else f.push(d);return f}},dequeue:function(a,b){b=b||"fx";var d=c.queue(a,b),f=d.shift();if(f==="inprogress")f=d.shift();if(f){b==="fx"&&d.unshift("inprogress");f.call(a,function(){c.dequeue(a,b)})}}});c.fn.extend({queue:function(a,b){if(typeof a!=="string"){b=a;a="fx"}if(b===
			w)return c.queue(this[0],a);return this.each(function(){var d=c.queue(this,a,b);a==="fx"&&d[0]!=="inprogress"&&c.dequeue(this,a)})},dequeue:function(a){return this.each(function(){c.dequeue(this,a)})},delay:function(a,b){a=c.fx?c.fx.speeds[a]||a:a;b=b||"fx";return this.queue(b,function(){var d=this;setTimeout(function(){c.dequeue(d,b)},a)})},clearQueue:function(a){return this.queue(a||"fx",[])}});var Aa=/[\n\t]/g,ca=/\s+/,Za=/\r/g,$a=/href|src|style/,ab=/(button|input)/i,bb=/(button|input|object|select|textarea)/i,
			cb=/^(a|area)$/i,Ba=/radio|checkbox/;c.fn.extend({attr:function(a,b){return X(this,a,b,true,c.attr)},removeAttr:function(a){return this.each(function(){c.attr(this,a,"");this.nodeType===1&&this.removeAttribute(a)})},addClass:function(a){if(c.isFunction(a))return this.each(function(n){var r=c(this);r.addClass(a.call(this,n,r.attr("class")))});if(a&&typeof a==="string")for(var b=(a||"").split(ca),d=0,f=this.length;d<f;d++){var e=this[d];if(e.nodeType===1)if(e.className){for(var j=" "+e.className+" ",
			i=e.className,o=0,k=b.length;o<k;o++)if(j.indexOf(" "+b[o]+" ")<0)i+=" "+b[o];e.className=c.trim(i)}else e.className=a}return this},removeClass:function(a){if(c.isFunction(a))return this.each(function(k){var n=c(this);n.removeClass(a.call(this,k,n.attr("class")))});if(a&&typeof a==="string"||a===w)for(var b=(a||"").split(ca),d=0,f=this.length;d<f;d++){var e=this[d];if(e.nodeType===1&&e.className)if(a){for(var j=(" "+e.className+" ").replace(Aa," "),i=0,o=b.length;i<o;i++)j=j.replace(" "+b[i]+" ",
			" ");e.className=c.trim(j)}else e.className=""}return this},toggleClass:function(a,b){var d=typeof a,f=typeof b==="boolean";if(c.isFunction(a))return this.each(function(e){var j=c(this);j.toggleClass(a.call(this,e,j.attr("class"),b),b)});return this.each(function(){if(d==="string")for(var e,j=0,i=c(this),o=b,k=a.split(ca);e=k[j++];){o=f?o:!i.hasClass(e);i[o?"addClass":"removeClass"](e)}else if(d==="undefined"||d==="boolean"){this.className&&c.data(this,"__className__",this.className);this.className=
			this.className||a===false?"":c.data(this,"__className__")||""}})},hasClass:function(a){a=" "+a+" ";for(var b=0,d=this.length;b<d;b++)if((" "+this[b].className+" ").replace(Aa," ").indexOf(a)>-1)return true;return false},val:function(a){if(a===w){var b=this[0];if(b){if(c.nodeName(b,"option"))return(b.attributes.value||{}).specified?b.value:b.text;if(c.nodeName(b,"select")){var d=b.selectedIndex,f=[],e=b.options;b=b.type==="select-one";if(d<0)return null;var j=b?d:0;for(d=b?d+1:e.length;j<d;j++){var i=
			e[j];if(i.selected){a=c(i).val();if(b)return a;f.push(a)}}return f}if(Ba.test(b.type)&&!c.support.checkOn)return b.getAttribute("value")===null?"on":b.value;return(b.value||"").replace(Za,"")}return w}var o=c.isFunction(a);return this.each(function(k){var n=c(this),r=a;if(this.nodeType===1){if(o)r=a.call(this,k,n.val());if(typeof r==="number")r+="";if(c.isArray(r)&&Ba.test(this.type))this.checked=c.inArray(n.val(),r)>=0;else if(c.nodeName(this,"select")){var u=c.makeArray(r);c("option",this).each(function(){this.selected=
			c.inArray(c(this).val(),u)>=0});if(!u.length)this.selectedIndex=-1}else this.value=r}})}});c.extend({attrFn:{val:true,css:true,html:true,text:true,data:true,width:true,height:true,offset:true},attr:function(a,b,d,f){if(!a||a.nodeType===3||a.nodeType===8)return w;if(f&&b in c.attrFn)return c(a)[b](d);f=a.nodeType!==1||!c.isXMLDoc(a);var e=d!==w;b=f&&c.props[b]||b;if(a.nodeType===1){var j=$a.test(b);if(b in a&&f&&!j){if(e){b==="type"&&ab.test(a.nodeName)&&a.parentNode&&c.error("type property can't be changed");
			a[b]=d}if(c.nodeName(a,"form")&&a.getAttributeNode(b))return a.getAttributeNode(b).nodeValue;if(b==="tabIndex")return(b=a.getAttributeNode("tabIndex"))&&b.specified?b.value:bb.test(a.nodeName)||cb.test(a.nodeName)&&a.href?0:w;return a[b]}if(!c.support.style&&f&&b==="style"){if(e)a.style.cssText=""+d;return a.style.cssText}e&&a.setAttribute(b,""+d);a=!c.support.hrefNormalized&&f&&j?a.getAttribute(b,2):a.getAttribute(b);return a===null?w:a}return c.style(a,b,d)}});var O=/\.(.*)$/,db=function(a){return a.replace(/[^\w\s\.\|`]/g,
			function(b){return"\\"+b})};c.event={add:function(a,b,d,f){if(!(a.nodeType===3||a.nodeType===8)){if(a.setInterval&&a!==A&&!a.frameElement)a=A;var e,j;if(d.handler){e=d;d=e.handler}if(!d.guid)d.guid=c.guid++;if(j=c.data(a)){var i=j.events=j.events||{},o=j.handle;if(!o)j.handle=o=function(){return typeof c!=="undefined"&&!c.event.triggered?c.event.handle.apply(o.elem,arguments):w};o.elem=a;b=b.split(" ");for(var k,n=0,r;k=b[n++];){j=e?c.extend({},e):{handler:d,data:f};if(k.indexOf(".")>-1){r=k.split(".");
			k=r.shift();j.namespace=r.slice(0).sort().join(".")}else{r=[];j.namespace=""}j.type=k;j.guid=d.guid;var u=i[k],z=c.event.special[k]||{};if(!u){u=i[k]=[];if(!z.setup||z.setup.call(a,f,r,o)===false)if(a.addEventListener)a.addEventListener(k,o,false);else a.attachEvent&&a.attachEvent("on"+k,o)}if(z.add){z.add.call(a,j);if(!j.handler.guid)j.handler.guid=d.guid}u.push(j);c.event.global[k]=true}a=null}}},global:{},remove:function(a,b,d,f){if(!(a.nodeType===3||a.nodeType===8)){var e,j=0,i,o,k,n,r,u,z=c.data(a),
			C=z&&z.events;if(z&&C){if(b&&b.type){d=b.handler;b=b.type}if(!b||typeof b==="string"&&b.charAt(0)==="."){b=b||"";for(e in C)c.event.remove(a,e+b)}else{for(b=b.split(" ");e=b[j++];){n=e;i=e.indexOf(".")<0;o=[];if(!i){o=e.split(".");e=o.shift();k=new RegExp("(^|\\.)"+c.map(o.slice(0).sort(),db).join("\\.(?:.*\\.)?")+"(\\.|$)")}if(r=C[e])if(d){n=c.event.special[e]||{};for(B=f||0;B<r.length;B++){u=r[B];if(d.guid===u.guid){if(i||k.test(u.namespace)){f==null&&r.splice(B--,1);n.remove&&n.remove.call(a,u)}if(f!=
			null)break}}if(r.length===0||f!=null&&r.length===1){if(!n.teardown||n.teardown.call(a,o)===false)Ca(a,e,z.handle);delete C[e]}}else for(var B=0;B<r.length;B++){u=r[B];if(i||k.test(u.namespace)){c.event.remove(a,n,u.handler,B);r.splice(B--,1)}}}if(c.isEmptyObject(C)){if(b=z.handle)b.elem=null;delete z.events;delete z.handle;c.isEmptyObject(z)&&c.removeData(a)}}}}},trigger:function(a,b,d,f){var e=a.type||a;if(!f){a=typeof a==="object"?a[G]?a:c.extend(c.Event(e),a):c.Event(e);if(e.indexOf("!")>=0){a.type=
			e=e.slice(0,-1);a.exclusive=true}if(!d){a.stopPropagation();c.event.global[e]&&c.each(c.cache,function(){this.events&&this.events[e]&&c.event.trigger(a,b,this.handle.elem)})}if(!d||d.nodeType===3||d.nodeType===8)return w;a.result=w;a.target=d;b=c.makeArray(b);b.unshift(a)}a.currentTarget=d;(f=c.data(d,"handle"))&&f.apply(d,b);f=d.parentNode||d.ownerDocument;try{if(!(d&&d.nodeName&&c.noData[d.nodeName.toLowerCase()]))if(d["on"+e]&&d["on"+e].apply(d,b)===false)a.result=false}catch(j){}if(!a.isPropagationStopped()&&
			f)c.event.trigger(a,b,f,true);else if(!a.isDefaultPrevented()){f=a.target;var i,o=c.nodeName(f,"a")&&e==="click",k=c.event.special[e]||{};if((!k._default||k._default.call(d,a)===false)&&!o&&!(f&&f.nodeName&&c.noData[f.nodeName.toLowerCase()])){try{if(f[e]){if(i=f["on"+e])f["on"+e]=null;c.event.triggered=true;f[e]()}}catch(n){}if(i)f["on"+e]=i;c.event.triggered=false}}},handle:function(a){var b,d,f,e;a=arguments[0]=c.event.fix(a||A.event);a.currentTarget=this;b=a.type.indexOf(".")<0&&!a.exclusive;
			if(!b){d=a.type.split(".");a.type=d.shift();f=new RegExp("(^|\\.)"+d.slice(0).sort().join("\\.(?:.*\\.)?")+"(\\.|$)")}e=c.data(this,"events");d=e[a.type];if(e&&d){d=d.slice(0);e=0;for(var j=d.length;e<j;e++){var i=d[e];if(b||f.test(i.namespace)){a.handler=i.handler;a.data=i.data;a.handleObj=i;i=i.handler.apply(this,arguments);if(i!==w){a.result=i;if(i===false){a.preventDefault();a.stopPropagation()}}if(a.isImmediatePropagationStopped())break}}}return a.result},props:"altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY originalTarget pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),
			fix:function(a){if(a[G])return a;var b=a;a=c.Event(b);for(var d=this.props.length,f;d;){f=this.props[--d];a[f]=b[f]}if(!a.target)a.target=a.srcElement||s;if(a.target.nodeType===3)a.target=a.target.parentNode;if(!a.relatedTarget&&a.fromElement)a.relatedTarget=a.fromElement===a.target?a.toElement:a.fromElement;if(a.pageX==null&&a.clientX!=null){b=s.documentElement;d=s.body;a.pageX=a.clientX+(b&&b.scrollLeft||d&&d.scrollLeft||0)-(b&&b.clientLeft||d&&d.clientLeft||0);a.pageY=a.clientY+(b&&b.scrollTop||
			d&&d.scrollTop||0)-(b&&b.clientTop||d&&d.clientTop||0)}if(!a.which&&(a.charCode||a.charCode===0?a.charCode:a.keyCode))a.which=a.charCode||a.keyCode;if(!a.metaKey&&a.ctrlKey)a.metaKey=a.ctrlKey;if(!a.which&&a.button!==w)a.which=a.button&1?1:a.button&2?3:a.button&4?2:0;return a},guid:1E8,proxy:c.proxy,special:{ready:{setup:c.bindReady,teardown:c.noop},live:{add:function(a){c.event.add(this,a.origType,c.extend({},a,{handler:oa}))},remove:function(a){var b=true,d=a.origType.replace(O,"");c.each(c.data(this,
			"events").live||[],function(){if(d===this.origType.replace(O,""))return b=false});b&&c.event.remove(this,a.origType,oa)}},beforeunload:{setup:function(a,b,d){if(this.setInterval)this.onbeforeunload=d;return false},teardown:function(a,b){if(this.onbeforeunload===b)this.onbeforeunload=null}}}};var Ca=s.removeEventListener?function(a,b,d){a.removeEventListener(b,d,false)}:function(a,b,d){a.detachEvent("on"+b,d)};c.Event=function(a){if(!this.preventDefault)return new c.Event(a);if(a&&a.type){this.originalEvent=
			a;this.type=a.type}else this.type=a;this.timeStamp=J();this[G]=true};c.Event.prototype={preventDefault:function(){this.isDefaultPrevented=Z;var a=this.originalEvent;if(a){a.preventDefault&&a.preventDefault();a.returnValue=false}},stopPropagation:function(){this.isPropagationStopped=Z;var a=this.originalEvent;if(a){a.stopPropagation&&a.stopPropagation();a.cancelBubble=true}},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=Z;this.stopPropagation()},isDefaultPrevented:Y,isPropagationStopped:Y,
			isImmediatePropagationStopped:Y};var Da=function(a){var b=a.relatedTarget;try{for(;b&&b!==this;)b=b.parentNode;if(b!==this){a.type=a.data;c.event.handle.apply(this,arguments)}}catch(d){}},Ea=function(a){a.type=a.data;c.event.handle.apply(this,arguments)};c.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(a,b){c.event.special[a]={setup:function(d){c.event.add(this,b,d&&d.selector?Ea:Da,a)},teardown:function(d){c.event.remove(this,b,d&&d.selector?Ea:Da)}}});if(!c.support.submitBubbles)c.event.special.submit=
			{setup:function(){if(this.nodeName.toLowerCase()!=="form"){c.event.add(this,"click.specialSubmit",function(a){var b=a.target,d=b.type;if((d==="submit"||d==="image")&&c(b).closest("form").length)return na("submit",this,arguments)});c.event.add(this,"keypress.specialSubmit",function(a){var b=a.target,d=b.type;if((d==="text"||d==="password")&&c(b).closest("form").length&&a.keyCode===13)return na("submit",this,arguments)})}else return false},teardown:function(){c.event.remove(this,".specialSubmit")}};
			if(!c.support.changeBubbles){var da=/textarea|input|select/i,ea,Fa=function(a){var b=a.type,d=a.value;if(b==="radio"||b==="checkbox")d=a.checked;else if(b==="select-multiple")d=a.selectedIndex>-1?c.map(a.options,function(f){return f.selected}).join("-"):"";else if(a.nodeName.toLowerCase()==="select")d=a.selectedIndex;return d},fa=function(a,b){var d=a.target,f,e;if(!(!da.test(d.nodeName)||d.readOnly)){f=c.data(d,"_change_data");e=Fa(d);if(a.type!=="focusout"||d.type!=="radio")c.data(d,"_change_data",
			e);if(!(f===w||e===f))if(f!=null||e){a.type="change";return c.event.trigger(a,b,d)}}};c.event.special.change={filters:{focusout:fa,click:function(a){var b=a.target,d=b.type;if(d==="radio"||d==="checkbox"||b.nodeName.toLowerCase()==="select")return fa.call(this,a)},keydown:function(a){var b=a.target,d=b.type;if(a.keyCode===13&&b.nodeName.toLowerCase()!=="textarea"||a.keyCode===32&&(d==="checkbox"||d==="radio")||d==="select-multiple")return fa.call(this,a)},beforeactivate:function(a){a=a.target;c.data(a,
			"_change_data",Fa(a))}},setup:function(){if(this.type==="file")return false;for(var a in ea)c.event.add(this,a+".specialChange",ea[a]);return da.test(this.nodeName)},teardown:function(){c.event.remove(this,".specialChange");return da.test(this.nodeName)}};ea=c.event.special.change.filters}s.addEventListener&&c.each({focus:"focusin",blur:"focusout"},function(a,b){function d(f){f=c.event.fix(f);f.type=b;return c.event.handle.call(this,f)}c.event.special[b]={setup:function(){this.addEventListener(a,
			d,true)},teardown:function(){this.removeEventListener(a,d,true)}}});c.each(["bind","one"],function(a,b){c.fn[b]=function(d,f,e){if(typeof d==="object"){for(var j in d)this[b](j,f,d[j],e);return this}if(c.isFunction(f)){e=f;f=w}var i=b==="one"?c.proxy(e,function(k){c(this).unbind(k,i);return e.apply(this,arguments)}):e;if(d==="unload"&&b!=="one")this.one(d,f,e);else{j=0;for(var o=this.length;j<o;j++)c.event.add(this[j],d,i,f)}return this}});c.fn.extend({unbind:function(a,b){if(typeof a==="object"&&
			!a.preventDefault)for(var d in a)this.unbind(d,a[d]);else{d=0;for(var f=this.length;d<f;d++)c.event.remove(this[d],a,b)}return this},delegate:function(a,b,d,f){return this.live(b,d,f,a)},undelegate:function(a,b,d){return arguments.length===0?this.unbind("live"):this.die(b,null,d,a)},trigger:function(a,b){return this.each(function(){c.event.trigger(a,b,this)})},triggerHandler:function(a,b){if(this[0]){a=c.Event(a);a.preventDefault();a.stopPropagation();c.event.trigger(a,b,this[0]);return a.result}},
			toggle:function(a){for(var b=arguments,d=1;d<b.length;)c.proxy(a,b[d++]);return this.click(c.proxy(a,function(f){var e=(c.data(this,"lastToggle"+a.guid)||0)%d;c.data(this,"lastToggle"+a.guid,e+1);f.preventDefault();return b[e].apply(this,arguments)||false}))},hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}});var Ga={focus:"focusin",blur:"focusout",mouseenter:"mouseover",mouseleave:"mouseout"};c.each(["live","die"],function(a,b){c.fn[b]=function(d,f,e,j){var i,o=0,k,n,r=j||this.selector,
			u=j?this:c(this.context);if(c.isFunction(f)){e=f;f=w}for(d=(d||"").split(" ");(i=d[o++])!=null;){j=O.exec(i);k="";if(j){k=j[0];i=i.replace(O,"")}if(i==="hover")d.push("mouseenter"+k,"mouseleave"+k);else{n=i;if(i==="focus"||i==="blur"){d.push(Ga[i]+k);i+=k}else i=(Ga[i]||i)+k;b==="live"?u.each(function(){c.event.add(this,pa(i,r),{data:f,selector:r,handler:e,origType:i,origHandler:e,preType:n})}):u.unbind(pa(i,r),e)}}return this}});c.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error".split(" "),
			function(a,b){c.fn[b]=function(d){return d?this.bind(b,d):this.trigger(b)};if(c.attrFn)c.attrFn[b]=true});A.attachEvent&&!A.addEventListener&&A.attachEvent("onunload",function(){for(var a in c.cache)if(c.cache[a].handle)try{c.event.remove(c.cache[a].handle.elem)}catch(b){}});(function(){function a(g){for(var h="",l,m=0;g[m];m++){l=g[m];if(l.nodeType===3||l.nodeType===4)h+=l.nodeValue;else if(l.nodeType!==8)h+=a(l.childNodes)}return h}function b(g,h,l,m,q,p){q=0;for(var v=m.length;q<v;q++){var t=m[q];
			if(t){t=t[g];for(var y=false;t;){if(t.sizcache===l){y=m[t.sizset];break}if(t.nodeType===1&&!p){t.sizcache=l;t.sizset=q}if(t.nodeName.toLowerCase()===h){y=t;break}t=t[g]}m[q]=y}}}function d(g,h,l,m,q,p){q=0;for(var v=m.length;q<v;q++){var t=m[q];if(t){t=t[g];for(var y=false;t;){if(t.sizcache===l){y=m[t.sizset];break}if(t.nodeType===1){if(!p){t.sizcache=l;t.sizset=q}if(typeof h!=="string"){if(t===h){y=true;break}}else if(k.filter(h,[t]).length>0){y=t;break}}t=t[g]}m[q]=y}}}var f=/((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^[\]]*\]|['"][^'"]*['"]|[^[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
			e=0,j=Object.prototype.toString,i=false,o=true;[0,0].sort(function(){o=false;return 0});var k=function(g,h,l,m){l=l||[];var q=h=h||s;if(h.nodeType!==1&&h.nodeType!==9)return[];if(!g||typeof g!=="string")return l;for(var p=[],v,t,y,S,H=true,M=x(h),I=g;(f.exec(""),v=f.exec(I))!==null;){I=v[3];p.push(v[1]);if(v[2]){S=v[3];break}}if(p.length>1&&r.exec(g))if(p.length===2&&n.relative[p[0]])t=ga(p[0]+p[1],h);else for(t=n.relative[p[0]]?[h]:k(p.shift(),h);p.length;){g=p.shift();if(n.relative[g])g+=p.shift();
			t=ga(g,t)}else{if(!m&&p.length>1&&h.nodeType===9&&!M&&n.match.ID.test(p[0])&&!n.match.ID.test(p[p.length-1])){v=k.find(p.shift(),h,M);h=v.expr?k.filter(v.expr,v.set)[0]:v.set[0]}if(h){v=m?{expr:p.pop(),set:z(m)}:k.find(p.pop(),p.length===1&&(p[0]==="~"||p[0]==="+")&&h.parentNode?h.parentNode:h,M);t=v.expr?k.filter(v.expr,v.set):v.set;if(p.length>0)y=z(t);else H=false;for(;p.length;){var D=p.pop();v=D;if(n.relative[D])v=p.pop();else D="";if(v==null)v=h;n.relative[D](y,v,M)}}else y=[]}y||(y=t);y||k.error(D||
			g);if(j.call(y)==="[object Array]")if(H)if(h&&h.nodeType===1)for(g=0;y[g]!=null;g++){if(y[g]&&(y[g]===true||y[g].nodeType===1&&E(h,y[g])))l.push(t[g])}else for(g=0;y[g]!=null;g++)y[g]&&y[g].nodeType===1&&l.push(t[g]);else l.push.apply(l,y);else z(y,l);if(S){k(S,q,l,m);k.uniqueSort(l)}return l};k.uniqueSort=function(g){if(B){i=o;g.sort(B);if(i)for(var h=1;h<g.length;h++)g[h]===g[h-1]&&g.splice(h--,1)}return g};k.matches=function(g,h){return k(g,null,null,h)};k.find=function(g,h,l){var m,q;if(!g)return[];
			for(var p=0,v=n.order.length;p<v;p++){var t=n.order[p];if(q=n.leftMatch[t].exec(g)){var y=q[1];q.splice(1,1);if(y.substr(y.length-1)!=="\\"){q[1]=(q[1]||"").replace(/\\/g,"");m=n.find[t](q,h,l);if(m!=null){g=g.replace(n.match[t],"");break}}}}m||(m=h.getElementsByTagName("*"));return{set:m,expr:g}};k.filter=function(g,h,l,m){for(var q=g,p=[],v=h,t,y,S=h&&h[0]&&x(h[0]);g&&h.length;){for(var H in n.filter)if((t=n.leftMatch[H].exec(g))!=null&&t[2]){var M=n.filter[H],I,D;D=t[1];y=false;t.splice(1,1);if(D.substr(D.length-
			1)!=="\\"){if(v===p)p=[];if(n.preFilter[H])if(t=n.preFilter[H](t,v,l,p,m,S)){if(t===true)continue}else y=I=true;if(t)for(var U=0;(D=v[U])!=null;U++)if(D){I=M(D,t,U,v);var Ha=m^!!I;if(l&&I!=null)if(Ha)y=true;else v[U]=false;else if(Ha){p.push(D);y=true}}if(I!==w){l||(v=p);g=g.replace(n.match[H],"");if(!y)return[];break}}}if(g===q)if(y==null)k.error(g);else break;q=g}return v};k.error=function(g){throw"Syntax error, unrecognized expression: "+g;};var n=k.selectors={order:["ID","NAME","TAG"],match:{ID:/#((?:[\w\u00c0-\uFFFF-]|\\.)+)/,
			CLASS:/\.((?:[\w\u00c0-\uFFFF-]|\\.)+)/,NAME:/\[name=['"]*((?:[\w\u00c0-\uFFFF-]|\\.)+)['"]*\]/,ATTR:/\[\s*((?:[\w\u00c0-\uFFFF-]|\\.)+)\s*(?:(\S?=)\s*(['"]*)(.*?)\3|)\s*\]/,TAG:/^((?:[\w\u00c0-\uFFFF\*-]|\\.)+)/,CHILD:/:(only|nth|last|first)-child(?:\((even|odd|[\dn+-]*)\))?/,POS:/:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^-]|$)/,PSEUDO:/:((?:[\w\u00c0-\uFFFF-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/},leftMatch:{},attrMap:{"class":"className","for":"htmlFor"},attrHandle:{href:function(g){return g.getAttribute("href")}},
			relative:{"+":function(g,h){var l=typeof h==="string",m=l&&!/\W/.test(h);l=l&&!m;if(m)h=h.toLowerCase();m=0;for(var q=g.length,p;m<q;m++)if(p=g[m]){for(;(p=p.previousSibling)&&p.nodeType!==1;);g[m]=l||p&&p.nodeName.toLowerCase()===h?p||false:p===h}l&&k.filter(h,g,true)},">":function(g,h){var l=typeof h==="string";if(l&&!/\W/.test(h)){h=h.toLowerCase();for(var m=0,q=g.length;m<q;m++){var p=g[m];if(p){l=p.parentNode;g[m]=l.nodeName.toLowerCase()===h?l:false}}}else{m=0;for(q=g.length;m<q;m++)if(p=g[m])g[m]=
			l?p.parentNode:p.parentNode===h;l&&k.filter(h,g,true)}},"":function(g,h,l){var m=e++,q=d;if(typeof h==="string"&&!/\W/.test(h)){var p=h=h.toLowerCase();q=b}q("parentNode",h,m,g,p,l)},"~":function(g,h,l){var m=e++,q=d;if(typeof h==="string"&&!/\W/.test(h)){var p=h=h.toLowerCase();q=b}q("previousSibling",h,m,g,p,l)}},find:{ID:function(g,h,l){if(typeof h.getElementById!=="undefined"&&!l)return(g=h.getElementById(g[1]))?[g]:[]},NAME:function(g,h){if(typeof h.getElementsByName!=="undefined"){var l=[];
			h=h.getElementsByName(g[1]);for(var m=0,q=h.length;m<q;m++)h[m].getAttribute("name")===g[1]&&l.push(h[m]);return l.length===0?null:l}},TAG:function(g,h){return h.getElementsByTagName(g[1])}},preFilter:{CLASS:function(g,h,l,m,q,p){g=" "+g[1].replace(/\\/g,"")+" ";if(p)return g;p=0;for(var v;(v=h[p])!=null;p++)if(v)if(q^(v.className&&(" "+v.className+" ").replace(/[\t\n]/g," ").indexOf(g)>=0))l||m.push(v);else if(l)h[p]=false;return false},ID:function(g){return g[1].replace(/\\/g,"")},TAG:function(g){return g[1].toLowerCase()},
			CHILD:function(g){if(g[1]==="nth"){var h=/(-?)(\d*)n((?:\+|-)?\d*)/.exec(g[2]==="even"&&"2n"||g[2]==="odd"&&"2n+1"||!/\D/.test(g[2])&&"0n+"+g[2]||g[2]);g[2]=h[1]+(h[2]||1)-0;g[3]=h[3]-0}g[0]=e++;return g},ATTR:function(g,h,l,m,q,p){h=g[1].replace(/\\/g,"");if(!p&&n.attrMap[h])g[1]=n.attrMap[h];if(g[2]==="~=")g[4]=" "+g[4]+" ";return g},PSEUDO:function(g,h,l,m,q){if(g[1]==="not")if((f.exec(g[3])||"").length>1||/^\w/.test(g[3]))g[3]=k(g[3],null,null,h);else{g=k.filter(g[3],h,l,true^q);l||m.push.apply(m,
			g);return false}else if(n.match.POS.test(g[0])||n.match.CHILD.test(g[0]))return true;return g},POS:function(g){g.unshift(true);return g}},filters:{enabled:function(g){return g.disabled===false&&g.type!=="hidden"},disabled:function(g){return g.disabled===true},checked:function(g){return g.checked===true},selected:function(g){return g.selected===true},parent:function(g){return!!g.firstChild},empty:function(g){return!g.firstChild},has:function(g,h,l){return!!k(l[3],g).length},header:function(g){return/h\d/i.test(g.nodeName)},
			text:function(g){return"text"===g.type},radio:function(g){return"radio"===g.type},checkbox:function(g){return"checkbox"===g.type},file:function(g){return"file"===g.type},password:function(g){return"password"===g.type},submit:function(g){return"submit"===g.type},image:function(g){return"image"===g.type},reset:function(g){return"reset"===g.type},button:function(g){return"button"===g.type||g.nodeName.toLowerCase()==="button"},input:function(g){return/input|select|textarea|button/i.test(g.nodeName)}},
			setFilters:{first:function(g,h){return h===0},last:function(g,h,l,m){return h===m.length-1},even:function(g,h){return h%2===0},odd:function(g,h){return h%2===1},lt:function(g,h,l){return h<l[3]-0},gt:function(g,h,l){return h>l[3]-0},nth:function(g,h,l){return l[3]-0===h},eq:function(g,h,l){return l[3]-0===h}},filter:{PSEUDO:function(g,h,l,m){var q=h[1],p=n.filters[q];if(p)return p(g,l,h,m);else if(q==="contains")return(g.textContent||g.innerText||a([g])||"").indexOf(h[3])>=0;else if(q==="not"){h=
			h[3];l=0;for(m=h.length;l<m;l++)if(h[l]===g)return false;return true}else k.error("Syntax error, unrecognized expression: "+q)},CHILD:function(g,h){var l=h[1],m=g;switch(l){case "only":case "first":for(;m=m.previousSibling;)if(m.nodeType===1)return false;if(l==="first")return true;m=g;case "last":for(;m=m.nextSibling;)if(m.nodeType===1)return false;return true;case "nth":l=h[2];var q=h[3];if(l===1&&q===0)return true;h=h[0];var p=g.parentNode;if(p&&(p.sizcache!==h||!g.nodeIndex)){var v=0;for(m=p.firstChild;m;m=
			m.nextSibling)if(m.nodeType===1)m.nodeIndex=++v;p.sizcache=h}g=g.nodeIndex-q;return l===0?g===0:g%l===0&&g/l>=0}},ID:function(g,h){return g.nodeType===1&&g.getAttribute("id")===h},TAG:function(g,h){return h==="*"&&g.nodeType===1||g.nodeName.toLowerCase()===h},CLASS:function(g,h){return(" "+(g.className||g.getAttribute("class"))+" ").indexOf(h)>-1},ATTR:function(g,h){var l=h[1];g=n.attrHandle[l]?n.attrHandle[l](g):g[l]!=null?g[l]:g.getAttribute(l);l=g+"";var m=h[2];h=h[4];return g==null?m==="!=":m===
			"="?l===h:m==="*="?l.indexOf(h)>=0:m==="~="?(" "+l+" ").indexOf(h)>=0:!h?l&&g!==false:m==="!="?l!==h:m==="^="?l.indexOf(h)===0:m==="$="?l.substr(l.length-h.length)===h:m==="|="?l===h||l.substr(0,h.length+1)===h+"-":false},POS:function(g,h,l,m){var q=n.setFilters[h[2]];if(q)return q(g,l,h,m)}}},r=n.match.POS;for(var u in n.match){n.match[u]=new RegExp(n.match[u].source+/(?![^\[]*\])(?![^\(]*\))/.source);n.leftMatch[u]=new RegExp(/(^(?:.|\r|\n)*?)/.source+n.match[u].source.replace(/\\(\d+)/g,function(g,
			h){return"\\"+(h-0+1)}))}var z=function(g,h){g=Array.prototype.slice.call(g,0);if(h){h.push.apply(h,g);return h}return g};try{Array.prototype.slice.call(s.documentElement.childNodes,0)}catch(C){z=function(g,h){h=h||[];if(j.call(g)==="[object Array]")Array.prototype.push.apply(h,g);else if(typeof g.length==="number")for(var l=0,m=g.length;l<m;l++)h.push(g[l]);else for(l=0;g[l];l++)h.push(g[l]);return h}}var B;if(s.documentElement.compareDocumentPosition)B=function(g,h){if(!g.compareDocumentPosition||
			!h.compareDocumentPosition){if(g==h)i=true;return g.compareDocumentPosition?-1:1}g=g.compareDocumentPosition(h)&4?-1:g===h?0:1;if(g===0)i=true;return g};else if("sourceIndex"in s.documentElement)B=function(g,h){if(!g.sourceIndex||!h.sourceIndex){if(g==h)i=true;return g.sourceIndex?-1:1}g=g.sourceIndex-h.sourceIndex;if(g===0)i=true;return g};else if(s.createRange)B=function(g,h){if(!g.ownerDocument||!h.ownerDocument){if(g==h)i=true;return g.ownerDocument?-1:1}var l=g.ownerDocument.createRange(),m=
			h.ownerDocument.createRange();l.setStart(g,0);l.setEnd(g,0);m.setStart(h,0);m.setEnd(h,0);g=l.compareBoundaryPoints(Range.START_TO_END,m);if(g===0)i=true;return g};(function(){var g=s.createElement("div"),h="script"+(new Date).getTime();g.innerHTML="<a name='"+h+"'/>";var l=s.documentElement;l.insertBefore(g,l.firstChild);if(s.getElementById(h)){n.find.ID=function(m,q,p){if(typeof q.getElementById!=="undefined"&&!p)return(q=q.getElementById(m[1]))?q.id===m[1]||typeof q.getAttributeNode!=="undefined"&&
			q.getAttributeNode("id").nodeValue===m[1]?[q]:w:[]};n.filter.ID=function(m,q){var p=typeof m.getAttributeNode!=="undefined"&&m.getAttributeNode("id");return m.nodeType===1&&p&&p.nodeValue===q}}l.removeChild(g);l=g=null})();(function(){var g=s.createElement("div");g.appendChild(s.createComment(""));if(g.getElementsByTagName("*").length>0)n.find.TAG=function(h,l){l=l.getElementsByTagName(h[1]);if(h[1]==="*"){h=[];for(var m=0;l[m];m++)l[m].nodeType===1&&h.push(l[m]);l=h}return l};g.innerHTML="<a href='#'></a>";
			if(g.firstChild&&typeof g.firstChild.getAttribute!=="undefined"&&g.firstChild.getAttribute("href")!=="#")n.attrHandle.href=function(h){return h.getAttribute("href",2)};g=null})();s.querySelectorAll&&function(){var g=k,h=s.createElement("div");h.innerHTML="<p class='TEST'></p>";if(!(h.querySelectorAll&&h.querySelectorAll(".TEST").length===0)){k=function(m,q,p,v){q=q||s;if(!v&&q.nodeType===9&&!x(q))try{return z(q.querySelectorAll(m),p)}catch(t){}return g(m,q,p,v)};for(var l in g)k[l]=g[l];h=null}}();
			(function(){var g=s.createElement("div");g.innerHTML="<div class='test e'></div><div class='test'></div>";if(!(!g.getElementsByClassName||g.getElementsByClassName("e").length===0)){g.lastChild.className="e";if(g.getElementsByClassName("e").length!==1){n.order.splice(1,0,"CLASS");n.find.CLASS=function(h,l,m){if(typeof l.getElementsByClassName!=="undefined"&&!m)return l.getElementsByClassName(h[1])};g=null}}})();var E=s.compareDocumentPosition?function(g,h){return!!(g.compareDocumentPosition(h)&16)}:
			function(g,h){return g!==h&&(g.contains?g.contains(h):true)},x=function(g){return(g=(g?g.ownerDocument||g:0).documentElement)?g.nodeName!=="HTML":false},ga=function(g,h){var l=[],m="",q;for(h=h.nodeType?[h]:h;q=n.match.PSEUDO.exec(g);){m+=q[0];g=g.replace(n.match.PSEUDO,"")}g=n.relative[g]?g+"*":g;q=0;for(var p=h.length;q<p;q++)k(g,h[q],l);return k.filter(m,l)};c.find=k;c.expr=k.selectors;c.expr[":"]=c.expr.filters;c.unique=k.uniqueSort;c.text=a;c.isXMLDoc=x;c.contains=E})();var eb=/Until$/,fb=/^(?:parents|prevUntil|prevAll)/,
			gb=/,/;R=Array.prototype.slice;var Ia=function(a,b,d){if(c.isFunction(b))return c.grep(a,function(e,j){return!!b.call(e,j,e)===d});else if(b.nodeType)return c.grep(a,function(e){return e===b===d});else if(typeof b==="string"){var f=c.grep(a,function(e){return e.nodeType===1});if(Ua.test(b))return c.filter(b,f,!d);else b=c.filter(b,f)}return c.grep(a,function(e){return c.inArray(e,b)>=0===d})};c.fn.extend({find:function(a){for(var b=this.pushStack("","find",a),d=0,f=0,e=this.length;f<e;f++){d=b.length;
			c.find(a,this[f],b);if(f>0)for(var j=d;j<b.length;j++)for(var i=0;i<d;i++)if(b[i]===b[j]){b.splice(j--,1);break}}return b},has:function(a){var b=c(a);return this.filter(function(){for(var d=0,f=b.length;d<f;d++)if(c.contains(this,b[d]))return true})},not:function(a){return this.pushStack(Ia(this,a,false),"not",a)},filter:function(a){return this.pushStack(Ia(this,a,true),"filter",a)},is:function(a){return!!a&&c.filter(a,this).length>0},closest:function(a,b){if(c.isArray(a)){var d=[],f=this[0],e,j=
			{},i;if(f&&a.length){e=0;for(var o=a.length;e<o;e++){i=a[e];j[i]||(j[i]=c.expr.match.POS.test(i)?c(i,b||this.context):i)}for(;f&&f.ownerDocument&&f!==b;){for(i in j){e=j[i];if(e.jquery?e.index(f)>-1:c(f).is(e)){d.push({selector:i,elem:f});delete j[i]}}f=f.parentNode}}return d}var k=c.expr.match.POS.test(a)?c(a,b||this.context):null;return this.map(function(n,r){for(;r&&r.ownerDocument&&r!==b;){if(k?k.index(r)>-1:c(r).is(a))return r;r=r.parentNode}return null})},index:function(a){if(!a||typeof a===
			"string")return c.inArray(this[0],a?c(a):this.parent().children());return c.inArray(a.jquery?a[0]:a,this)},add:function(a,b){a=typeof a==="string"?c(a,b||this.context):c.makeArray(a);b=c.merge(this.get(),a);return this.pushStack(qa(a[0])||qa(b[0])?b:c.unique(b))},andSelf:function(){return this.add(this.prevObject)}});c.each({parent:function(a){return(a=a.parentNode)&&a.nodeType!==11?a:null},parents:function(a){return c.dir(a,"parentNode")},parentsUntil:function(a,b,d){return c.dir(a,"parentNode",
			d)},next:function(a){return c.nth(a,2,"nextSibling")},prev:function(a){return c.nth(a,2,"previousSibling")},nextAll:function(a){return c.dir(a,"nextSibling")},prevAll:function(a){return c.dir(a,"previousSibling")},nextUntil:function(a,b,d){return c.dir(a,"nextSibling",d)},prevUntil:function(a,b,d){return c.dir(a,"previousSibling",d)},siblings:function(a){return c.sibling(a.parentNode.firstChild,a)},children:function(a){return c.sibling(a.firstChild)},contents:function(a){return c.nodeName(a,"iframe")?
			a.contentDocument||a.contentWindow.document:c.makeArray(a.childNodes)}},function(a,b){c.fn[a]=function(d,f){var e=c.map(this,b,d);eb.test(a)||(f=d);if(f&&typeof f==="string")e=c.filter(f,e);e=this.length>1?c.unique(e):e;if((this.length>1||gb.test(f))&&fb.test(a))e=e.reverse();return this.pushStack(e,a,R.call(arguments).join(","))}});c.extend({filter:function(a,b,d){if(d)a=":not("+a+")";return c.find.matches(a,b)},dir:function(a,b,d){var f=[];for(a=a[b];a&&a.nodeType!==9&&(d===w||a.nodeType!==1||!c(a).is(d));){a.nodeType===
			1&&f.push(a);a=a[b]}return f},nth:function(a,b,d){b=b||1;for(var f=0;a;a=a[d])if(a.nodeType===1&&++f===b)break;return a},sibling:function(a,b){for(var d=[];a;a=a.nextSibling)a.nodeType===1&&a!==b&&d.push(a);return d}});var Ja=/ jQuery\d+="(?:\d+|null)"/g,V=/^\s+/,Ka=/(<([\w:]+)[^>]*?)\/>/g,hb=/^(?:area|br|col|embed|hr|img|input|link|meta|param)$/i,La=/<([\w:]+)/,ib=/<tbody/i,jb=/<|&#?\w+;/,ta=/<script|<object|<embed|<option|<style/i,ua=/checked\s*(?:[^=]|=\s*.checked.)/i,Ma=function(a,b,d){return hb.test(d)?
			a:b+"></"+d+">"},F={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]};F.optgroup=F.option;F.tbody=F.tfoot=F.colgroup=F.caption=F.thead;F.th=F.td;if(!c.support.htmlSerialize)F._default=[1,"div<div>","</div>"];c.fn.extend({text:function(a){if(c.isFunction(a))return this.each(function(b){var d=
			c(this);d.text(a.call(this,b,d.text()))});if(typeof a!=="object"&&a!==w)return this.empty().append((this[0]&&this[0].ownerDocument||s).createTextNode(a));return c.text(this)},wrapAll:function(a){if(c.isFunction(a))return this.each(function(d){c(this).wrapAll(a.call(this,d))});if(this[0]){var b=c(a,this[0].ownerDocument).eq(0).clone(true);this[0].parentNode&&b.insertBefore(this[0]);b.map(function(){for(var d=this;d.firstChild&&d.firstChild.nodeType===1;)d=d.firstChild;return d}).append(this)}return this},
			wrapInner:function(a){if(c.isFunction(a))return this.each(function(b){c(this).wrapInner(a.call(this,b))});return this.each(function(){var b=c(this),d=b.contents();d.length?d.wrapAll(a):b.append(a)})},wrap:function(a){return this.each(function(){c(this).wrapAll(a)})},unwrap:function(){return this.parent().each(function(){c.nodeName(this,"body")||c(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,true,function(a){this.nodeType===1&&this.appendChild(a)})},
			prepend:function(){return this.domManip(arguments,true,function(a){this.nodeType===1&&this.insertBefore(a,this.firstChild)})},before:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,false,function(b){this.parentNode.insertBefore(b,this)});else if(arguments.length){var a=c(arguments[0]);a.push.apply(a,this.toArray());return this.pushStack(a,"before",arguments)}},after:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,false,function(b){this.parentNode.insertBefore(b,
			this.nextSibling)});else if(arguments.length){var a=this.pushStack(this,"after",arguments);a.push.apply(a,c(arguments[0]).toArray());return a}},remove:function(a,b){for(var d=0,f;(f=this[d])!=null;d++)if(!a||c.filter(a,[f]).length){if(!b&&f.nodeType===1){c.cleanData(f.getElementsByTagName("*"));c.cleanData([f])}f.parentNode&&f.parentNode.removeChild(f)}return this},empty:function(){for(var a=0,b;(b=this[a])!=null;a++)for(b.nodeType===1&&c.cleanData(b.getElementsByTagName("*"));b.firstChild;)b.removeChild(b.firstChild);
			return this},clone:function(a){var b=this.map(function(){if(!c.support.noCloneEvent&&!c.isXMLDoc(this)){var d=this.outerHTML,f=this.ownerDocument;if(!d){d=f.createElement("div");d.appendChild(this.cloneNode(true));d=d.innerHTML}return c.clean([d.replace(Ja,"").replace(/=([^="'>\s]+\/)>/g,'="$1">').replace(V,"")],f)[0]}else return this.cloneNode(true)});if(a===true){ra(this,b);ra(this.find("*"),b.find("*"))}return b},html:function(a){if(a===w)return this[0]&&this[0].nodeType===1?this[0].innerHTML.replace(Ja,
			""):null;else if(typeof a==="string"&&!ta.test(a)&&(c.support.leadingWhitespace||!V.test(a))&&!F[(La.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(Ka,Ma);try{for(var b=0,d=this.length;b<d;b++)if(this[b].nodeType===1){c.cleanData(this[b].getElementsByTagName("*"));this[b].innerHTML=a}}catch(f){this.empty().append(a)}}else c.isFunction(a)?this.each(function(e){var j=c(this),i=j.html();j.empty().append(function(){return a.call(this,e,i)})}):this.empty().append(a);return this},replaceWith:function(a){if(this[0]&&
			this[0].parentNode){if(c.isFunction(a))return this.each(function(b){var d=c(this),f=d.html();d.replaceWith(a.call(this,b,f))});if(typeof a!=="string")a=c(a).detach();return this.each(function(){var b=this.nextSibling,d=this.parentNode;c(this).remove();b?c(b).before(a):c(d).append(a)})}else return this.pushStack(c(c.isFunction(a)?a():a),"replaceWith",a)},detach:function(a){return this.remove(a,true)},domManip:function(a,b,d){function f(u){return c.nodeName(u,"table")?u.getElementsByTagName("tbody")[0]||
			u.appendChild(u.ownerDocument.createElement("tbody")):u}var e,j,i=a[0],o=[],k;if(!c.support.checkClone&&arguments.length===3&&typeof i==="string"&&ua.test(i))return this.each(function(){c(this).domManip(a,b,d,true)});if(c.isFunction(i))return this.each(function(u){var z=c(this);a[0]=i.call(this,u,b?z.html():w);z.domManip(a,b,d)});if(this[0]){e=i&&i.parentNode;e=c.support.parentNode&&e&&e.nodeType===11&&e.childNodes.length===this.length?{fragment:e}:sa(a,this,o);k=e.fragment;if(j=k.childNodes.length===
			1?(k=k.firstChild):k.firstChild){b=b&&c.nodeName(j,"tr");for(var n=0,r=this.length;n<r;n++)d.call(b?f(this[n],j):this[n],n>0||e.cacheable||this.length>1?k.cloneNode(true):k)}o.length&&c.each(o,Qa)}return this}});c.fragments={};c.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){c.fn[a]=function(d){var f=[];d=c(d);var e=this.length===1&&this[0].parentNode;if(e&&e.nodeType===11&&e.childNodes.length===1&&d.length===1){d[b](this[0]);
			return this}else{e=0;for(var j=d.length;e<j;e++){var i=(e>0?this.clone(true):this).get();c.fn[b].apply(c(d[e]),i);f=f.concat(i)}return this.pushStack(f,a,d.selector)}}});c.extend({clean:function(a,b,d,f){b=b||s;if(typeof b.createElement==="undefined")b=b.ownerDocument||b[0]&&b[0].ownerDocument||s;for(var e=[],j=0,i;(i=a[j])!=null;j++){if(typeof i==="number")i+="";if(i){if(typeof i==="string"&&!jb.test(i))i=b.createTextNode(i);else if(typeof i==="string"){i=i.replace(Ka,Ma);var o=(La.exec(i)||["",
			""])[1].toLowerCase(),k=F[o]||F._default,n=k[0],r=b.createElement("div");for(r.innerHTML=k[1]+i+k[2];n--;)r=r.lastChild;if(!c.support.tbody){n=ib.test(i);o=o==="table"&&!n?r.firstChild&&r.firstChild.childNodes:k[1]==="<table>"&&!n?r.childNodes:[];for(k=o.length-1;k>=0;--k)c.nodeName(o[k],"tbody")&&!o[k].childNodes.length&&o[k].parentNode.removeChild(o[k])}!c.support.leadingWhitespace&&V.test(i)&&r.insertBefore(b.createTextNode(V.exec(i)[0]),r.firstChild);i=r.childNodes}if(i.nodeType)e.push(i);else e=
			c.merge(e,i)}}if(d)for(j=0;e[j];j++)if(f&&c.nodeName(e[j],"script")&&(!e[j].type||e[j].type.toLowerCase()==="text/javascript"))f.push(e[j].parentNode?e[j].parentNode.removeChild(e[j]):e[j]);else{e[j].nodeType===1&&e.splice.apply(e,[j+1,0].concat(c.makeArray(e[j].getElementsByTagName("script"))));d.appendChild(e[j])}return e},cleanData:function(a){for(var b,d,f=c.cache,e=c.event.special,j=c.support.deleteExpando,i=0,o;(o=a[i])!=null;i++)if(d=o[c.expando]){b=f[d];if(b.events)for(var k in b.events)e[k]?
			c.event.remove(o,k):Ca(o,k,b.handle);if(j)delete o[c.expando];else o.removeAttribute&&o.removeAttribute(c.expando);delete f[d]}}});var kb=/z-?index|font-?weight|opacity|zoom|line-?height/i,Na=/alpha\([^)]*\)/,Oa=/opacity=([^)]*)/,ha=/float/i,ia=/-([a-z])/ig,lb=/([A-Z])/g,mb=/^-?\d+(?:px)?$/i,nb=/^-?\d/,ob={position:"absolute",visibility:"hidden",display:"block"},pb=["Left","Right"],qb=["Top","Bottom"],rb=s.defaultView&&s.defaultView.getComputedStyle,Pa=c.support.cssFloat?"cssFloat":"styleFloat",ja=
			function(a,b){return b.toUpperCase()};c.fn.css=function(a,b){return X(this,a,b,true,function(d,f,e){if(e===w)return c.curCSS(d,f);if(typeof e==="number"&&!kb.test(f))e+="px";c.style(d,f,e)})};c.extend({style:function(a,b,d){if(!a||a.nodeType===3||a.nodeType===8)return w;if((b==="width"||b==="height")&&parseFloat(d)<0)d=w;var f=a.style||a,e=d!==w;if(!c.support.opacity&&b==="opacity"){if(e){f.zoom=1;b=parseInt(d,10)+""==="NaN"?"":"alpha(opacity="+d*100+")";a=f.filter||c.curCSS(a,"filter")||"";f.filter=
			Na.test(a)?a.replace(Na,b):b}return f.filter&&f.filter.indexOf("opacity=")>=0?parseFloat(Oa.exec(f.filter)[1])/100+"":""}if(ha.test(b))b=Pa;b=b.replace(ia,ja);if(e)f[b]=d;return f[b]},css:function(a,b,d,f){if(b==="width"||b==="height"){var e,j=b==="width"?pb:qb;function i(){e=b==="width"?a.offsetWidth:a.offsetHeight;f!=="border"&&c.each(j,function(){f||(e-=parseFloat(c.curCSS(a,"padding"+this,true))||0);if(f==="margin")e+=parseFloat(c.curCSS(a,"margin"+this,true))||0;else e-=parseFloat(c.curCSS(a,
			"border"+this+"Width",true))||0})}a.offsetWidth!==0?i():c.swap(a,ob,i);return Math.max(0,Math.round(e))}return c.curCSS(a,b,d)},curCSS:function(a,b,d){var f,e=a.style;if(!c.support.opacity&&b==="opacity"&&a.currentStyle){f=Oa.test(a.currentStyle.filter||"")?parseFloat(RegExp.$1)/100+"":"";return f===""?"1":f}if(ha.test(b))b=Pa;if(!d&&e&&e[b])f=e[b];else if(rb){if(ha.test(b))b="float";b=b.replace(lb,"-$1").toLowerCase();e=a.ownerDocument.defaultView;if(!e)return null;if(a=e.getComputedStyle(a,null))f=
			a.getPropertyValue(b);if(b==="opacity"&&f==="")f="1"}else if(a.currentStyle){d=b.replace(ia,ja);f=a.currentStyle[b]||a.currentStyle[d];if(!mb.test(f)&&nb.test(f)){b=e.left;var j=a.runtimeStyle.left;a.runtimeStyle.left=a.currentStyle.left;e.left=d==="fontSize"?"1em":f||0;f=e.pixelLeft+"px";e.left=b;a.runtimeStyle.left=j}}return f},swap:function(a,b,d){var f={};for(var e in b){f[e]=a.style[e];a.style[e]=b[e]}d.call(a);for(e in b)a.style[e]=f[e]}});if(c.expr&&c.expr.filters){c.expr.filters.hidden=function(a){var b=
			a.offsetWidth,d=a.offsetHeight,f=a.nodeName.toLowerCase()==="tr";return b===0&&d===0&&!f?true:b>0&&d>0&&!f?false:c.curCSS(a,"display")==="none"};c.expr.filters.visible=function(a){return!c.expr.filters.hidden(a)}}var sb=J(),tb=/<script(.|\s)*?\/script>/gi,ub=/select|textarea/i,vb=/color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week/i,N=/=\?(&|$)/,ka=/\?/,wb=/(\?|&)_=.*?(&|$)/,xb=/^(\w+:)?\/\/([^\/?#]+)/,yb=/%20/g,zb=c.fn.load;c.fn.extend({load:function(a,b,d){if(typeof a!==
			"string")return zb.call(this,a);else if(!this.length)return this;var f=a.indexOf(" ");if(f>=0){var e=a.slice(f,a.length);a=a.slice(0,f)}f="GET";if(b)if(c.isFunction(b)){d=b;b=null}else if(typeof b==="object"){b=c.param(b,c.ajaxSettings.traditional);f="POST"}var j=this;c.ajax({url:a,type:f,dataType:"html",data:b,complete:function(i,o){if(o==="success"||o==="notmodified")j.html(e?c("<div />").append(i.responseText.replace(tb,"")).find(e):i.responseText);d&&j.each(d,[i.responseText,o,i])}});return this},
			serialize:function(){return c.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?c.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||ub.test(this.nodeName)||vb.test(this.type))}).map(function(a,b){a=c(this).val();return a==null?null:c.isArray(a)?c.map(a,function(d){return{name:b.name,value:d}}):{name:b.name,value:a}}).get()}});c.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "),
			function(a,b){c.fn[b]=function(d){return this.bind(b,d)}});c.extend({get:function(a,b,d,f){if(c.isFunction(b)){f=f||d;d=b;b=null}return c.ajax({type:"GET",url:a,data:b,success:d,dataType:f})},getScript:function(a,b){return c.get(a,null,b,"script")},getJSON:function(a,b,d){return c.get(a,b,d,"json")},post:function(a,b,d,f){if(c.isFunction(b)){f=f||d;d=b;b={}}return c.ajax({type:"POST",url:a,data:b,success:d,dataType:f})},ajaxSetup:function(a){c.extend(c.ajaxSettings,a)},ajaxSettings:{url:location.href,
			global:true,type:"GET",contentType:"application/x-www-form-urlencoded",processData:true,async:true,xhr:A.XMLHttpRequest&&(A.location.protocol!=="file:"||!A.ActiveXObject)?function(){return new A.XMLHttpRequest}:function(){try{return new A.ActiveXObject("Microsoft.XMLHTTP")}catch(a){}},accepts:{xml:"application/xml, text/xml",html:"text/html",script:"text/javascript, application/javascript",json:"application/json, text/javascript",text:"text/plain",_default:"*/*"}},lastModified:{},etag:{},ajax:function(a){function b(){e.success&&
			e.success.call(k,o,i,x);e.global&&f("ajaxSuccess",[x,e])}function d(){e.complete&&e.complete.call(k,x,i);e.global&&f("ajaxComplete",[x,e]);e.global&&!--c.active&&c.event.trigger("ajaxStop")}function f(q,p){(e.context?c(e.context):c.event).trigger(q,p)}var e=c.extend(true,{},c.ajaxSettings,a),j,i,o,k=a&&a.context||e,n=e.type.toUpperCase();if(e.data&&e.processData&&typeof e.data!=="string")e.data=c.param(e.data,e.traditional);if(e.dataType==="jsonp"){if(n==="GET")N.test(e.url)||(e.url+=(ka.test(e.url)?
			"&":"?")+(e.jsonp||"callback")+"=?");else if(!e.data||!N.test(e.data))e.data=(e.data?e.data+"&":"")+(e.jsonp||"callback")+"=?";e.dataType="json"}if(e.dataType==="json"&&(e.data&&N.test(e.data)||N.test(e.url))){j=e.jsonpCallback||"jsonp"+sb++;if(e.data)e.data=(e.data+"").replace(N,"="+j+"$1");e.url=e.url.replace(N,"="+j+"$1");e.dataType="script";A[j]=A[j]||function(q){o=q;b();d();A[j]=w;try{delete A[j]}catch(p){}z&&z.removeChild(C)}}if(e.dataType==="script"&&e.cache===null)e.cache=false;if(e.cache===
			false&&n==="GET"){var r=J(),u=e.url.replace(wb,"$1_="+r+"$2");e.url=u+(u===e.url?(ka.test(e.url)?"&":"?")+"_="+r:"")}if(e.data&&n==="GET")e.url+=(ka.test(e.url)?"&":"?")+e.data;e.global&&!c.active++&&c.event.trigger("ajaxStart");r=(r=xb.exec(e.url))&&(r[1]&&r[1]!==location.protocol||r[2]!==location.host);if(e.dataType==="script"&&n==="GET"&&r){var z=s.getElementsByTagName("head")[0]||s.documentElement,C=s.createElement("script");C.src=e.url;if(e.scriptCharset)C.charset=e.scriptCharset;if(!j){var B=
			false;C.onload=C.onreadystatechange=function(){if(!B&&(!this.readyState||this.readyState==="loaded"||this.readyState==="complete")){B=true;b();d();C.onload=C.onreadystatechange=null;z&&C.parentNode&&z.removeChild(C)}}}z.insertBefore(C,z.firstChild);return w}var E=false,x=e.xhr();if(x){e.username?x.open(n,e.url,e.async,e.username,e.password):x.open(n,e.url,e.async);try{if(e.data||a&&a.contentType)x.setRequestHeader("Content-Type",e.contentType);if(e.ifModified){c.lastModified[e.url]&&x.setRequestHeader("If-Modified-Since",
			c.lastModified[e.url]);c.etag[e.url]&&x.setRequestHeader("If-None-Match",c.etag[e.url])}r||x.setRequestHeader("X-Requested-With","XMLHttpRequest");x.setRequestHeader("Accept",e.dataType&&e.accepts[e.dataType]?e.accepts[e.dataType]+", */*":e.accepts._default)}catch(ga){}if(e.beforeSend&&e.beforeSend.call(k,x,e)===false){e.global&&!--c.active&&c.event.trigger("ajaxStop");x.abort();return false}e.global&&f("ajaxSend",[x,e]);var g=x.onreadystatechange=function(q){if(!x||x.readyState===0||q==="abort"){E||
			d();E=true;if(x)x.onreadystatechange=c.noop}else if(!E&&x&&(x.readyState===4||q==="timeout")){E=true;x.onreadystatechange=c.noop;i=q==="timeout"?"timeout":!c.httpSuccess(x)?"error":e.ifModified&&c.httpNotModified(x,e.url)?"notmodified":"success";var p;if(i==="success")try{o=c.httpData(x,e.dataType,e)}catch(v){i="parsererror";p=v}if(i==="success"||i==="notmodified")j||b();else c.handleError(e,x,i,p);d();q==="timeout"&&x.abort();if(e.async)x=null}};try{var h=x.abort;x.abort=function(){x&&h.call(x);
			g("abort")}}catch(l){}e.async&&e.timeout>0&&setTimeout(function(){x&&!E&&g("timeout")},e.timeout);try{x.send(n==="POST"||n==="PUT"||n==="DELETE"?e.data:null)}catch(m){c.handleError(e,x,null,m);d()}e.async||g();return x}},handleError:function(a,b,d,f){if(a.error)a.error.call(a.context||a,b,d,f);if(a.global)(a.context?c(a.context):c.event).trigger("ajaxError",[b,a,f])},active:0,httpSuccess:function(a){try{return!a.status&&location.protocol==="file:"||a.status>=200&&a.status<300||a.status===304||a.status===
			1223||a.status===0}catch(b){}return false},httpNotModified:function(a,b){var d=a.getResponseHeader("Last-Modified"),f=a.getResponseHeader("Etag");if(d)c.lastModified[b]=d;if(f)c.etag[b]=f;return a.status===304||a.status===0},httpData:function(a,b,d){var f=a.getResponseHeader("content-type")||"",e=b==="xml"||!b&&f.indexOf("xml")>=0;a=e?a.responseXML:a.responseText;e&&a.documentElement.nodeName==="parsererror"&&c.error("parsererror");if(d&&d.dataFilter)a=d.dataFilter(a,b);if(typeof a==="string")if(b===
			"json"||!b&&f.indexOf("json")>=0)a=c.parseJSON(a);else if(b==="script"||!b&&f.indexOf("javascript")>=0)c.globalEval(a);return a},param:function(a,b){function d(i,o){if(c.isArray(o))c.each(o,function(k,n){b||/\[\]$/.test(i)?f(i,n):d(i+"["+(typeof n==="object"||c.isArray(n)?k:"")+"]",n)});else!b&&o!=null&&typeof o==="object"?c.each(o,function(k,n){d(i+"["+k+"]",n)}):f(i,o)}function f(i,o){o=c.isFunction(o)?o():o;e[e.length]=encodeURIComponent(i)+"="+encodeURIComponent(o)}var e=[];if(b===w)b=c.ajaxSettings.traditional;
			if(c.isArray(a)||a.jquery)c.each(a,function(){f(this.name,this.value)});else for(var j in a)d(j,a[j]);return e.join("&").replace(yb,"+")}});var la={},Ab=/toggle|show|hide/,Bb=/^([+-]=)?([\d+-.]+)(.*)$/,W,va=[["height","marginTop","marginBottom","paddingTop","paddingBottom"],["width","marginLeft","marginRight","paddingLeft","paddingRight"],["opacity"]];c.fn.extend({show:function(a,b){if(a||a===0)return this.animate(K("show",3),a,b);else{a=0;for(b=this.length;a<b;a++){var d=c.data(this[a],"olddisplay");
			this[a].style.display=d||"";if(c.css(this[a],"display")==="none"){d=this[a].nodeName;var f;if(la[d])f=la[d];else{var e=c("<"+d+" />").appendTo("body");f=e.css("display");if(f==="none")f="block";e.remove();la[d]=f}c.data(this[a],"olddisplay",f)}}a=0;for(b=this.length;a<b;a++)this[a].style.display=c.data(this[a],"olddisplay")||"";return this}},hide:function(a,b){if(a||a===0)return this.animate(K("hide",3),a,b);else{a=0;for(b=this.length;a<b;a++){var d=c.data(this[a],"olddisplay");!d&&d!=="none"&&c.data(this[a],
			"olddisplay",c.css(this[a],"display"))}a=0;for(b=this.length;a<b;a++)this[a].style.display="none";return this}},_toggle:c.fn.toggle,toggle:function(a,b){var d=typeof a==="boolean";if(c.isFunction(a)&&c.isFunction(b))this._toggle.apply(this,arguments);else a==null||d?this.each(function(){var f=d?a:c(this).is(":hidden");c(this)[f?"show":"hide"]()}):this.animate(K("toggle",3),a,b);return this},fadeTo:function(a,b,d){return this.filter(":hidden").css("opacity",0).show().end().animate({opacity:b},a,d)},
			animate:function(a,b,d,f){var e=c.speed(b,d,f);if(c.isEmptyObject(a))return this.each(e.complete);return this[e.queue===false?"each":"queue"](function(){var j=c.extend({},e),i,o=this.nodeType===1&&c(this).is(":hidden"),k=this;for(i in a){var n=i.replace(ia,ja);if(i!==n){a[n]=a[i];delete a[i];i=n}if(a[i]==="hide"&&o||a[i]==="show"&&!o)return j.complete.call(this);if((i==="height"||i==="width")&&this.style){j.display=c.css(this,"display");j.overflow=this.style.overflow}if(c.isArray(a[i])){(j.specialEasing=
			j.specialEasing||{})[i]=a[i][1];a[i]=a[i][0]}}if(j.overflow!=null)this.style.overflow="hidden";j.curAnim=c.extend({},a);c.each(a,function(r,u){var z=new c.fx(k,j,r);if(Ab.test(u))z[u==="toggle"?o?"show":"hide":u](a);else{var C=Bb.exec(u),B=z.cur(true)||0;if(C){u=parseFloat(C[2]);var E=C[3]||"px";if(E!=="px"){k.style[r]=(u||1)+E;B=(u||1)/z.cur(true)*B;k.style[r]=B+E}if(C[1])u=(C[1]==="-="?-1:1)*u+B;z.custom(B,u,E)}else z.custom(B,u,"")}});return true})},stop:function(a,b){var d=c.timers;a&&this.queue([]);
			this.each(function(){for(var f=d.length-1;f>=0;f--)if(d[f].elem===this){b&&d[f](true);d.splice(f,1)}});b||this.dequeue();return this}});c.each({slideDown:K("show",1),slideUp:K("hide",1),slideToggle:K("toggle",1),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"}},function(a,b){c.fn[a]=function(d,f){return this.animate(b,d,f)}});c.extend({speed:function(a,b,d){var f=a&&typeof a==="object"?a:{complete:d||!d&&b||c.isFunction(a)&&a,duration:a,easing:d&&b||b&&!c.isFunction(b)&&b};f.duration=c.fx.off?0:typeof f.duration===
			"number"?f.duration:c.fx.speeds[f.duration]||c.fx.speeds._default;f.old=f.complete;f.complete=function(){f.queue!==false&&c(this).dequeue();c.isFunction(f.old)&&f.old.call(this)};return f},easing:{linear:function(a,b,d,f){return d+f*a},swing:function(a,b,d,f){return(-Math.cos(a*Math.PI)/2+0.5)*f+d}},timers:[],fx:function(a,b,d){this.options=b;this.elem=a;this.prop=d;if(!b.orig)b.orig={}}});c.fx.prototype={update:function(){this.options.step&&this.options.step.call(this.elem,this.now,this);(c.fx.step[this.prop]||
			c.fx.step._default)(this);if((this.prop==="height"||this.prop==="width")&&this.elem.style)this.elem.style.display="block"},cur:function(a){if(this.elem[this.prop]!=null&&(!this.elem.style||this.elem.style[this.prop]==null))return this.elem[this.prop];return(a=parseFloat(c.css(this.elem,this.prop,a)))&&a>-10000?a:parseFloat(c.curCSS(this.elem,this.prop))||0},custom:function(a,b,d){function f(j){return e.step(j)}this.startTime=J();this.start=a;this.end=b;this.unit=d||this.unit||"px";this.now=this.start;
			this.pos=this.state=0;var e=this;f.elem=this.elem;if(f()&&c.timers.push(f)&&!W)W=setInterval(c.fx.tick,13)},show:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.show=true;this.custom(this.prop==="width"||this.prop==="height"?1:0,this.cur());c(this.elem).show()},hide:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.hide=true;this.custom(this.cur(),0)},step:function(a){var b=J(),d=true;if(a||b>=this.options.duration+this.startTime){this.now=
			this.end;this.pos=this.state=1;this.update();this.options.curAnim[this.prop]=true;for(var f in this.options.curAnim)if(this.options.curAnim[f]!==true)d=false;if(d){if(this.options.display!=null){this.elem.style.overflow=this.options.overflow;a=c.data(this.elem,"olddisplay");this.elem.style.display=a?a:this.options.display;if(c.css(this.elem,"display")==="none")this.elem.style.display="block"}this.options.hide&&c(this.elem).hide();if(this.options.hide||this.options.show)for(var e in this.options.curAnim)c.style(this.elem,
			e,this.options.orig[e]);this.options.complete.call(this.elem)}return false}else{e=b-this.startTime;this.state=e/this.options.duration;a=this.options.easing||(c.easing.swing?"swing":"linear");this.pos=c.easing[this.options.specialEasing&&this.options.specialEasing[this.prop]||a](this.state,e,0,1,this.options.duration);this.now=this.start+(this.end-this.start)*this.pos;this.update()}return true}};c.extend(c.fx,{tick:function(){for(var a=c.timers,b=0;b<a.length;b++)a[b]()||a.splice(b--,1);a.length||
			c.fx.stop()},stop:function(){clearInterval(W);W=null},speeds:{slow:600,fast:200,_default:400},step:{opacity:function(a){c.style(a.elem,"opacity",a.now)},_default:function(a){if(a.elem.style&&a.elem.style[a.prop]!=null)a.elem.style[a.prop]=(a.prop==="width"||a.prop==="height"?Math.max(0,a.now):a.now)+a.unit;else a.elem[a.prop]=a.now}}});if(c.expr&&c.expr.filters)c.expr.filters.animated=function(a){return c.grep(c.timers,function(b){return a===b.elem}).length};c.fn.offset="getBoundingClientRect"in s.documentElement?
			function(a){var b=this[0];if(a)return this.each(function(e){c.offset.setOffset(this,a,e)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return c.offset.bodyOffset(b);var d=b.getBoundingClientRect(),f=b.ownerDocument;b=f.body;f=f.documentElement;return{top:d.top+(self.pageYOffset||c.support.boxModel&&f.scrollTop||b.scrollTop)-(f.clientTop||b.clientTop||0),left:d.left+(self.pageXOffset||c.support.boxModel&&f.scrollLeft||b.scrollLeft)-(f.clientLeft||b.clientLeft||0)}}:function(a){var b=
			this[0];if(a)return this.each(function(r){c.offset.setOffset(this,a,r)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return c.offset.bodyOffset(b);c.offset.initialize();var d=b.offsetParent,f=b,e=b.ownerDocument,j,i=e.documentElement,o=e.body;f=(e=e.defaultView)?e.getComputedStyle(b,null):b.currentStyle;for(var k=b.offsetTop,n=b.offsetLeft;(b=b.parentNode)&&b!==o&&b!==i;){if(c.offset.supportsFixedPosition&&f.position==="fixed")break;j=e?e.getComputedStyle(b,null):b.currentStyle;
			k-=b.scrollTop;n-=b.scrollLeft;if(b===d){k+=b.offsetTop;n+=b.offsetLeft;if(c.offset.doesNotAddBorder&&!(c.offset.doesAddBorderForTableAndCells&&/^t(able|d|h)$/i.test(b.nodeName))){k+=parseFloat(j.borderTopWidth)||0;n+=parseFloat(j.borderLeftWidth)||0}f=d;d=b.offsetParent}if(c.offset.subtractsBorderForOverflowNotVisible&&j.overflow!=="visible"){k+=parseFloat(j.borderTopWidth)||0;n+=parseFloat(j.borderLeftWidth)||0}f=j}if(f.position==="relative"||f.position==="static"){k+=o.offsetTop;n+=o.offsetLeft}if(c.offset.supportsFixedPosition&&
			f.position==="fixed"){k+=Math.max(i.scrollTop,o.scrollTop);n+=Math.max(i.scrollLeft,o.scrollLeft)}return{top:k,left:n}};c.offset={initialize:function(){var a=s.body,b=s.createElement("div"),d,f,e,j=parseFloat(c.curCSS(a,"marginTop",true))||0;c.extend(b.style,{position:"absolute",top:0,left:0,margin:0,border:0,width:"1px",height:"1px",visibility:"hidden"});b.innerHTML="<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>";
			a.insertBefore(b,a.firstChild);d=b.firstChild;f=d.firstChild;e=d.nextSibling.firstChild.firstChild;this.doesNotAddBorder=f.offsetTop!==5;this.doesAddBorderForTableAndCells=e.offsetTop===5;f.style.position="fixed";f.style.top="20px";this.supportsFixedPosition=f.offsetTop===20||f.offsetTop===15;f.style.position=f.style.top="";d.style.overflow="hidden";d.style.position="relative";this.subtractsBorderForOverflowNotVisible=f.offsetTop===-5;this.doesNotIncludeMarginInBodyOffset=a.offsetTop!==j;a.removeChild(b);
			c.offset.initialize=c.noop},bodyOffset:function(a){var b=a.offsetTop,d=a.offsetLeft;c.offset.initialize();if(c.offset.doesNotIncludeMarginInBodyOffset){b+=parseFloat(c.curCSS(a,"marginTop",true))||0;d+=parseFloat(c.curCSS(a,"marginLeft",true))||0}return{top:b,left:d}},setOffset:function(a,b,d){if(/static/.test(c.curCSS(a,"position")))a.style.position="relative";var f=c(a),e=f.offset(),j=parseInt(c.curCSS(a,"top",true),10)||0,i=parseInt(c.curCSS(a,"left",true),10)||0;if(c.isFunction(b))b=b.call(a,
			d,e);d={top:b.top-e.top+j,left:b.left-e.left+i};"using"in b?b.using.call(a,d):f.css(d)}};c.fn.extend({position:function(){if(!this[0])return null;var a=this[0],b=this.offsetParent(),d=this.offset(),f=/^body|html$/i.test(b[0].nodeName)?{top:0,left:0}:b.offset();d.top-=parseFloat(c.curCSS(a,"marginTop",true))||0;d.left-=parseFloat(c.curCSS(a,"marginLeft",true))||0;f.top+=parseFloat(c.curCSS(b[0],"borderTopWidth",true))||0;f.left+=parseFloat(c.curCSS(b[0],"borderLeftWidth",true))||0;return{top:d.top-
			f.top,left:d.left-f.left}},offsetParent:function(){return this.map(function(){for(var a=this.offsetParent||s.body;a&&!/^body|html$/i.test(a.nodeName)&&c.css(a,"position")==="static";)a=a.offsetParent;return a})}});c.each(["Left","Top"],function(a,b){var d="scroll"+b;c.fn[d]=function(f){var e=this[0],j;if(!e)return null;if(f!==w)return this.each(function(){if(j=wa(this))j.scrollTo(!a?f:c(j).scrollLeft(),a?f:c(j).scrollTop());else this[d]=f});else return(j=wa(e))?"pageXOffset"in j?j[a?"pageYOffset":
			"pageXOffset"]:c.support.boxModel&&j.document.documentElement[d]||j.document.body[d]:e[d]}});c.each(["Height","Width"],function(a,b){var d=b.toLowerCase();c.fn["inner"+b]=function(){return this[0]?c.css(this[0],d,false,"padding"):null};c.fn["outer"+b]=function(f){return this[0]?c.css(this[0],d,false,f?"margin":"border"):null};c.fn[d]=function(f){var e=this[0];if(!e)return f==null?null:this;if(c.isFunction(f))return this.each(function(j){var i=c(this);i[d](f.call(this,j,i[d]()))});return"scrollTo"in
			e&&e.document?e.document.compatMode==="CSS1Compat"&&e.document.documentElement["client"+b]||e.document.body["client"+b]:e.nodeType===9?Math.max(e.documentElement["client"+b],e.body["scroll"+b],e.documentElement["scroll"+b],e.body["offset"+b],e.documentElement["offset"+b]):f===w?c.css(e,d):this.css(d,typeof f==="string"?f:f+"px")}});A.jQuery=A.$=c})(window);
			
			/* jquery.sparkline 1.5.1 - http://omnipotent.net/jquery.sparkline/ */

			(function($){$.fn.simpledraw=function(width,height,use_existing){if(use_existing&&this[0].vcanvas)return this[0].vcanvas;if(width==undefined)width=$(this).innerWidth();if(height==undefined)height=$(this).innerHeight();if($.browser.hasCanvas){return new vcanvas_canvas(width,height,this);}else if($.browser.msie){return new vcanvas_vml(width,height,this);}else{return false;}};var pending=[];$.fn.sparkline=function(uservalues,options){var options=$.extend({type:'line',lineColor:'#00f',fillColor:'#cdf',defaultPixelsPerValue:3,width:'auto',height:'auto',composite:false},options?options:{});return this.each(function(){var render=function(){var values=(uservalues=='html'||uservalues==undefined)?$(this).text().split(','):uservalues;var width=options.width=='auto'?values.length*options.defaultPixelsPerValue:options.width;if(options.height=='auto'){if(!options.composite||!this.vcanvas){var tmp=document.createElement('span');tmp.innerHTML='a';$(this).html(tmp);height=$(tmp).innerHeight();$(tmp).remove();}}else{height=options.height;}
			$.fn.sparkline[options.type].call(this,values,options,width,height);}
			if(($(this).html()&&$(this).is(':hidden'))||($.fn.jquery<"1.3.0"&&$(this).parents().is(':hidden'))){pending.push([this,render]);}else{render.call(this);}});};$.sparkline_display_visible=function(){for(var i=pending.length-1;i>=0;i--){var el=pending[i][0];if($(el).is(':visible')&&!$(el).parents().is(':hidden')){pending[i][1].call(el);pending.splice(i,1);}}};$.fn.sparkline.line=function(values,options,width,height){var options=$.extend({spotColor:'#f80',spotRadius:1.5,minSpotColor:'#f80',maxSpotColor:'#f80',lineWidth:1,normalRangeMin:undefined,normalRangeMax:undefined,normalRangeColor:'#ccc',chartRangeMin:undefined,chartRangeMax:undefined,chartRangeMinX:undefined,chartRangeMaxX:undefined},options?options:{});var xvalues=[],yvalues=[],yminmax=[];for(i=0;i<values.length;i++){var v=values[i];var isstr=typeof(values[i])=='string';var isarray=typeof(values[i])=='object'&&values[i]instanceof Array;var sp=isstr&&values[i].split(':');if(isstr&&sp.length==2){xvalues.push(Number(sp[0]));yvalues.push(Number(sp[1]));yminmax.push(Number(sp[1]));}else if(isarray){xvalues.push(values[i][0]);yvalues.push(values[i][1]);yminmax.push(values[i][1]);}else{xvalues.push(i);if(values[i]===null||values[i]=='null'){yvalues.push(null);}else{yvalues.push(Number(values[i]));yminmax.push(Number(values[i]));}}}
			if(options.xvalues){xvalues=options.xvalues;}
			var maxy=Math.max.apply(Math,yminmax);var maxyval=maxy;var miny=Math.min.apply(Math,yminmax);var minyval=miny;var maxx=Math.max.apply(Math,xvalues);var maxxval=maxx;var minx=Math.min.apply(Math,xvalues);var minxval=minx;if(options.normalRangeMin!=undefined){if(options.normalRangeMin<miny)
			miny=options.normalRangeMin;if(options.normalRangeMax>maxy)
			maxy=options.normalRangeMax;}
			if(options.chartRangeMin!=undefined&&(options.chartRangeClip||options.chartRangeMin<miny)){miny=options.chartRangeMin;}
			if(options.chartRangeMax!=undefined&&(options.chartRangeClip||options.chartRangeMax>maxy)){maxy=options.chartRangeMax;}
			if(options.chartRangeMinX!=undefined&&(options.chartRangeClipX||options.chartRangeMinX<minx)){minx=options.chartRangeMinX;}
			if(options.chartRangeMaxX!=undefined&&(options.chartRangeClipX||options.chartRangeMaxX>maxx)){maxx=options.chartRangeMaxX;}
			var rangex=maxx-minx==0?1:maxx-minx;var rangey=maxy-miny==0?1:maxy-miny;var vl=yvalues.length-1;if(vl<1){this.innerHTML='';return;}
			var target=$(this).simpledraw(width,height,options.composite);if(target){var canvas_width=target.pixel_width;var canvas_height=target.pixel_height;var canvas_top=0;var canvas_left=0;if(options.spotRadius&&(canvas_width<(options.spotRadius*4)||canvas_height<(options.spotRadius*4))){options.spotRadius=0;}
			if(options.spotRadius){if(options.minSpotColor||(options.spotColor&&yvalues[vl]==miny))
			canvas_height-=Math.ceil(options.spotRadius);if(options.maxSpotColor||(options.spotColor&&yvalues[vl]==maxy)){canvas_height-=Math.ceil(options.spotRadius);canvas_top+=Math.ceil(options.spotRadius);}
			if(options.minSpotColor||options.maxSpotColor&&(yvalues[0]==miny||yvalues[0]==maxy)){canvas_left+=Math.ceil(options.spotRadius);canvas_width-=Math.ceil(options.spotRadius);}
			if(options.spotColor||(options.minSpotColor||options.maxSpotColor&&(yvalues[vl]==miny||yvalues[vl]==maxy)))
			canvas_width-=Math.ceil(options.spotRadius);}
			canvas_height--;if(options.normalRangeMin!=undefined){var ytop=canvas_top+Math.round(canvas_height-(canvas_height*((options.normalRangeMax-miny)/rangey)));var height=Math.round((canvas_height*(options.normalRangeMax-options.normalRangeMin))/rangey);target.drawRect(canvas_left,ytop,canvas_width,height,undefined,options.normalRangeColor);}
			var path=[];var paths=[path];for(var i=0,vlen=yvalues.length;i<vlen;i++){var x=xvalues[i],y=yvalues[i];if(y===null){if(i){if(yvalues[i-1]!==null){path=[];paths.push(path);}}}else{if(y<miny)y=miny;if(y>maxy)y=maxy;if(!path.length){path.push([canvas_left+Math.round((x-minx)*(canvas_width/rangex)),canvas_top+canvas_height]);}
			path.push([canvas_left+Math.round((x-minx)*(canvas_width/rangex)),canvas_top+Math.round(canvas_height-(canvas_height*((y-miny)/rangey)))]);}}
			for(var i=0,plen=paths.length;i<plen;i++){path=paths[i];if(!path.length)
			continue;if(options.fillColor){path.push([path[path.length-1][0],canvas_top+canvas_height-1]);target.drawShape(path,undefined,options.fillColor);path.pop();}
			if(path.length>2){path[0]=[path[0][0],path[1][1]];}
			target.drawShape(path,options.lineColor,undefined,options.lineWidth);}
			if(options.spotRadius&&options.spotColor){target.drawCircle(canvas_left+Math.round(xvalues[xvalues.length-1]*(canvas_width/rangex)),canvas_top+Math.round(canvas_height-(canvas_height*((yvalues[vl]-miny)/rangey))),options.spotRadius,undefined,options.spotColor);}
			if(maxy!=minyval){if(options.spotRadius&&options.minSpotColor){var x=xvalues[yvalues.indexOf(minyval)];target.drawCircle(canvas_left+Math.round((x-minx)*(canvas_width/rangex)),canvas_top+Math.round(canvas_height-(canvas_height*((minyval-miny)/rangey))),options.spotRadius,undefined,options.minSpotColor);}
			if(options.spotRadius&&options.maxSpotColor){var x=xvalues[yvalues.indexOf(maxyval)];target.drawCircle(canvas_left+Math.round((x-minx)*(canvas_width/rangex)),canvas_top+Math.round(canvas_height-(canvas_height*((maxyval-miny)/rangey))),options.spotRadius,undefined,options.maxSpotColor);}}}else{this.innerHTML='';}};$.fn.sparkline.bar=function(values,options,width,height){var options=$.extend({type:'bar',barColor:'#00f',negBarColor:'#f44',zeroColor:undefined,nullColor:undefined,zeroAxis:undefined,barWidth:4,barSpacing:1,chartRangeMax:undefined,chartRangeMin:undefined,chartRangeClip:false,colorMap:undefined},options?options:{});var width=(values.length*options.barWidth)+((values.length-1)*options.barSpacing);var num_values=[];for(var i=0,vlen=values.length;i<vlen;i++){if(values[i]=='null'||values[i]===null){values[i]=null;}else{values[i]=Number(values[i]);num_values.push(Number(values[i]));}}
			var max=Math.max.apply(Math,num_values);var min=Math.min.apply(Math,num_values);if(options.chartRangeMin!=undefined&&(options.chartRangeClip||options.chartRangeMin<min)){min=options.chartRangeMin;}
			if(options.chartRangeMax!=undefined&&(options.chartRangeClip||options.chartRangeMax>max)){max=options.chartRangeMax;}
			if(options.zeroAxis==undefined)options.zeroAxis=min<0;var range=max-min==0?1:max-min;if($.isArray(options.colorMap)){var colorMapByIndex=options.colorMap;var colorMapByValue=null;}else{var colorMapByIndex=null;var colorMapByValue=options.colorMap;}
			var target=$(this).simpledraw(width,height,options.composite);if(target){var canvas_width=target.pixel_width;var canvas_height=target.pixel_height;var yzero=min<0&&options.zeroAxis?canvas_height-Math.round(canvas_height*(Math.abs(min)/range))-1:canvas_height-1;for(var i=0,vlen=values.length;i<vlen;i++){var x=i*(options.barWidth+options.barSpacing);var val=values[i];if(val===null){if(options.nullColor){color=options.nullColor;val=(options.zeroAxis&&min<0)?0:min;var height=1;var y=(options.zeroAxis&&min<0)?yzero:canvas_height-height;}else{continue;}}else{if(val<min)val=min;if(val>max)val=max;var color=(val<0)?options.negBarColor:options.barColor;if(options.zeroAxis&&min<0){var height=Math.round(canvas_height*((Math.abs(val)/range)))+1;var y=(val<0)?yzero:yzero-height;}else{var height=Math.round(canvas_height*((val-min)/range))+1;var y=canvas_height-height;}
			if(val==0&&options.zeroColor!=undefined){color=options.zeroColor;}
			if(colorMapByValue&&colorMapByValue[val]){color=colorMapByValue[val];}else if(colorMapByIndex&&colorMapByIndex.length>i){color=colorMapByIndex[i];}
			if(color===null){continue;}}
			target.drawRect(x,y,options.barWidth-1,height-1,color,color);}}else{this.innerHTML='';}};$.fn.sparkline.tristate=function(values,options,width,height){values=$.map(values,Number);var options=$.extend({barWidth:4,barSpacing:1,posBarColor:'#6f6',negBarColor:'#f44',zeroBarColor:'#999',colorMap:{}},options);var width=(values.length*options.barWidth)+((values.length-1)*options.barSpacing);if($.isArray(options.colorMap)){var colorMapByIndex=options.colorMap;var colorMapByValue=null;}else{var colorMapByIndex=null;var colorMapByValue=options.colorMap;}
			var target=$(this).simpledraw(width,height,options.composite);if(target){var canvas_width=target.pixel_width;var canvas_height=target.pixel_height;var half_height=Math.round(canvas_height/2);for(var i=0,vlen=values.length;i<vlen;i++){var x=i*(options.barWidth+options.barSpacing);if(values[i]<0){var y=half_height;var height=half_height-1;var color=options.negBarColor;}else if(values[i]>0){var y=0;var height=half_height-1;var color=options.posBarColor;}else{var y=half_height-1;var height=2;var color=options.zeroBarColor;}
			if(colorMapByValue&&colorMapByValue[values[i]]){color=colorMapByValue[values[i]];}else if(colorMapByIndex&&colorMapByIndex.length>i){color=colorMapByIndex[i];}
			if(color===null){continue;}
			target.drawRect(x,y,options.barWidth-1,height-1,color,color);}}else{this.innerHTML='';}};$.fn.sparkline.discrete=function(values,options,width,height){values=$.map(values,Number);var options=$.extend({lineHeight:'auto',thresholdColor:undefined,thresholdValue:0,chartRangeMax:undefined,chartRangeMin:undefined,chartRangeClip:false},options);width=options.width=='auto'?values.length*2:width;var interval=Math.floor(width/values.length);var target=$(this).simpledraw(width,height,options.composite);if(target){var canvas_width=target.pixel_width;var canvas_height=target.pixel_height;var line_height=options.lineHeight=='auto'?Math.round(canvas_height*0.3):options.lineHeight;var pheight=canvas_height-line_height;var min=Math.min.apply(Math,values);var max=Math.max.apply(Math,values);if(options.chartRangeMin!=undefined&&(options.chartRangeClip||options.chartRangeMin<min)){min=options.chartRangeMin;}
			if(options.chartRangeMax!=undefined&&(options.chartRangeClip||options.chartRangeMax>max)){max=options.chartRangeMax;}
			var range=max-min;for(var i=0,vlen=values.length;i<vlen;i++){var val=values[i];if(val<min)val=min;if(val>max)val=max;var x=(i*interval);var ytop=Math.round(pheight-pheight*((val-min)/range));target.drawLine(x,ytop,x,ytop+line_height,(options.thresholdColor&&val<options.thresholdValue)?options.thresholdColor:options.lineColor);}}else{this.innerHTML='';}};$.fn.sparkline.bullet=function(values,options,width,height){values=$.map(values,Number);var options=$.extend({targetColor:'red',targetWidth:3,performanceColor:'blue',rangeColors:['#D3DAFE','#A8B6FF','#7F94FF'],base:undefined},options);width=options.width=='auto'?'4.0em':width;var target=$(this).simpledraw(width,height,options.composite);if(target&&values.length>1){var canvas_width=target.pixel_width-Math.ceil(options.targetWidth/2);var canvas_height=target.pixel_height;var min=Math.min.apply(Math,values);var max=Math.max.apply(Math,values);if(options.base==undefined){var min=min<0?min:0;}else{min=options.base;}
			var range=max-min;for(i=2,vlen=values.length;i<vlen;i++){var rangeval=parseInt(values[i]);var rangewidth=Math.round(canvas_width*((rangeval-min)/range));target.drawRect(0,0,rangewidth-1,canvas_height-1,options.rangeColors[i-2],options.rangeColors[i-2]);}
			var perfval=parseInt(values[1]);var perfwidth=Math.round(canvas_width*((perfval-min)/range));target.drawRect(0,Math.round(canvas_height*0.3),perfwidth-1,Math.round(canvas_height*0.4)-1,options.performanceColor,options.performanceColor);var targetval=parseInt(values[0]);var x=Math.round(canvas_width*((targetval-min)/range)-(options.targetWidth/2));var targettop=Math.round(canvas_height*0.10);var targetheight=canvas_height-(targettop*2);target.drawRect(x,targettop,options.targetWidth-1,targetheight-1,options.targetColor,options.targetColor);}else{this.innerHTML='';}};$.fn.sparkline.pie=function(values,options,width,height){values=$.map(values,Number);var options=$.extend({sliceColors:['#f00','#0f0','#00f']},options);width=options.width=='auto'?height:width;var target=$(this).simpledraw(width,height,options.composite);if(target&&values.length>1){var canvas_width=target.pixel_width;var canvas_height=target.pixel_height;var radius=Math.floor(Math.min(canvas_width,canvas_height)/2);var total=0;for(var i=0,vlen=values.length;i<vlen;i++)
			total+=values[i];var next=0;if(options.offset){next+=(2*Math.PI)*(options.offset/360);}
			var circle=2*Math.PI;for(var i=0,vlen=values.length;i<vlen;i++){var start=next;var end=next;if(total>0){end=next+(circle*(values[i]/total));}
			target.drawPieSlice(radius,radius,radius,start,end,undefined,options.sliceColors[i%options.sliceColors.length]);next=end;}}};function quartile(values,q){if(q==2){var vl2=Math.floor(values.length/2);return values.length%2?values[vl2]:(values[vl2]+values[vl2+1])/2;}else{var vl4=Math.floor(values.length/4);return values.length%2?(values[vl4*q]+values[vl4*q+1])/2:values[vl4*q];}};$.fn.sparkline.box=function(values,options,width,height){values=$.map(values,Number);var options=$.extend({raw:false,boxLineColor:'black',boxFillColor:'#cdf',whiskerColor:'black',outlierLineColor:'#333',outlierFillColor:'white',medianColor:'red',showOutliers:true,outlierIQR:1.5,spotRadius:1.5,target:undefined,targetColor:'#4a2',chartRangeMax:undefined,chartRangeMin:undefined},options);width=options.width=='auto'?'4.0em':width;minvalue=options.chartRangeMin==undefined?Math.min.apply(Math,values):options.chartRangeMin;maxvalue=options.chartRangeMax==undefined?Math.max.apply(Math,values):options.chartRangeMax;var target=$(this).simpledraw(width,height,options.composite);if(target&&values.length>1){var canvas_width=target.pixel_width;var canvas_height=target.pixel_height;if(options.raw){if(options.showOutliers&&values.length>5){var loutlier=values[0],lwhisker=values[1],q1=values[2],q2=values[3],q3=values[4],rwhisker=values[5],routlier=values[6];}else{var lwhisker=values[0],q1=values[1],q2=values[2],q3=values[3],rwhisker=values[4];}}else{values.sort(function(a,b){return a-b;});var q1=quartile(values,1);var q2=quartile(values,2);var q3=quartile(values,3);var iqr=q3-q1;if(options.showOutliers){var lwhisker=undefined,rwhisker=undefined;for(var i=0,vlen=values.length;i<vlen;i++){if(lwhisker==undefined&&values[i]>q1-(iqr*options.outlierIQR))
			lwhisker=values[i];if(values[i]<q3+(iqr*options.outlierIQR))
			rwhisker=values[i];}
			var loutlier=values[0];var routlier=values[values.length-1];}else{var lwhisker=values[0];var rwhisker=values[values.length-1];}}
			var unitsize=canvas_width/(maxvalue-minvalue+1);var canvas_left=0;if(options.showOutliers){canvas_left=Math.ceil(options.spotRadius);canvas_width-=2*Math.ceil(options.spotRadius);var unitsize=canvas_width/(maxvalue-minvalue+1);if(loutlier<lwhisker)
			target.drawCircle((loutlier-minvalue)*unitsize+canvas_left,canvas_height/2,options.spotRadius,options.outlierLineColor,options.outlierFillColor);if(routlier>rwhisker)
			target.drawCircle((routlier-minvalue)*unitsize+canvas_left,canvas_height/2,options.spotRadius,options.outlierLineColor,options.outlierFillColor);}
			target.drawRect(Math.round((q1-minvalue)*unitsize+canvas_left),Math.round(canvas_height*0.1),Math.round((q3-q1)*unitsize),Math.round(canvas_height*0.8),options.boxLineColor,options.boxFillColor);target.drawLine(Math.round((lwhisker-minvalue)*unitsize+canvas_left),Math.round(canvas_height/2),Math.round((q1-minvalue)*unitsize+canvas_left),Math.round(canvas_height/2),options.lineColor);target.drawLine(Math.round((lwhisker-minvalue)*unitsize+canvas_left),Math.round(canvas_height/4),Math.round((lwhisker-minvalue)*unitsize+canvas_left),Math.round(canvas_height-canvas_height/4),options.whiskerColor);target.drawLine(Math.round((rwhisker-minvalue)*unitsize+canvas_left),Math.round(canvas_height/2),Math.round((q3-minvalue)*unitsize+canvas_left),Math.round(canvas_height/2),options.lineColor);target.drawLine(Math.round((rwhisker-minvalue)*unitsize+canvas_left),Math.round(canvas_height/4),Math.round((rwhisker-minvalue)*unitsize+canvas_left),Math.round(canvas_height-canvas_height/4),options.whiskerColor);target.drawLine(Math.round((q2-minvalue)*unitsize+canvas_left),Math.round(canvas_height*0.1),Math.round((q2-minvalue)*unitsize+canvas_left),Math.round(canvas_height*0.9),options.medianColor);if(options.target){var size=Math.ceil(options.spotRadius);target.drawLine(Math.round((options.target-minvalue)*unitsize+canvas_left),Math.round((canvas_height/2)-size),Math.round((options.target-minvalue)*unitsize+canvas_left),Math.round((canvas_height/2)+size),options.targetColor);target.drawLine(Math.round((options.target-minvalue)*unitsize+canvas_left-size),Math.round(canvas_height/2),Math.round((options.target-minvalue)*unitsize+canvas_left+size),Math.round(canvas_height/2),options.targetColor);}}else{this.innerHTML='';}};if(!Array.prototype.indexOf){Array.prototype.indexOf=function(entry){for(var i=0,vlen=this.length;i<vlen;i++){if(this[i]==entry)
			return i;}
			return-1;}}
			if($.browser.msie&&!document.namespaces['v']){document.namespaces.add('v','urn:schemas-microsoft-com:vml','#default#VML');}
			if($.browser.hasCanvas==undefined){var t=document.createElement('canvas');$.browser.hasCanvas=t.getContext!=undefined;}
			var vcanvas_base=function(width,height,target){};vcanvas_base.prototype={init:function(width,height,target){this.width=width;this.height=height;this.target=target;if(target[0])target=target[0];target.vcanvas=this;},drawShape:function(path,lineColor,fillColor,lineWidth){alert('drawShape not implemented');},drawLine:function(x1,y1,x2,y2,lineColor,lineWidth){return this.drawShape([[x1,y1],[x2,y2]],lineColor,lineWidth);},drawCircle:function(x,y,radius,lineColor,fillColor){alert('drawCircle not implemented');},drawPieSlice:function(x,y,radius,startAngle,endAngle,lineColor,fillColor){alert('drawPieSlice not implemented');},drawRect:function(x,y,width,height,lineColor,fillColor){alert('drawRect not implemented');},getElement:function(){return this.canvas;},_insert:function(el,target){$(target).html(el);}};var vcanvas_canvas=function(width,height,target){return this.init(width,height,target);};vcanvas_canvas.prototype=$.extend(new vcanvas_base,{_super:vcanvas_base.prototype,init:function(width,height,target){this._super.init(width,height,target);this.canvas=document.createElement('canvas');if(target[0])target=target[0];target.vcanvas=this;$(this.canvas).css({display:'inline-block',width:width,height:height,verticalAlign:'top'});this._insert(this.canvas,target);this.pixel_height=$(this.canvas).height();this.pixel_width=$(this.canvas).width();this.canvas.width=this.pixel_width;this.canvas.height=this.pixel_height;$(this.canvas).css({width:this.pixel_width,height:this.pixel_height});},_getContext:function(lineColor,fillColor,lineWidth){var context=this.canvas.getContext('2d');if(lineColor!=undefined)
			context.strokeStyle=lineColor;context.lineWidth=lineWidth==undefined?1:lineWidth;if(fillColor!=undefined)
			context.fillStyle=fillColor;return context;},drawShape:function(path,lineColor,fillColor,lineWidth){var context=this._getContext(lineColor,fillColor,lineWidth);context.beginPath();context.moveTo(path[0][0]+0.5,path[0][1]+0.5);for(var i=1,plen=path.length;i<plen;i++){context.lineTo(path[i][0]+0.5,path[i][1]+0.5);}
			if(lineColor!=undefined){context.stroke();}
			if(fillColor!=undefined){context.fill();}},drawCircle:function(x,y,radius,lineColor,fillColor){var context=this._getContext(lineColor,fillColor);context.beginPath();context.arc(x,y,radius,0,2*Math.PI,false);if(lineColor!=undefined){context.stroke();}
			if(fillColor!=undefined){context.fill();}},drawPieSlice:function(x,y,radius,startAngle,endAngle,lineColor,fillColor){var context=this._getContext(lineColor,fillColor);context.beginPath();context.moveTo(x,y);context.arc(x,y,radius,startAngle,endAngle,false);context.lineTo(x,y);context.closePath();if(lineColor!=undefined){context.stroke();}
			if(fillColor){context.fill();}},drawRect:function(x,y,width,height,lineColor,fillColor){return this.drawShape([[x,y],[x+width,y],[x+width,y+height],[x,y+height],[x,y]],lineColor,fillColor);}});var vcanvas_vml=function(width,height,target){return this.init(width,height,target);};vcanvas_vml.prototype=$.extend(new vcanvas_base,{_super:vcanvas_base.prototype,init:function(width,height,target){this._super.init(width,height,target);if(target[0])target=target[0];target.vcanvas=this;this.canvas=document.createElement('span');$(this.canvas).css({display:'inline-block',position:'relative',overflow:'hidden',width:width,height:height,margin:'0px',padding:'0px',verticalAlign:'top'});this._insert(this.canvas,target);this.pixel_height=$(this.canvas).height();this.pixel_width=$(this.canvas).width();this.canvas.width=this.pixel_width;this.canvas.height=this.pixel_height;;var groupel='<v:group coordorigin="0 0" coordsize="'+this.pixel_width+' '+this.pixel_height+'"'
			+' style="position:absolute;top:0;left:0;width:'+this.pixel_width+'px;height='+this.pixel_height+'px;"></v:group>';this.canvas.insertAdjacentHTML('beforeEnd',groupel);this.group=$(this.canvas).children()[0];},drawShape:function(path,lineColor,fillColor,lineWidth){var vpath=[];for(var i=0,plen=path.length;i<plen;i++){vpath[i]=''+(path[i][0])+','+(path[i][1]);}
			var initial=vpath.splice(0,1);lineWidth=lineWidth==undefined?1:lineWidth;var stroke=lineColor==undefined?' stroked="false" ':' strokeWeight="'+lineWidth+'" strokeColor="'+lineColor+'" ';var fill=fillColor==undefined?' filled="false"':' fillColor="'+fillColor+'" filled="true" ';var closed=vpath[0]==vpath[vpath.length-1]?'x ':'';var vel='<v:shape coordorigin="0 0" coordsize="'+this.pixel_width+' '+this.pixel_height+'" '
			+stroke
			+fill
			+' style="position:absolute;left:0px;top:0px;height:'+this.pixel_height+'px;width:'+this.pixel_width+'px;padding:0px;margin:0px;" '
			+' path="m '+initial+' l '+vpath.join(', ')+' '+closed+'e">'
			+' </v:shape>';this.group.insertAdjacentHTML('beforeEnd',vel);},drawCircle:function(x,y,radius,lineColor,fillColor){x-=radius+1;y-=radius+1;var stroke=lineColor==undefined?' stroked="false" ':' strokeWeight="1" strokeColor="'+lineColor+'" ';var fill=fillColor==undefined?' filled="false"':' fillColor="'+fillColor+'" filled="true" ';var vel='<v:oval '
			+stroke
			+fill
			+' style="position:absolute;top:'+y+'px; left:'+x+'px; width:'+(radius*2)+'px; height:'+(radius*2)+'px"></v:oval>';this.group.insertAdjacentHTML('beforeEnd',vel);},drawPieSlice:function(x,y,radius,startAngle,endAngle,lineColor,fillColor){if(startAngle==endAngle){return;}
			if((endAngle-startAngle)==(2*Math.PI)){startAngle=0.0;endAngle=(2*Math.PI);}
			var startx=x+Math.round(Math.cos(startAngle)*radius);var starty=y+Math.round(Math.sin(startAngle)*radius);var endx=x+Math.round(Math.cos(endAngle)*radius);var endy=y+Math.round(Math.sin(endAngle)*radius);if(startx==endx&&starty==endy&&(endAngle-startAngle)<Math.PI)
			return;var vpath=[x-radius,y-radius,x+radius,y+radius,startx,starty,endx,endy];var stroke=lineColor==undefined?' stroked="false" ':' strokeWeight="1" strokeColor="'+lineColor+'" ';var fill=fillColor==undefined?' filled="false"':' fillColor="'+fillColor+'" filled="true" ';var vel='<v:shape coordorigin="0 0" coordsize="'+this.pixel_width+' '+this.pixel_height+'" '
			+stroke
			+fill
			+' style="position:absolute;left:0px;top:0px;height:'+this.pixel_height+'px;width:'+this.pixel_width+'px;padding:0px;margin:0px;" '
			+' path="m '+x+','+y+' wa '+vpath.join(', ')+' x e">'
			+' </v:shape>';this.group.insertAdjacentHTML('beforeEnd',vel);},drawRect:function(x,y,width,height,lineColor,fillColor){return this.drawShape([[x,y],[x,y+height],[x+width,y+height],[x+width,y],[x,y]],lineColor,fillColor);}});})(jQuery);
			
			// ==ClosureCompiler==
			// @compilation_level SIMPLE_OPTIMIZATIONS

			/**
			 * @license Highcharts JS v2.1 alpha (merged changes from master 2010-09-28)
			 * 
			 * (c) 2009-2010 Torstein Hønsi
			 * 
			 * License: www.highcharts.com/license
			 */

			// JSLint options:
			/*jslint forin: true */
			/*global document, window, navigator, setInterval, clearInterval, clearTimeout, setTimeout, location, jQuery, $ */

			(function() {
			// encapsulated variables
			var doc = document,
				win = window,
				math = Math,
				mathRound = math.round,
				mathFloor = math.floor,
				mathCeil = math.ceil,
				mathMax = math.max,
				mathMin = math.min,
				mathAbs = math.abs,
				mathCos = math.cos,
				mathSin = math.sin,
				mathPI = math.PI,
				deg2rad = mathPI * 2 / 360,


				// some variables
				userAgent = navigator.userAgent,
				isIE = /msie/i.test(userAgent) && !win.opera,
				docMode8 = doc.documentMode == 8,
				isWebKit = /AppleWebKit/.test(userAgent),
				hasSVG = win.SVGAngle || doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1"),
				hasTouch = 'ontouchstart' in doc.documentElement,
				colorCounter,
				symbolCounter,
				symbolSizes = {},
				idCounter = 0,
				timeFactor = 1, // 1 = JavaScript time, 1000 = Unix time
				garbageBin,
				defaultOptions,
				dateFormat, // function
				globalAnimation,
				pathAnim,


				// some constants for frequently used strings
				UNDEFINED,
				DIV = 'div',
				ABSOLUTE = 'absolute',
				RELATIVE = 'relative',
				HIDDEN = 'hidden',
				PREFIX = 'highcharts-',
				VISIBLE = 'visible',
				PX = 'px',
				NONE = 'none',
				M = 'M',
				L = 'L',
				/*
				 * Empirical lowest possible opacities for TRACKER_FILL
				 * IE6: 0.002
				 * IE7: 0.002
				 * IE8: 0.002
				 * IE9: 0.00000000001 (unlimited)
				 * FF: 0.00000000001 (unlimited)
				 * Chrome: 0.000001
				 * Safari: 0.000001
				 * Opera: 0.00000000001 (unlimited)
				 */
				TRACKER_FILL = 'rgba(192,192,192,'+ (hasSVG ? 0.000001 : 0.002) +')', // invisible but clickable
				NORMAL_STATE = '',
				HOVER_STATE = 'hover',
				SELECT_STATE = 'select',

				// time methods, changed based on whether or not UTC is used
				makeTime,
				getMinutes,
				getHours,
				getDay,
				getDate,
				getMonth,
				getFullYear,
				setMinutes,
				setHours,
				setDate,
				setMonth,
				setFullYear,

				// check for a custom HighchartsAdapter defined prior to this file
				globalAdapter = win.HighchartsAdapter,
				adapter = globalAdapter || {}, 

				// Utility functions. If the HighchartsAdapter is not defined, adapter is an empty object
				// and all the utility functions will be null. In that case they are populated by the 
				// default adapters below.
				each = adapter.each,
				grep = adapter.grep,
				map = adapter.map,
				merge = adapter.merge,
				hyphenate = adapter.hyphenate,
				addEvent = adapter.addEvent,
				removeEvent = adapter.removeEvent,
				fireEvent = adapter.fireEvent,
				animate = adapter.animate,
				stop = adapter.stop,

				// lookup over the types and the associated classes
				seriesTypes = {};

			/**
			 * Extend an object with the members of another
			 * @param {Object} a The object to be extended
			 * @param {Object} b The object to add to the first one
			 */
			function extend(a, b) {
				if (!a) {
					a = {};
				}
				for (var n in b) {
					a[n] = b[n];
				}
				return a;
			}

			/**
			 * Shortcut for parseInt
			 * @param {Object} s
			 */
			function pInt(s, mag) {
				return parseInt(s, mag || 10);
			}

			/**
			 * Check for string
			 * @param {Object} s
			 */
			function isString(s) {
				return typeof s == 'string';
			}

			/**
			 * Check for object
			 * @param {Object} obj
			 */
			function isObject(obj) {
				return typeof obj == 'object';
			}

			/**
			 * Check for number
			 * @param {Object} n
			 */
			function isNumber(n) {
				return typeof n == 'number';
			}

			/**
			 * Remove last occurence of an item from an array
			 * @param {Array} arr
			 * @param {Mixed} item
			 */
			function erase(arr, item) {
				var i = arr.length;
				while (i--) {
					if (arr[i] == item) {
						arr.splice(i, 1);
						break;
					}
				}
				//return arr;
			}

			/**
			 * Returns true if the object is not null or undefined. Like MooTools' $.defined.
			 * @param {Object} obj
			 */
			function defined (obj) {
				return obj !== UNDEFINED && obj !== null;
			}

			/**
			 * Set or get an attribute or an object of attributes. Can't use jQuery attr because
			 * it attempts to set expando properties on the SVG element, which is not allowed.
			 * 
			 * @param {Object} elem The DOM element to receive the attribute(s)
			 * @param {String|Object} prop The property or an abject of key-value pairs
			 * @param {String} value The value if a single property is set
			 */
			function attr(elem, prop, value) {
				var key,
					setAttribute = 'setAttribute',
					ret;

				// if the prop is a string
				if (isString(prop)) {
					// set the value
					if (defined(value)) {
						elem[setAttribute](prop, value);

					// get the value
					} else if (elem && elem.getAttribute) { // elem not defined when printing pie demo...
						ret = elem.getAttribute(prop);
					}

				// else if prop is defined, it is a hash of key/value pairs
				} else if (defined(prop) && isObject(prop)) {
					for (key in prop) {
						elem[setAttribute](key, prop[key]);
					}
				}
				return ret;
			}
			/**
			 * Check if an element is an array, and if not, make it into an array. Like
			 * MooTools' $.splat.
			 */
			function splat(obj) {
				if (!obj || obj.constructor != Array) {
					obj = [obj];
				}
				return obj; 
			}



			/**
			 * Return the first value that is defined. Like MooTools' $.pick.
			 */
			function pick() {
				var args = arguments,
					i,
					arg;
				for (i = 0; i < args.length; i++) {
					arg = args[i];
					if (defined(arg)) {
						return arg;
					}
				}
			}
			/**
			 * Make a style string from a JS object
			 * @param {Object} style
			 */
			function serializeCSS(style) {
				var s = '', 
					key;
				// serialize the declaration
				for (key in style) {
					s += hyphenate(key) +':'+ style[key] + ';';
				}
				return s;

			}
			/**
			 * Set CSS on a give element
			 * @param {Object} el
			 * @param {Object} styles
			 */
			function css (el, styles) {
				if (isIE) {
					if (styles && styles.opacity !== UNDEFINED) {
						styles.filter = 'alpha(opacity='+ (styles.opacity * 100) +')';
					}
				}
				extend(el.style, styles);
			}

			/**
			 * Utility function to create element with attributes and styles
			 * @param {Object} tag
			 * @param {Object} attribs
			 * @param {Object} styles
			 * @param {Object} parent
			 * @param {Object} nopad
			 */
			function createElement (tag, attribs, styles, parent, nopad) {
				var el = doc.createElement(tag);
				if (attribs) {
					extend(el, attribs);
				}
				if (nopad) {
					css(el, {padding: 0, border: NONE, margin: 0});
				}
				if (styles) {
					css(el, styles);
				}
				if (parent) {
					parent.appendChild(el);
				}	
				return el;
			}

			/**
			 * Set the global animation to either a given value, or fall back to the 
			 * given chart's animation option
			 * @param {Object} animation
			 * @param {Object} chart
			 */
			function setAnimation(animation, chart) {
				globalAnimation = pick(animation, chart.animation);
			}

			/* 
			 * Define the adapter for frameworks. If an external adapter is not defined, 
			 * Highcharts reverts to the built-in jQuery adapter.
			 */
			if (globalAdapter && globalAdapter.init) {
				globalAdapter.init();
			} 
			if (!globalAdapter && win.jQuery) {
				var jQ = jQuery;

				/**
				 * Utility for iterating over an array. Parameters are reversed compared to jQuery.
				 * @param {Array} arr
				 * @param {Function} fn
				 */
				each = function(arr, fn) {
					for (var i = 0, len = arr.length; i < len; i++) {
						if (fn.call(arr[i], arr[i], i, arr) === false) {
							return i;
						}
					}
				};

				/**
				 * Filter an array
				 */
				grep = jQ.grep;

				/**
				 * Map an array
				 * @param {Array} arr
				 * @param {Function} fn
				 */
				map = function(arr, fn){
					//return jQuery.map(arr, fn);
					var results = [];
					for (var i = 0, len = arr.length; i < len; i++) {
						results[i] = fn.call(arr[i], arr[i], i, arr);
					}
					return results;

				};

				/**
				 * Deep merge two objects and return a third object
				 */
				merge = function(){
					var args = arguments;
					return jQ.extend(true, null, args[0], args[1], args[2], args[3]);
				};

				/**
				 * Convert a camelCase string to a hyphenated string
				 * @param {String} str
				 */
				hyphenate = function (str) {
					return str.replace(/([A-Z])/g, function(a, b){ return '-'+ b.toLowerCase(); });
				};

				/**
				 * Add an event listener
				 * @param {Object} el A HTML element or custom object
				 * @param {String} event The event type
				 * @param {Function} fn The event handler
				 */
				addEvent = function (el, event, fn){
					jQ(el).bind(event, fn);
				};

				/**
				 * Remove event added with addEvent
				 * @param {Object} el The object
				 * @param {String} eventType The event type. Leave blank to remove all events.
				 * @param {Function} handler The function to remove
				 */
				removeEvent = function(el, eventType, handler) {
					// workaround for jQuery issue with unbinding custom events:
					// http://forum.jquery.com/topic/javascript-error-when-unbinding-a-custom-event-using-jquery-1-4-2
					var func = doc.removeEventListener ? 'removeEventListener' : 'detachEvent';
					if (doc[func] && !el[func]) {
						el[func] = function() {};
					}

					jQ(el).unbind(eventType, handler);
				};

				/**
				 * Fire an event on a custom object
				 * @param {Object} el
				 * @param {String} type
				 * @param {Object} eventArguments
				 * @param {Function} defaultFunction
				 */
				fireEvent = function(el, type, eventArguments, defaultFunction) {
					var event = jQ.Event(type),
						detachedType = 'detached'+ type;
					extend(event, eventArguments);

					// Prevent jQuery from triggering the object method that is named the
					// same as the event. For example, if the event is 'select', jQuery
					// attempts calling el.select and it goes into a loop.
					if (el[type]) {
						el[detachedType] = el[type];
						el[type] = null;	
					}

					// trigger it
					jQ(el).trigger(event);

					// attach the method
					if (el[detachedType]) {
						el[type] = el[detachedType];
						el[detachedType] = null;
					}

					if (defaultFunction && !event.isDefaultPrevented()) {
						defaultFunction(event);
					}	
				};

				/**
				 * Animate a HTML element or SVG element wrapper
				 * @param {Object} el
				 * @param {Object} params
				 * @param {Object} options jQuery-like animation options: duration, easing, callback
				 */
				animate = function (el, params, options) {
					var $el = jQ(el);
					if (params.d) {
						el.toD = params.d; // keep the array form for paths, used in jQ.fx.step.d
						params.d = 1; // because in jQuery, animating to an array has a different meaning
					}

					$el.stop();
					$el.animate(params, options);
				};
				/**
				 * Stop running animation
				 */
				stop = function (el) {
					jQ(el).stop();
				};


				// extend jQuery
				jQ.extend( jQ.easing, {
					easeOutQuad: function (x, t, b, c, d) {
						return -c *(t/=d)*(t-2) + b;
					}
				});

				// extend the animate function to allow SVG animations
				var oldStepDefault = jQuery.fx.step._default, 
					oldCur = jQuery.fx.prototype.cur;

				// do the step
				jQ.fx.step._default = function(fx){
					var elem = fx.elem;
					if (elem.attr) { // is SVG element wrapper
						elem.attr(fx.prop, fx.now);			
					} else {
						oldStepDefault.apply(this, arguments);
					}
				};
				// animate paths
				jQ.fx.step.d = function(fx) {
					var elem = fx.elem;


					// Normally start and end should be set in state == 0, but sometimes,
					// for reasons unknown, this doesn't happen. Perhaps state == 0 is skipped
					// in these cases
					if (!fx.started) {
						var ends = pathAnim.init(elem, elem.d, elem.toD);
						fx.start = ends[0];
						fx.end = ends[1];
						fx.started = true;
					}


					// interpolate each value of the path
					elem.attr('d', pathAnim.step(fx.start, fx.end, fx.pos, elem.toD));

				};
				// get the current value
				jQ.fx.prototype.cur = function() {
					var elem = this.elem,
						r;
					if (elem.attr) { // is SVG element wrapper
						r = elem.attr(this.prop);
					} else {
						r = oldCur.apply(this, arguments);
					}
					return r;
				};
			}


			/**
			 * Add a global listener for mousemove events
			 */
			/*addEvent(doc, 'mousemove', function(e) {
				if (globalMouseMove) {
					globalMouseMove(e);
				}
			});*/

			/**
			 * Path interpolation algorithm used across adapters
			 */
			pathAnim = {
				/**
				 * Prepare start and end values so that the path can be animated one to one
				 */
				init: function(elem, fromD, toD) {
					fromD = fromD || '';
					var shift = elem.shift,
						bezier = fromD.indexOf('C') > -1,
						numParams = bezier ? 7 : 3,
						endLength,
						slice,
						i,
						start = fromD.split(' '),
						end = [].concat(toD), // copy
						startBaseLine,
						endBaseLine,
						sixify = function(arr) { // in splines make move points have six parameters like bezier curves
							i = arr.length;
							while (i--) {
								if (arr[i] == M) {
									arr.splice(i + 1, 0, arr[i+1], arr[i+2], arr[i+1], arr[i+2]);
								}
							}
						};

					if (bezier) {
						sixify(start);
						sixify(end);
					}

					// pull out the base lines before padding
					if (elem.isArea) { 
						startBaseLine = start.splice(start.length - 6, 6);
						endBaseLine = end.splice(end.length - 6, 6);
					}

					// if shifting points, prepend a dummy point to the end path
					if (shift) {

						end = [].concat(end).splice(0, numParams).concat(end);
						elem.shift = false; // reset for following animations
					}

					// copy and append last point until the length matches the end length
					endLength = end.length;
					while (start.length < endLength) {		

						//bezier && sixify(start); 
						slice = [].concat(start).splice(start.length - numParams, numParams);
						if (bezier) { // disable first control point
							slice[numParams - 6] = slice[numParams - 2];
							slice[numParams - 5] = slice[numParams - 1];
						}
						start = start.concat(slice);
					}

					if (startBaseLine) { // append the base lines for areas
						start = start.concat(startBaseLine);
						end = end.concat(endBaseLine);
					}
					return [start, end];
				},

				/**
				 * Interpolate each value of the path and return the array
				 */
				step: function(start, end, pos, complete) {
					var ret = [],
						i = start.length,
						startVal;

					if (pos == 1) { // land on the final path without adjustment points appended in the ends
						ret = complete;

					} else if (i == end.length && pos < 1) {
						while (i--) {
							startVal = parseFloat(start[i]);
							ret[i] = 
								isNaN(startVal) ? // a letter instruction like M or L
									start[i] :
									pos * (parseFloat(end[i] - startVal)) + startVal;

						}
					} else { // if animation is finished or length not matching, land on right value
						ret = end;
					}
					return ret;
				}
			};

			/**
			 * Set the time methods globally based on the useUTC option. Time method can be either 
			 * local time or UTC (default).
			 */
			function setTimeMethods() {
				var useUTC = defaultOptions.global.useUTC;

				makeTime = useUTC ? Date.UTC : function(year, month, date, hours, minutes, seconds) {
					return new Date(
						year, 
						month, 
						pick(date, 1), 
						pick(hours, 0), 
						pick(minutes, 0), 
						pick(seconds, 0)
					).getTime();
				};
				getMinutes = useUTC ? 'getUTCMinutes' : 'getMinutes';
				getHours = useUTC ? 'getUTCHours' : 'getHours';
				getDay = useUTC ? 'getUTCDay' : 'getDay';
				getDate = useUTC ? 'getUTCDate' : 'getDate';
				getMonth = useUTC ? 'getUTCMonth' : 'getMonth';
				getFullYear = useUTC ? 'getUTCFullYear' : 'getFullYear';
				setMinutes = useUTC ? 'setUTCMinutes' : 'setMinutes';
				setHours = useUTC ? 'setUTCHours' : 'setHours';
				setDate = useUTC ? 'setUTCDate' : 'setDate';
				setMonth = useUTC ? 'setUTCMonth' : 'setMonth';
				setFullYear = useUTC ? 'setUTCFullYear' : 'setFullYear';

			}

			/**
			 * Merge the default options with custom options and return the new options structure
			 * @param {Object} options The new custom options
			 */
			function setOptions(options) {
				defaultOptions = merge(defaultOptions, options);

				// apply UTC
				setTimeMethods();

				return defaultOptions;
			}

			/**
			 * Get the updated default options. Merely exposing defaultOptions for outside modules
			 * isn't enough because the setOptions method creates a new object.
			 */
			function getOptions() {
				return defaultOptions;
			}

			/**
			 * Discard an element by moving it to the bin and delete
			 * @param {Object} The HTML node to discard
			 */
			function discardElement(element) {
				// create a garbage bin element, not part of the DOM
				if (!garbageBin) {
					garbageBin = createElement(DIV);
				}

				// move the node and empty bin
				if (element) {
					garbageBin.appendChild(element);
				}
				garbageBin.innerHTML = '';
			}

			/* ****************************************************************************
			 * Handle the options                                                         *
			 *****************************************************************************/
			var 

			defaultLabelOptions = {
				enabled: true,
				// rotation: 0,
				align: 'center',
				x: 0,
				y: 15,
				/*formatter: function() {
					return this.value;
				},*/
				style: {
					color: '#666',
					fontSize: '11px'
				}
			};

			defaultOptions = {
				colors: ['#4572A7', '#AA4643', '#89A54E', '#80699B', '#3D96AE', 
					'#DB843D', '#92A8CD', '#A47D7C', '#B5CA92'],
				symbols: ['circle', 'diamond', 'square', 'triangle', 'triangle-down'],
				lang: {
					loading: 'Loading...',
					months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 
							'August', 'September', 'October', 'November', 'December'],
					weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
					decimalPoint: '.',
					resetZoom: 'Reset zoom',
					resetZoomTitle: 'Reset zoom level 1:1',
					thousandsSep: ','
				},
				global: {
					useUTC: true
				},
				chart: {
					//animation: true,
					//alignTicks: false,
					//reflow: true,
					//className: null,
					//events: { load, selection },
					//margin: [null],
					//marginTop: null,
					//marginRight: null,
					//marginBottom: null,
					//marginLeft: null,
					borderColor: '#4572A7',
					//borderWidth: 0,
					borderRadius: 5,		
					defaultSeriesType: 'line',
					ignoreHiddenSeries: true,
					//inverted: false,
					//shadow: false,
					spacingTop: 10,
					spacingRight: 10,
					spacingBottom: 15,
					spacingLeft: 10,
					style: {
						fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Verdana, Arial, Helvetica, sans-serif', // default font
						fontSize: '12px'
					},
					backgroundColor: '#FFFFFF',
					//plotBackgroundColor: null,
					plotBorderColor: '#C0C0C0'
					//plotBorderWidth: 0,
					//plotShadow: false,
					//zoomType: ''
				},
				title: {
					text: 'Chart title',
					align: 'center',
					// floating: false,
					// margin: 15,
					// x: 0,
					// verticalAlign: 'top',
					y: 15, // docs
					style: {
						color: '#3E576F',
						fontSize: '16px'
					}

				},
				subtitle: {
					text: '',
					align: 'center',
					// floating: false
					// x: 0,
					// verticalAlign: 'top',
					y: 30, // docs
					style: {
						color: '#6D869F'
					}
				},

				plotOptions: {
					line: { // base series options
						allowPointSelect: false,
						showCheckbox: false,
						animation: {
							duration: 1000
						},
						//cursor: 'default',
						//dashStyle: null,
						//enableMouseTracking: true,
						events: {},
						lineWidth: 2,
						shadow: true,
						// stacking: null,
						marker: { 
							enabled: true,
							//symbol: null, 
							lineWidth: 0,
							radius: 4,
							lineColor: '#FFFFFF',
							//fillColor: null, 
							states: { // states for a single point
								hover: {
									//radius: base + 2
								},
								select: {
									fillColor: '#FFFFFF',
									lineColor: '#000000',
									lineWidth: 2
								}					
							}
						},
						point: {
							events: {}
						},
						dataLabels: merge(defaultLabelOptions, {
							enabled: false,
							y: -6,
							formatter: function() {
								return this.y;
							}
						}),

						//pointStart: 0,
						//pointInterval: 1,
						showInLegend: true,
						states: { // states for the entire series
							hover: {
								//enabled: false,
								//lineWidth: base + 1,
								marker: {
									// lineWidth: base + 1,
									// radius: base + 1
								}
							},
							select: {
								marker: {}
							}
						},
						stickyTracking: true
						//zIndex: null
					}
				},
				labels: {
					//items: [],
					style: {
						//font: defaultFont,
						position: ABSOLUTE,
						color: '#3E576F'
					}
				},
				legend: {
					enabled: true,
					align: 'center',
					//floating: false,
					layout: 'horizontal',
					labelFormatter: function() {
						return this.name;
					},
					// lineHeight: 16, // docs: deprecated
					borderWidth: 1,
					borderColor: '#909090',
					borderRadius: 5,
					// margin: 10,
					// reversed: false,
					shadow: false,
					// backgroundColor: null,
					style: {
						padding: '5px'
					},
					itemStyle: {
						cursor: 'pointer',
						color: '#3E576F'
					},
					itemHoverStyle: {
						cursor: 'pointer',
						color: '#000000'
					},
					itemHiddenStyle: {
						color: '#C0C0C0'
					},
					itemCheckboxStyle: {
						position: ABSOLUTE,
						width: '13px', // for IE precision
						height: '13px'
					},
					// itemWidth: undefined,
					symbolWidth: 16,
					symbolPadding: 5,
					verticalAlign: 'bottom',
					// width: undefined,
					x: 0, // docs
					y: 0 // docs
				},

				loading: {
					hideDuration: 100,
					labelStyle: {
						fontWeight: 'bold',
						position: RELATIVE,
						top: '1em'
					},
					showDuration: 100,
					style: {
						position: ABSOLUTE,
						backgroundColor: 'white',
						opacity: 0.5,
						textAlign: 'center'
					}
				},

				tooltip: {
					enabled: true,
					//crosshairs: null,
					backgroundColor: 'rgba(255, 255, 255, .85)',
					borderWidth: 2,
					borderRadius: 5,
					//formatter: defaultFormatter,
					shadow: true,
					//shared: false,
					snap: 10,
					style: {
						color: '#333333',
						fontSize: '12px',
						padding: '5px',
						whiteSpace: 'nowrap'
					}
				},

				toolbar: {
					itemStyle: {
						color: '#4572A7',
						cursor: 'pointer'
					}
				},

				credits: {
					enabled: true,
					text: 'Highcharts.com',
					href: 'http://www.highcharts.com',
					position: {
						align: 'right',
						x: -10,
						verticalAlign: 'bottom',
						y: -5
					},
					style: {
						cursor: 'pointer',
						color: '#909090',
						fontSize: '10px'
					}
				}
			};

			// Axis defaults
			var defaultXAxisOptions =  {
				// allowDecimals: null,
				// alternateGridColor: null,
				// categories: [],
				dateTimeLabelFormats: {
					second: '%H:%M:%S',
					minute: '%H:%M',
					hour: '%H:%M',
					day: '%e. %b',
					week: '%e. %b',
					month: '%b \'%y',
					year: '%Y'
				},
				endOnTick: false,
				gridLineColor: '#C0C0C0',
				// gridLineDashStyle: 'solid', // docs
				// gridLineWidth: 0,
				// reversed: false,

				labels: defaultLabelOptions,
					// { step: null },
				lineColor: '#C0D0E0',
				lineWidth: 1,
				//linkedTo: null,
				max: null,
				min: null,
				minPadding: 0.01,
				maxPadding: 0.01,
				//maxZoom: null,
				minorGridLineColor: '#E0E0E0',
				// minorGridLineDashStyle: null,
				minorGridLineWidth: 1,
				minorTickColor: '#A0A0A0',
				//minorTickInterval: null,
				minorTickLength: 2,
				minorTickPosition: 'outside', // inside or outside
				//minorTickWidth: 0,
				//opposite: false,
				//offset: 0,
				//plotBands: [{
				//	events: {},
				//	zIndex: 1,
				//	labels: { align, x, verticalAlign, y, style, rotation, textAlign }
				//}],
				//plotLines: [{
				//	events: {}
				//  dashStyle: {}
				//	zIndex:
				//	labels: { align, x, verticalAlign, y, style, rotation, textAlign }
				//}],
				//reversed: false,
				// showFirstLabel: true,
				// showLastLabel: false,
				startOfWeek: 1, 
				startOnTick: false,
				tickColor: '#C0D0E0',
				//tickInterval: null,
				tickLength: 5,
				tickmarkPlacement: 'between', // on or between
				tickPixelInterval: 100,
				tickPosition: 'outside',
				tickWidth: 1,
				title: {
					//text: null,
					align: 'middle', // low, middle or high
					//margin: 0 for horizontal, 10 for vertical axes,
					//rotation: 0,
					//side: 'outside',
					style: {
						color: '#6D869F',
						//font: defaultFont.replace('normal', 'bold')
						fontWeight: 'bold'
					}
					//x: 0,
					//y: 0
				},
				type: 'linear' // linear or datetime
			},

			defaultYAxisOptions = merge(defaultXAxisOptions, {
				endOnTick: true,
				gridLineWidth: 1,
				tickPixelInterval: 72,
				showLastLabel: true,
				labels: {
					align: 'right',
					x: -8,
					y: 3
				},
				lineWidth: 0,
				maxPadding: 0.05,
				minPadding: 0.05,
				startOnTick: true,
				tickWidth: 0,
				title: {
					rotation: 270,
					text: 'Y-values'
				}
			}),

			defaultLeftAxisOptions = {
				labels: {
					align: 'right',
					x: -8,
					y: 3
				},
				title: {
					rotation: 270
				}
			},
			defaultRightAxisOptions = {
				labels: {
					align: 'left',
					x: 8,
					y: 3
				},
				title: {
					rotation: 90
				}
			},
			defaultBottomAxisOptions = { // horizontal axis
				labels: {
					align: 'center',
					x: 0,
					y: 14
					// staggerLines: null
				},
				title: {
					rotation: 0
				}
			},
			defaultTopAxisOptions = merge(defaultBottomAxisOptions, {
				labels: {
					y: -5
					// staggerLines: null
				}
			});




			// Series defaults
			var defaultPlotOptions = defaultOptions.plotOptions, 
				defaultSeriesOptions = defaultPlotOptions.line; 
			//defaultPlotOptions.line = merge(defaultSeriesOptions);
			defaultPlotOptions.spline = merge(defaultSeriesOptions);
			defaultPlotOptions.scatter = merge(defaultSeriesOptions, {
				lineWidth: 0,
				states: {
					hover: {
						lineWidth: 0
					}
				}
			});
			defaultPlotOptions.area = merge(defaultSeriesOptions, {
				// threshold: 0,
				// lineColor: null, // overrides color, but lets fillColor be unaltered
				// fillOpacity: 0.75,
				// fillColor: null

			});
			defaultPlotOptions.areaspline = merge(defaultPlotOptions.area);
			defaultPlotOptions.column = merge(defaultSeriesOptions, {
				borderColor: '#FFFFFF',
				borderWidth: 1,
				borderRadius: 0,
				//colorByPoint: undefined,
				groupPadding: 0.2,
				marker: null, // point options are specified in the base options
				pointPadding: 0.1,
				//pointWidth: null,
				minPointLength: 0, 
				states: {
					hover: {
						brightness: 0.1,
						shadow: false
					},
					select: {
						color: '#C0C0C0',
						borderColor: '#000000',
						shadow: false
					}
				}
			});
			defaultPlotOptions.bar = merge(defaultPlotOptions.column, {
				dataLabels: {
					align: 'left',
					x: 5,
					y: 0
				}
			});
			defaultPlotOptions.pie = merge(defaultSeriesOptions, {
				//dragType: '', // n/a
				borderColor: '#FFFFFF',
				borderWidth: 1,
				center: ['50%', '50%'],
				colorByPoint: true, // always true for pies
				dataLabels: {
					// align: null,
					// connectorWidth: 1,
					// connectorColor: '#606060',
					// connectorPadding: 5,
					distance: 30,
					enabled: true,
					formatter: function() {
						return this.point.name;
					},
					y: 5
				},
				//innerSize: 0,
				legendType: 'point',
				marker: null, // point options are specified in the base options
				size: '75%',
				showInLegend: false,
				slicedOffset: 10,
				states: {
					hover: {
						brightness: 0.1,
						shadow: false
					}
				}

			});

			// set the default time methods
			setTimeMethods();


			/**
			 * Extend a prototyped class by new members
			 * @param {Object} parent
			 * @param {Object} members
			 */
			function extendClass(parent, members) {
				var object = function(){};
				object.prototype = new parent();
				extend(object.prototype, members);
				return object;
			}


			/**
			 * Handle color operations. The object methods are chainable.
			 * @param {String} input The input color in either rbga or hex format
			 */
			var Color = function(input) {
				// declare variables
				var rgba = [], result;

				/**
				 * Parse the input color to rgba array
				 * @param {String} input
				 */
				function init(input) {

					// rgba
					if((result = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/.exec(input))) {
						rgba = [pInt(result[1]), pInt(result[2]), pInt(result[3]), parseFloat(result[4], 10)];
					}

					// hex
					else if((result = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(input))) {
						rgba = [pInt(result[1],16), pInt(result[2],16), pInt(result[3],16), 1];
					}

				}
				/**
				 * Return the color a specified format
				 * @param {String} format
				 */
				function get(format) {
					var ret;

					// it's NaN if gradient colors on a column chart
					if (rgba && !isNaN(rgba[0])) {
						if (format == 'rgb') {
							ret = 'rgb('+ rgba[0] +','+ rgba[1] +','+ rgba[2] +')';
						} else if (format == 'a') {
							ret = rgba[3];
						} else {
							ret = 'rgba('+ rgba.join(',') +')';
						}
					} else {
						ret = input;
					}
					return ret;
				}

				/**
				 * Brighten the color
				 * @param {Number} alpha
				 */
				function brighten(alpha) {
					if (isNumber(alpha) && alpha !== 0) {
						var i;
						for (i = 0; i < 3; i++) {
							rgba[i] += pInt(alpha * 255);

							if (rgba[i] < 0) {
								rgba[i] = 0;
							}
							if (rgba[i] > 255) {
								rgba[i] = 255;
							}
						}
					}
					return this;
				}
				/**
				 * Set the color's opacity to a given alpha value
				 * @param {Number} alpha
				 */
				function setOpacity(alpha) {
					rgba[3] = alpha;
					return this;
				}	

				// initialize: parse the input
				init(input);

				// public methods
				return {
					get: get,
					brighten: brighten,
					setOpacity: setOpacity
				};
			};



			/**
			 * Format a number and return a string based on input settings
			 * @param {Number} number The input number to format
			 * @param {Number} decimals The amount of decimals
			 * @param {String} decPoint The decimal point, defaults to the one given in the lang options
			 * @param {String} thousandsSep The thousands separator, defaults to the one given in the lang options
			 */
			function numberFormat (number, decimals, decPoint, thousandsSep) {
				var lang = defaultOptions.lang,
					// http://kevin.vanzonneveld.net/techblog/article/javascript_equivalent_for_phps_number_format/
					n = number, c = isNaN(decimals = mathAbs(decimals)) ? 2 : decimals,
					d = decPoint === undefined ? lang.decimalPoint : decPoint,
					t = thousandsSep === undefined ? lang.thousandsSep : thousandsSep, s = n < 0 ? "-" : "",
					i = pInt(n = mathAbs(+n || 0).toFixed(c)) + "", j = (j = i.length) > 3 ? j % 3 : 0;

				return s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) +
					(c ? d + mathAbs(n - i).toFixed(c).slice(2) : "");
			}

			/**
			 * Based on http://www.php.net/manual/en/function.strftime.php 
			 * @param {String} format
			 * @param {Number} timestamp
			 * @param {Boolean} capitalize
			 */
			dateFormat = function (format, timestamp, capitalize) {
				function pad (number) {
					return number.toString().replace(/^([0-9])$/, '0$1');
				}

				if (!defined(timestamp) || isNaN(timestamp)) {
					return 'Invalid date';
				}
				format = pick(format, '%Y-%m-%d %H:%M:%S');

				var date = new Date(timestamp * timeFactor),

					// get the basic time values
					hours = date[getHours](),
					day = date[getDay](),
					dayOfMonth = date[getDate](),
					month = date[getMonth](),
					fullYear = date[getFullYear](),
					lang = defaultOptions.lang,
					langWeekdays = lang.weekdays,
					langMonths = lang.months,

					// list all format keys
					replacements = {

						// Day
						'a': langWeekdays[day].substr(0, 3), // Short weekday, like 'Mon'
						'A': langWeekdays[day], // Long weekday, like 'Monday'
						'd': pad(dayOfMonth), // Two digit day of the month, 01 to 31 
						'e': dayOfMonth, // Day of the month, 1 through 31 

						// Week (none implemented)

						// Month
						'b': langMonths[month].substr(0, 3), // Short month, like 'Jan'
						'B': langMonths[month], // Long month, like 'January'
						'm': pad(month + 1), // Two digit month number, 01 through 12

						// Year
						'y': fullYear.toString().substr(2, 2), // Two digits year, like 09 for 2009
						'Y': fullYear, // Four digits year, like 2009

						// Time
						'H': pad(hours), // Two digits hours in 24h format, 00 through 23
						'I': pad((hours % 12) || 12), // Two digits hours in 12h format, 00 through 11
						'l': (hours % 12) || 12, // Hours in 12h format, 1 through 12
						'M': pad(date[getMinutes]()), // Two digits minutes, 00 through 59
						'p': hours < 12 ? 'AM' : 'PM', // Upper case AM or PM
						'P': hours < 12 ? 'am' : 'pm', // Lower case AM or PM
						'S': pad(date.getSeconds()) // Two digits seconds, 00 through  59

					};


				// do the replaces
				for (var key in replacements) {
					format = format.replace('%'+ key, replacements[key]);
				}

				// Optionally capitalize the string and return
				return capitalize ? format.substr(0, 1).toUpperCase() + format.substr(1) : format;
			};



			/**
			 * Loop up the node tree and add offsetWidth and offsetHeight to get the
			 * total page offset for a given element. Used by Opera and iOS on hover and
			 * all browsers on point click.
			 * 
			 * @param {Object} el
			 * 
			 */
			function getPosition (el) {
				var p = { left: el.offsetLeft, top: el.offsetTop };
				while ((el = el.offsetParent))	{
					p.left += el.offsetLeft;
					p.top += el.offsetTop;
					if (el != doc.body && el != doc.documentElement) {
						p.left -= el.scrollLeft;
						p.top -= el.scrollTop;
					}
				}
				return p;
			}


			/**
			 * A wrapper object for SVG elements 
			 */
			function SVGElement () {}

			SVGElement.prototype = {
				/**
				 * Initialize the SVG renderer
				 * @param {Object} renderer
				 * @param {String} nodeName
				 */
				init: function(renderer, nodeName) {
					this.element = doc.createElementNS('http://www.w3.org/2000/svg', nodeName);
					this.renderer = renderer;
				},
				/**
				 * Animate a given attribute
				 * @param {Object} params
				 * @param {Number} options The same options as in jQuery animation
				 * @param {Function} complete Function to perform at the end of animation
				 */
				animate: function(params, options, complete) {
					var animOptions = pick(options, globalAnimation, true);
					if (animOptions) {
						animOptions = merge(animOptions);
						if (complete) { // allows using a callback with the global animation without overwriting it
							animOptions.complete = complete;
						}
						animate(this, params, animOptions);
					} else {
						this.attr(params);
						if (complete) {
							complete();
						}
					}
				},
				/**
				 * Set or get a given attribute
				 * @param {Object|String} hash
				 * @param {Mixed|Undefined} val
				 */
				attr: function(hash, val) {
					var key, 
						value, 
						i, 
						child,
						element = this.element,
						nodeName = element.nodeName,
						renderer = this.renderer,
						skipAttr,
						shadows = this.shadows,
						hasSetSymbolSize,
						ret = this;

					// single key-value pair
					if (isString(hash) && defined(val)) {
						key = hash;
						hash = {};
						hash[key] = val;
					}

					// used as a getter: first argument is a string, second is undefined
					if (isString(hash)) {
						key = hash;
						if (nodeName == 'circle') {
							key = { x: 'cx', y: 'cy' }[key] || key;
						} else if (key == 'strokeWidth') {
							key = 'stroke-width';
						}
						ret = attr(element, key) || this[key] || 0;

						if (key != 'd' && key != 'visibility') { // 'd' is string in animation step
							ret = parseFloat(ret);
						}

					// setter
					} else {

						for (key in hash) {
							skipAttr = false; // reset
							value = hash[key];

							// paths
							if (key == 'd') {
								if (value && value.join) { // join path
									value = value.join(' ');
								}					
								if (/(NaN| {2}|^$)/.test(value)) {
									value = 'M 0 0';
								}
								this.d = value; // shortcut for animations

							// update child tspans x values
							} else if (key == 'x' && nodeName == 'text') { 
								for (i = 0; i < element.childNodes.length; i++ ) {
									child = element.childNodes[i];
									// if the x values are equal, the tspan represents a linebreak
									if (attr(child, 'x') == attr(element, 'x')) {
										//child.setAttribute('x', value);
										attr(child, 'x', value);
									}
								}

								if (this.rotation) {
									attr(element, 'transform', 'rotate('+ this.rotation +' '+ value +' '+
										pInt(hash.y || attr(element, 'y')) +')');
								}

							// apply gradients
							} else if (key == 'fill') {
								value = renderer.color(value, element, key);

							// circle x and y
							} else if (nodeName == 'circle' && (key == 'x' || key == 'y')) {
								key = { x: 'cx', y: 'cy' }[key] || key;

							// translation and text rotation
							} else if (key == 'translateX' || key == 'translateY' || key == 'rotation') {
								this[key] = value;
								this.updateTransform();
								skipAttr = true;

							// apply opacity as subnode (required by legacy WebKit and Batik)
							} else if (key == 'stroke') {
								value = renderer.color(value, element, key);

							// emulate VML's dashstyle implementation
							} else if (key == 'dashstyle') {
								key = 'stroke-dasharray';
								if (value) {
									value = value.toLowerCase()
										.replace('shortdashdotdot', '3,1,1,1,1,1,')
										.replace('shortdashdot', '3,1,1,1')
										.replace('shortdot', '1,1,')
										.replace('shortdash', '3,1,')
										.replace('longdash', '8,3,')
										.replace(/dot/g, '1,3,')
										.replace('dash', '4,3,')
										.replace(/,$/, '')
										.split(','); // ending comma

									i = value.length;
									while (i--) {
										value[i] = pInt(value[i]) * hash['stroke-width'];
									}
									value = value.join(',');
								}	

							// special
							} else if (key == 'isTracker') {
								this[key] = value;

							// IE9/MooTools combo: MooTools returns objects instead of numbers and IE9 Beta 2
							// is unable to cast them. Test again with final IE9.
							} else if (key == 'width') {
								value = pInt(value);

							// Text alignment
							} else if (key == 'align') {
								key = 'text-anchor';
								value = { left: 'start', center: 'middle', right: 'end' }[value];
							}



							// jQuery animate changes case
							if (key == 'strokeWidth') {
								key = 'stroke-width';
							}

							// Chrome/Win < 6 bug (http://code.google.com/p/chromium/issues/detail?id=15461)				
							if (isWebKit && key == 'stroke-width' && value === 0) {
								value = 0.000001;
							}

							// symbols
							if (this.symbolName && /^(x|y|r|start|end|innerR)/.test(key)) {


								if (!hasSetSymbolSize) {
									this.symbolAttr(hash);
									hasSetSymbolSize = true;
								}
								skipAttr = true;
							}

							// let the shadow follow the main element
							if (shadows && /^(width|height|visibility|x|y|d)$/.test(key)) {
								i = shadows.length;
								while (i--) {
									attr(shadows[i], key, value);
								}					
							}



							if (key == 'text') {
								// only one node allowed
								renderer.buildText(element, value);
							} else if (!skipAttr) {
								//element.setAttribute(key, value);
								attr(element, key, value);
							}
						}

					}
					return ret;
				},

				/**
				 * If one of the symbol size affecting parameters are changed,
				 * check all the others only once for each call to an element's
				 * .attr() method
				 * @param {Object} hash
				 */
				symbolAttr: function(hash) {
					var wrapper = this;

					wrapper.x = pick(hash.x, wrapper.x);
					wrapper.y = parseFloat(pick(hash.y, wrapper.y)); // mootools animation bug needs parseFloat
					wrapper.r = pick(hash.r, wrapper.r);
					wrapper.start = pick(hash.start, wrapper.start);
					wrapper.end = pick(hash.end, wrapper.end);
					wrapper.width = pick(hash.width, wrapper.width);
					wrapper.height = parseFloat(pick(hash.height, wrapper.height));
					wrapper.innerR = pick(hash.innerR, wrapper.innerR);

					wrapper.attr({ 
						d: wrapper.renderer.symbols[wrapper.symbolName](wrapper.x, wrapper.y, wrapper.r, {
							start: wrapper.start, 
							end: wrapper.end,
							width: wrapper.width, 
							height: wrapper.height,
							innerR: wrapper.innerR
						})
					});
				},

				/**
				 * Apply a clipping path to this object
				 * @param {String} id
				 */
				clip: function(clipRect) {
					return this.attr('clip-path', 'url('+ this.renderer.url +'#'+ clipRect.id +')');
				},

				/**
				 * Set styles for the element
				 * @param {Object} styles
				 */
				css: function(styles) {
					var elemWrapper = this;

					// convert legacy
					if (styles && styles.color) {
						styles.fill = styles.color;
					}

					// save the styles in an object
					styles = extend(
						elemWrapper.styles,
						styles
					);

					// serialize and set style attribute
					elemWrapper.attr({
						style: serializeCSS(styles)
					});

					// store object
					elemWrapper.styles = styles;

					return elemWrapper;
				},

				/**
				 * Add an event listener
				 * @param {String} eventType
				 * @param {Function} handler
				 */
				on: function(eventType, handler) {
					// simplest possible event model for internal use
					this.element['on'+ eventType] = handler;
					return this;
				},


				/**
				 * Move an object and its children by x and y values
				 * @param {Number} x
				 * @param {Number} y
				 */
				translate: function(x, y) {
					return this.attr({
						translateX: x,
						translateY: y
					});
				},

				/**
				 * Invert a group, rotate and flip
				 */
				invert: function() {
					var wrapper = this;
					wrapper.inverted = true;
					wrapper.updateTransform();
					return wrapper;
				},

				/**
				 * Private method to update the transform attribute based on internal 
				 * properties
				 */
				updateTransform: function() {
					var wrapper = this,
						translateX = wrapper.translateX || 0,
						translateY = wrapper.translateY || 0,
						inverted = wrapper.inverted,
						rotation = wrapper.rotation,
						transform = [];

					// flipping affects translate as adjustment for flipping around the group's axis
					if (inverted) {
						translateX += wrapper.attr('width');
						translateY += wrapper.attr('height');
					}

					// apply translate
					if (translateX || translateY) {
						transform.push('translate('+ translateX +','+ translateY +')');
					}

					// apply rotation
					if (inverted) {
						transform.push('rotate(90) scale(-1,1)');
					} else if (rotation) { // text rotation
						transform.push('rotate('+ rotation +' '+ wrapper.x +' '+ wrapper.y +')');
					}

					if (transform.length) {
						attr(wrapper.element, 'transform', transform.join(' '));
					}
				},
				/**
				 * Bring the element to the front
				 */
				toFront: function() {
					var element = this.element;
					element.parentNode.appendChild(element);
					return this;
				},


				/**
				 * Break down alignment options like align, verticalAlign, x and y 
				 * to x and y relative to the chart.
				 * 
				 * @param {Object} alignOptions
				 * @param {Boolean} alignByTranslate
				 * @param {Object} box The box to align to, needs a width and height
				 * 
				 */
				align: function(alignOptions, alignByTranslate, box) {

					if (!alignOptions) { // called on resize
						alignOptions = this.alignOptions;
						alignByTranslate = this.alignByTranslate;
					} else { // first call on instanciate
						this.alignOptions = alignOptions;
						this.alignByTranslate = alignByTranslate;
						if (!box) { // boxes other than renderer handle this internally
							this.renderer.alignedObjects.push(this);
						}
					}

					box = pick(box, this.renderer);

					var align = alignOptions.align,
						vAlign = alignOptions.verticalAlign,
						x = (box.x || 0) + (alignOptions.x || 0), // default: left align
						y = (box.y || 0) + (alignOptions.y || 0), // default: top align
						attribs = {};


					// align
					if (/^(right|center)$/.test(align)) {
						x += (box.width - (alignOptions.width || 0) ) /
								{ right: 1, center: 2 }[align];
					}
					attribs[alignByTranslate ? 'translateX' : 'x'] = x;


					// vertical align
					if (/^(bottom|middle)$/.test(vAlign)) {
						y += (box.height - (alignOptions.height || 0)) /
								({ bottom: 1, middle: 2 }[vAlign] || 1);

					}
					attribs[alignByTranslate ? 'translateY' : 'y'] = y;

					// animate only if already placed
					this[this.placed ? 'animate' : 'attr'](attribs);
					this.placed = true;

					return this;
				},

				/**
				 * Get the bounding box (width, height, x and y) for the element
				 */
				getBBox: function() {		
					var	bBox,
						width,
						height,
						rotation = this.rotation,
						rad = rotation * deg2rad;

					try { // fails in Firefox if the container has display: none
						// use extend because IE9 is not allowed to change width and height in case 
						// of rotation (below)
						bBox = extend({}, this.element.getBBox());
					} catch(e) {
						bBox = { width: 0, height: 0 };
					}
					width = bBox.width;
					height = bBox.height;

					// adjust for rotated text
					if (rotation) {
						bBox.width = mathAbs(height * mathSin(rad)) + mathAbs(width * mathCos(rad));
						bBox.height = mathAbs(height * mathCos(rad)) + mathAbs(width * mathSin(rad));
					}

					return bBox;
				},

				/* *
				 * Manually compute width and height of rotated text from non-rotated. Shared by SVG and VML
				 * @param {Object} bBox
				 * @param {number} rotation
				 * /
				rotateBBox: function(bBox, rotation) {
					var rad = rotation * math.PI * 2 / 360, // radians
						width = bBox.width,
						height = bBox.height;


				},*/

				/**
				 * Show the element
				 */
				show: function() {
					return this.attr({ visibility: VISIBLE });
				},

				/**
				 * Hide the element
				 */
				hide: function() {
					return this.attr({ visibility: HIDDEN });
				},

				/**
				 * Add the element
				 * @param {Object|Undefined} parent Can be an element, an element wrapper or undefined
				 *    to append the element to the renderer.box.
				 */ 
				add: function(parent) {

					var renderer = this.renderer,
						parentWrapper = parent || renderer,
						parentNode = parentWrapper.element || renderer.box,
						childNodes = parentNode.childNodes,
						element = this.element,
						zIndex = attr(element, 'zIndex'),
						otherElement,
						otherZIndex,
						i;

					// mark as inverted
					this.parentInverted = parent && parent.inverted;

					// mark the container as having z indexed children
					if (zIndex) {
						parentWrapper.handleZ = true;
						zIndex = pInt(zIndex);
					}

					// insert according to this and other elements' zIndex
					if (parentWrapper.handleZ) { // this element or any of its siblings has a z index
						for (i = 0; i < childNodes.length; i++) {
							otherElement = childNodes[i];
							otherZIndex = attr(otherElement, 'zIndex');
							if (otherElement != element && (
									// insert before the first element with a higher zIndex
									pInt(otherZIndex) > zIndex || 
									// if no zIndex given, insert before the first element with a zIndex
									(!defined(zIndex) && defined(otherZIndex))  

									)) {
								parentNode.insertBefore(element, otherElement);
								return this;
							}
						}
					}

					// default: append at the end
					parentNode.appendChild(element);
					return this;
				},


				/**
				 * Destroy the element and element wrapper
				 */
				destroy: function() {
					var wrapper = this,
						element = wrapper.element || {},
						shadows = wrapper.shadows,
						parentNode = element.parentNode,
						key;

					// remove events
					element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = null;
					stop(wrapper); // stop running animations

					// remove element
					if (parentNode) {
						parentNode.removeChild(element);
					}

					// destroy shadows
					if (shadows) {
						each(shadows, function(shadow) {
							parentNode = shadow.parentNode;
							if (parentNode) { // the entire chart HTML can be overwritten
								parentNode.removeChild(shadow);
							}				
						});
					}

					// remove from alignObjects
					erase(wrapper.renderer.alignedObjects, wrapper);

					for (key in wrapper) {
						delete wrapper[key];
					}

					return null;
				},

				/**
				 * Empty a group element
				 */
				empty: function() {
					var element = this.element,
						childNodes = element.childNodes,
						i = childNodes.length;

					while (i--) {
						element.removeChild(childNodes[i]);
					}
				},

				/**
				 * Add a shadow to the element. Must be done after the element is added to the DOM
				 * @param {Boolean} apply
				 */
				shadow: function(apply) {
					var shadows = [],
						i,
						shadow,
						element = this.element,

						// compensate for inverted plot area
						transform = this.parentInverted ? '(-1,-1)' : '(1,1)';


					if (apply) {
						for (i = 1; i <= 3; i++) {
							shadow = element.cloneNode(0);
							attr(shadow, {
								'isShadow': 'true',
								'stroke': 'rgb(0, 0, 0)',
								'stroke-opacity': 0.05 * i,
								'stroke-width': 7 - 2 * i,
								'transform': 'translate'+ transform,
								'fill': NONE
							});


							element.parentNode.insertBefore(shadow, element);

							shadows.push(shadow);
						}

						this.shadows = shadows;
					}
					return this;

				}
			};



			/**
			 * The default SVG renderer
			 */
			var SVGRenderer = function() {
				this.init.apply(this, arguments);
			};
			SVGRenderer.prototype = {
				/**
				 * Initialize the SVGRenderer
				 * @param {Object} container
				 * @param {Number} width
				 * @param {Number} height
				 */
				init: function(container, width, height) {
					var renderer = this,
						loc = location,
						boxWrapper;

					renderer.Element = SVGElement;
					boxWrapper = renderer.createElement('svg')
						.attr({
							xmlns: 'http://www.w3.org/2000/svg',
							version: '1.1'
						});
					container.appendChild(boxWrapper.element);

					// object properties
					renderer.box = boxWrapper.element;
					renderer.boxWrapper = boxWrapper;
					renderer.alignedObjects = [];
					renderer.url = isIE ? '' : loc.href.replace(/#.*?$/, ''); // page url used for internal references
					renderer.defs = this.createElement('defs').add();

					renderer.setSize(width, height, false);

				},


				/**
				 * Create a wrapper for an SVG element
				 * @param {Object} nodeName
				 */
				createElement: function(nodeName) {
					var wrapper = new this.Element();
					wrapper.init(this, nodeName);
					return wrapper;
				},


				/** 
				 * Parse a simple HTML string into SVG tspans
				 * 
				 * @param {Object} textNode The parent text SVG node
				 * @param {String} str
				 */
				buildText: function(textNode, str) {
					var lines = str.toString()
							.replace(/<(b|strong)>/g, '<span style="font-weight:bold">')
							.replace(/<(i|em)>/g, '<span style="font-style:italic">')
							.replace(/<a/g, '<span')
							.replace(/<\/(b|strong|i|em|a)>/g, '</span>')
							.split(/<br[^>]?>/g),
						childNodes = textNode.childNodes,
						styleRegex = /style="([^"]+)"/,
						hrefRegex = /href="([^"]+)"/,
						parentX = attr(textNode, 'x'),
						lastLine,
						i = childNodes.length;


					// remove old text
					while (i--) {
						textNode.removeChild(childNodes[i]);
					}


					each(lines, function(line, lineNo) {
						var spans, spanNo = 0;

						line = line.replace(/<span/g, '|||<span').replace(/<\/span>/g, '</span>|||');
						spans = line.split('|||');

						each(spans, function (span) {
							if (span !== '' || spans.length == 1) {
								var attributes = {},
									tspan = doc.createElementNS('http://www.w3.org/2000/svg', 'tspan');
								if (styleRegex.test(span)) {
									attr(
										tspan, 
										'style', 
										span.match(styleRegex)[1].replace(/(;| |^)color([ :])/, '$1fill$2')
									);
								}
								if (hrefRegex.test(span)) {
									attr(tspan, 'onclick', 'location.href=\"'+ span.match(hrefRegex)[1] +'\"');
									css(tspan, { cursor: 'pointer' });
								}

								span = span.replace(/<(.|\n)*?>/g, '');
								tspan.appendChild(doc.createTextNode(span || ' ')); // WebKit needs a string
								//console.log('"'+tspan.textContent+'"');
								if (!spanNo) { // first span in a line, align it to the left
									attributes.x = parentX;
								} else {
									// Firefox ignores spaces at the front or end of the tspan
									attributes.dx = 3; // space
								}


								// first span on subsequent line, add the line height
								if (!spanNo) {						
									if (lineNo) {
										attr(tspan, 'dy', pInt(lastLine.offsetHeight || 
											window.getComputedStyle(lastLine, null).getPropertyValue('line-height') ||
											18));
									}
									lastLine = tspan; // record for use in next line						
								}

								// add attributes
								attr(tspan, attributes);

								// append it
								textNode.appendChild(tspan);

								spanNo++;
							}
						});

					});
				},

				/**
				 * Make a straight line crisper by not spilling out to neighbour pixels
				 * @param {Array} points
				 * @param {Number} width 
				 */
				crispLine: function(points, width) {
					// points format: [M, 0, 0, L, 100, 0]
					// normalize to a crisp line
					if (points[1] == points[4]) {
						points[1] = points[4] = mathRound(points[1]) + (width % 2 / 2);
					}
					if (points[2] == points[5]) {
						points[2] = points[5] = mathRound(points[2]) + (width % 2 / 2);
					}
					return points;
				},


				/**
				 * Draw a path
				 * @param {Array} path An SVG path in array form
				 */
				path: function (path) {
					return this.createElement('path').attr({ 
						d: path, 
						fill: NONE
					});
				},

				/**
				 * Draw and return an SVG circle
				 * @param {Number} x The x position
				 * @param {Number} y The y position
				 * @param {Number} r The radius
				 */
				circle: function (x, y, r) {
					var attr = isObject(x) ?
						x :
						{
							x: x,
							y: y,
							r: r
						};

					return this.createElement('circle').attr(attr);
				},

				/**
				 * Draw and return an arc
				 * @param {Number} x X position
				 * @param {Number} y Y position
				 * @param {Number} r Radius
				 * @param {Number} innerR Inner radius like used in donut charts
				 * @param {Number} start Starting angle
				 * @param {Number} end Ending angle
				 */
				arc: function (x, y, r, innerR, start, end) {
					// arcs are defined as symbols for the ability to set 
					// attributes in attr and animate

					if (isObject(x)) {
						y = x.y;
						r = x.r;
						innerR = x.innerR;
						start = x.start;
						end = x.end;
						x = x.x;
					}

					return this.symbol('arc', x || 0, y || 0, r || 0, {
						innerR: innerR || 0,
						start: start || 0,
						end: end || 0
					});
				},

				/**
				 * Draw and return a rectangle
				 * @param {Number} x Left position
				 * @param {Number} y Top position
				 * @param {Number} width
				 * @param {Number} height
				 * @param {Number} r Border corner radius
				 * @param {Number} strokeWidth A stroke width can be supplied to allow crisp drawing
				 */
				rect: function (x, y, width, height, r, strokeWidth) {

					if (arguments.length > 1) {
						var normalizer = (strokeWidth || 0) % 2 / 2;

						// normalize for crisp edges
						x = mathRound(x || 0) + normalizer;
						y = mathRound(y || 0) + normalizer;
						width = mathRound((width || 0) - 2 * normalizer);
						height = mathRound((height || 0) - 2 * normalizer);
					}

					var attr = isObject(x) ? 
						x : // the attributes can be passed as the first argument
						{
							x: x,
							y: y,
							width: mathMax(width, 0),
							height: mathMax(height, 0)
						};			

					return this.createElement('rect').attr(extend(attr, {
						rx: r || attr.r,
						ry: r || attr.r,
						fill: NONE
					}));
				},

				/**
				 * Resize the box and re-align all aligned elements
				 * @param {Object} width
				 * @param {Object} height
				 * @param {Boolean} animate
				 * 
				 */
				setSize: function(width, height, animate) {
					var renderer = this,
						alignedObjects = renderer.alignedObjects,
						i = alignedObjects.length;

					renderer.width = width;
					renderer.height = height;

					renderer.boxWrapper[pick(animate, true) ? 'animate' : 'attr']({
						width: width,
						height: height
					});		

					while (i--) {
						alignedObjects[i].align();
					}
				},

				/**
				 * Create a group
				 * @param {String} name The group will be given a class name of 'highcharts-{name}'.
				 *     This can be used for styling and scripting.
				 */
				g: function(name) {
					return this.createElement('g').attr(
						defined(name) && { 'class': PREFIX + name }
					);
				},

				/**
				 * Display an image
				 * @param {String} src
				 * @param {Number} x
				 * @param {Number} y
				 * @param {Number} width
				 * @param {Number} height
				 */
				image: function(src, x, y, width, height) {
					var attribs = {
							preserveAspectRatio: NONE	
						},
						elemWrapper;

					// optional properties
					if (arguments.length > 1) {
						extend(attribs, {
							x: x,
							y: y,
							width: width,
							height: height
						});
					}

					elemWrapper = this.createElement('image').attr(attribs);		

					// set the href in the xlink namespace
					elemWrapper.element.setAttributeNS('http://www.w3.org/1999/xlink', 
						'href', src);

					return elemWrapper;					
				},

				/**
				 * Draw a symbol out of pre-defined shape paths from the namespace 'symbol' object.
				 * 
				 * @param {Object} symbol
				 * @param {Object} x
				 * @param {Object} y
				 * @param {Object} radius
				 * @param {Object} options
				 */
				symbol: function(symbol, x, y, radius, options) {

					var obj,

						// get the symbol definition function
						symbolFn = this.symbols[symbol],

						// check if there's a path defined for this symbol
						path = symbolFn && symbolFn(
							x, 
							y, 
							radius, 
							options
						),

						imageRegex = /^url\((.*?)\)$/,
						imageSrc;

					if (path) {

						obj = this.path(path);
						// expando properties for use in animate and attr
						extend(obj, {
							symbolName: symbol,
							x: x,
							y: y,
							r: radius
						});
						if (options) {
							extend(obj, options);
						}


					// image symbols
					} else if (imageRegex.test(symbol)) {

						imageSrc = symbol.match(imageRegex)[1];

						// create the image synchronously, add attribs async
						obj = this.image(imageSrc)
							.attr({
								x: x,
								y: y
							});

						// create a dummy JavaScript image to get the width and height  
						createElement('img', {
							onload: function() {
								var img = this,
									size = symbolSizes[img.src] || [img.width, img.height];
								obj.attr({						
									width: size[0],
									height: size[1]
								}).translate(
									-mathRound(size[0] / 2),
									-mathRound(size[1] / 2)
								);
							},
							src: imageSrc
						});

					// default circles
					} else {
						obj = this.circle(x, y, radius);
					}

					return obj;
				},

				/**
				 * An extendable collection of functions for defining symbol paths.
				 */
				symbols: {
					'square': function (x, y, radius) {
						var len = 0.707 * radius;
						return [
							M, x-len, y-len,
							L, x+len, y-len,
							x+len, y+len,
							x-len, y+len,
							'Z'
						];
					},

					'triangle': function (x, y, radius) {
						return [
							M, x, y-1.33 * radius,
							L, x+radius, y + 0.67 * radius,
							x-radius, y + 0.67 * radius,
							'Z'
						];
					},

					'triangle-down': function (x, y, radius) {
						return [
							M, x, y + 1.33 * radius,
							L, x-radius, y-0.67 * radius,
							x+radius, y-0.67 * radius,
							'Z'
						];
					},
					'diamond': function (x, y, radius) {
						return [
							M, x, y-radius,
							L, x+radius, y,
							x, y+radius,
							x-radius, y,
							'Z'
						];
					},
					'arc': function (x, y, radius, options) {
						var start = options.start,
							end = options.end - 0.000001, // to prevent cos and sin of start and end from becoming equal on 360 arcs
							innerRadius = options.innerR,
							cosStart = mathCos(start),
							sinStart = mathSin(start),
							cosEnd = mathCos(end),
							sinEnd = mathSin(end),
							longArc = options.end - start < mathPI ? 0 : 1;

						return [
							M,
							x + radius * cosStart,
							y + radius * sinStart,
							'A', // arcTo
							radius, // x radius
							radius, // y radius
							0, // slanting
							longArc, // long or short arc
							1, // clockwise
							x + radius * cosEnd,
							y + radius * sinEnd,
							L,				
							x + innerRadius * cosEnd, 
							y + innerRadius * sinEnd,
							'A', // arcTo
							innerRadius, // x radius
							innerRadius, // y radius
							0, // slanting
							longArc, // long or short arc
							0, // clockwise
							x + innerRadius * cosStart,
							y + innerRadius * sinStart,

							'Z' // close
						];
					}
				},

				/**
				 * Define a clipping rectangle
				 * @param {String} id
				 * @param {Number} x
				 * @param {Number} y
				 * @param {Number} width
				 * @param {Number} height
				 */
				clipRect: function (x, y, width, height) {
					var wrapper,
						id = PREFIX + idCounter++,

						clipPath = this.createElement('clipPath').attr({
							id: id
						}).add(this.defs);

					wrapper = this.rect(x, y, width, height, 0).add(clipPath);
					wrapper.id = id;

					return wrapper;
				},


				/**
				 * Take a color and return it if it's a string, make it a gradient if it's a
				 * gradient configuration object
				 * 
				 * @param {Object} color The color or config object
				 */
				color: function(color, elem, prop) {
					var colorObject,
						regexRgba = /^rgba/;
					if (color && color.linearGradient) {
						var renderer = this,
							strLinearGradient = 'linearGradient',
							linearGradient = color[strLinearGradient],
							id = PREFIX + idCounter++,
							gradientObject,
							stopColor,
							stopOpacity;
						gradientObject = renderer.createElement(strLinearGradient).attr({
							id: id,
							gradientUnits: 'userSpaceOnUse',
							x1: linearGradient[0],
							y1: linearGradient[1],
							x2: linearGradient[2],
							y2: linearGradient[3]
						}).add(renderer.defs);

						each(color.stops, function(stop) {
							if (regexRgba.test(stop[1])) {
								colorObject = Color(stop[1]);
								stopColor = colorObject.get('rgb');
								stopOpacity = colorObject.get('a');
							} else {
								stopColor = stop[1];
								stopOpacity = 1;
							}
							renderer.createElement('stop').attr({
								offset: stop[0],
								'stop-color': stopColor,
								'stop-opacity': stopOpacity
							}).add(gradientObject);
						});

						return 'url('+ this.url +'#'+ id +')';

					// Webkit and Batik can't show rgba.
					} else if (regexRgba.test(color)) {
						colorObject = Color(color);
						attr(elem, prop +'-opacity', colorObject.get('a'));

						return colorObject.get('rgb');


					} else {
						return color;
					}

				},


				/**
				 * Add text to the SVG object
				 * @param {String} str
				 * @param {Number} x Left position
				 * @param {Number} y Top position
				 * @param {Object} style CSS styles for the text
				 * @param {Nubmer} rotation Rotation in degrees
				 * @param {String} align Left, center or right
				 */
				text: function(str, x, y) {

					// declare variables
					var defaultChartStyle = defaultOptions.chart.style,
						wrapper;

					x = mathRound(pick(x, 0));
					y = mathRound(pick(y, 0));

					wrapper = this.createElement('text')
						.attr({
							x: x,
							y: y,
							text: str				
						})
						.css({
							'font-family': defaultChartStyle.fontFamily,
							'font-size': defaultChartStyle.fontSize
						});

					wrapper.x = x;
					wrapper.y = y;
					return wrapper;
				}
			}; // end SVGRenderer




			/* **************************************************************************** 
			 *                                                                            * 
			 * START OF INTERNET EXPLORER <= 8 SPECIFIC CODE                              *
			 *                                                                            *
			 * For applications and websites that don't need IE support, like platform    *
			 * targeted mobile apps and web apps, this code can be removed.               *
			 *                                                                            *
			 *****************************************************************************/
			var VMLRenderer;
			if (!hasSVG) {

			/**
			 * The VML element wrapper.
			 */
			var VMLElement = extendClass( SVGElement, {

				/**
				 * Initialize a new VML element wrapper. It builds the markup as a string
				 * to minimize DOM traffic.
				 * @param {Object} renderer
				 * @param {Object} nodeName
				 */
				init: function(renderer, nodeName) {
					var markup =  ['<', nodeName, ' filled="f" stroked="f"'],
						style = ['position: ', ABSOLUTE, ';'];

					// divs and shapes need size
					if (nodeName == 'shape' || nodeName == DIV) {
						style.push('left:0;top:0;width:10px;height:10px;');
					}
					if (docMode8) {
						style.push('visibility: ', nodeName == DIV ? HIDDEN : VISIBLE);
					}

					markup.push(' style="', style.join(''), '"/>');

					// create element with default attributes and style
					if (nodeName) {
						markup = nodeName == DIV || nodeName == 'span' || nodeName == 'img' ? 
							markup.join('')
							: renderer.prepVML(markup);
						this.element = createElement(markup);
					}

					this.renderer = renderer;
				},

				/**
				 * Add the node to the given parent
				 * @param {Object} parent
				 */
				add: function(parent) {
					var wrapper = this,
						renderer = wrapper.renderer,
						element = wrapper.element,
						box = renderer.box,
						inverted = parent && parent.inverted,

						// get the parent node
						parentNode = parent ? 
							parent.element || parent : 
							box;


					// if the parent group is inverted, apply inversion on all children
					if (inverted) { // only on groups
						renderer.invertChild(element, parentNode);			
					}

					// append it
					parentNode.appendChild(element);

					// align text after adding to be able to read offset
					wrapper.added = true;
					if (wrapper.alignOnAdd) {
						wrapper.updateTransform();
					}

					return wrapper;
				},

				/**
				 * Get or set attributes
				 */
				attr: function(hash, val) {
					var key, 
						value, 
						i, 
						element = this.element || {},
						elemStyle = element.style,
						nodeName = element.nodeName,
						renderer = this.renderer,
						symbolName = this.symbolName,
						childNodes,
						hasSetSymbolSize,
						shadows = this.shadows,
						skipAttr,
						ret = this;

					// single key-value pair
					if (isString(hash) && defined(val)) {
						key = hash;
						hash = {};
						hash[key] = val;
					}

					// used as a getter, val is undefined
					if (isString(hash)) {
						key = hash;
						if (key == 'strokeWidth' || key == 'stroke-width') {
							ret = this.strokeweight;
						} else {
							ret = this[key];
						}

					// setter
					} else {		
						for (key in hash) {
							value = hash[key];
							skipAttr = false;

							// prepare paths
							// symbols
							if (symbolName && /^(x|y|r|start|end|width|height|innerR)/.test(key)) {
								// if one of the symbol size affecting parameters are changed,
								// check all the others only once for each call to an element's
								// .attr() method
								if (!hasSetSymbolSize) {

									this.symbolAttr(hash);						

									hasSetSymbolSize = true;
								} 

								skipAttr = true;

							} else if (key == 'd') {
								value = value || [];
								this.d = value.join(' '); // used in getter for animation

								// convert paths 
								i = value.length;
								var convertedPath = [];
								while (i--) {					

									// Multiply by 10 to allow subpixel precision.
									// Substracting half a pixel seems to make the coordinates
									// align with SVG, but this hasn't been tested thoroughly
									if (isNumber(value[i])) {
										convertedPath[i] = mathRound(value[i] * 10) - 5;
									}
									// close the path
									else if (value[i] == 'Z') {
										convertedPath[i] = 'x';
									} 
									else {
										convertedPath[i] = value[i];
									}

								}
								value = convertedPath.join(' ') || 'x';							
								element.path = value;

								// update shadows
								if (shadows) {
									i = shadows.length;
									while (i--) {
										shadows[i].path = value;
									}
								}
								skipAttr = true;

							// directly mapped to css
							} else if (key == 'zIndex' || key == 'visibility') {

								// issue 61 workaround
								if (docMode8 && key == 'visibility' && nodeName == 'DIV') {
									childNodes = element.childNodes;
									i = childNodes.length;
									while (i--) {
										css(childNodes[i], { visibility: value });
									}
									if (value == VISIBLE) { // issue 74
										value = null;
									}
								}

								if (value) {
									elemStyle[key] = value;
								}



								skipAttr = true;

							// width and height
							} else if (/^(width|height)$/.test(key)) {


								// clipping rectangle special
								if (this.updateClipping) {
									this[key] = value;
									this.updateClipping();

								} else {
									// normal
									elemStyle[key] = value;
								}

								skipAttr = true;

							// x and y 
							} else if (/^(x|y)$/.test(key)) {

								this[key] = value; // used in getter

								if (element.tagName == 'SPAN') {
									this.updateTransform();

								} else {
									elemStyle[{ x: 'left', y: 'top' }[key]] = value;
								}

							// class name
							} else if (key == 'class') {
								// IE8 Standards mode has problems retrieving the className
								element.className = value;

							// stroke
							} else if (key == 'stroke') {

								value = renderer.color(value, element, key);				

								key = 'strokecolor';

							// stroke width
							} else if (key == 'stroke-width' || key == 'strokeWidth') {
								element.stroked = value ? true : false;
								key = 'strokeweight';
								this[key] = value; // used in getter, issue #113
								if (isNumber(value)) {
									value += PX;
								}

							// dashStyle					 
							} else if (key == 'dashstyle') {
								var strokeElem = element.getElementsByTagName('stroke')[0] ||
									createElement(renderer.prepVML(['<stroke/>']), null, null, element);
								strokeElem[key] = value || 'solid';
								this.dashstyle = value; /* because changing stroke-width will change the dash length
									and cause an epileptic effect */ 
								skipAttr = true;

							// fill
							} else if (key == 'fill') {

								if (nodeName == 'SPAN') { // text color
									elemStyle.color = value;
								} else {
									element.filled = value != NONE ? true : false;

									value = renderer.color(value, element, key);

									key = 'fillcolor';
								}

							// translation for animation
							} else if (key == 'translateX' || key == 'translateY' || key == 'rotation' || key == 'align') {
								if (key == 'align') {
									key = 'textAlign';
								}
								this[key] = value;
								this.updateTransform();

								skipAttr = true;
							}

							// text for rotated and non-rotated elements
							else if (key == 'text') {
								element.innerHTML = value;
								skipAttr = true;
							} 


							// let the shadow follow the main element
							if (shadows && key == 'visibility') {
								i = shadows.length;
								while (i--) {
									shadows[i].style[key] = value;
								}
							}



							if (!skipAttr) {
								if (docMode8) { // IE8 setAttribute bug
									element[key] = value;
								} else {
									attr(element, key, value);
								}
							}
						}			
					}
					return ret;
				},

				/**
				 * Set the element's clipping to a predefined rectangle
				 * 
				 * @param {String} id The id of the clip rectangle
				 */
				clip: function(clipRect) {
					var wrapper = this,
						clipMembers = clipRect.members,
						index = clipMembers.length;

					clipMembers.push(wrapper);
					wrapper.destroyClip = function() {
						clipMembers.splice(index, 1);
					};
					return wrapper.css(clipRect.getCSS(wrapper.inverted));
				},

				/**
				 * Set styles for the element
				 * @param {Object} styles
				 */
				css: function(styles) {
					var wrapper = this;

					css(wrapper.element, styles);

					return wrapper;
				},

				/**
				 * Extend element.destroy by removing it from the clip members array
				 */
				destroy: function() {
					var wrapper = this;

					if (wrapper.destroyClip) {
						wrapper.destroyClip();
					}

					SVGElement.prototype.destroy.apply(this);
				},

				/**
				 * Remove all child nodes of a group, except the v:group element
				 */
				empty: function() {
					var element = this.element,
						childNodes = element.childNodes,
						i = childNodes.length,
						node;

					while (i--) {
						node = childNodes[i];
						node.parentNode.removeChild(node);
					}
				},

				/**
				 * VML override for calculating the bounding box based on offsets
				 * 
				 * @return {Object} A hash containing values for x, y, width and height
				 */

				getBBox: function() {
					var element = this.element;
						/*bBox,
						hasOffsetWidth = element.offsetWidth,
						origParentNode = element.parentNode;

					if (!hasOffsetWidth) {
						doc.body.appendChild(element);
					}
					*/
					return {
						x: element.offsetLeft,
						y: element.offsetTop,
						width: element.offsetWidth,
						height: element.offsetHeight
					};

					/*if (!hasOffsetWidth) {
						if (origParentNode) {
							origParentNode.appendChild(element);
						} else {
							doc.body.removeChild(element);
						}
					}

					return bBox;*/

				},

				/**
				 * Add an event listener. VML override for normalizing event parameters.
				 * @param {String} eventType
				 * @param {Function} handler
				 */
				on: function(eventType, handler) {
					// simplest possible event model for internal use
					this.element['on'+ eventType] = function() {
						var evt = win.event;
						evt.target = evt.srcElement;
						handler(evt);
					};
					return this;
				},


				/**
				 * Private method to update elements based on internal 
				 * properties based on SVG transform
				 */
				updateTransform: function(hash) {
					// aligning non added elements is expensive
					if (!this.added) {
						this.alignOnAdd = true;
						return;
					}


					var wrapper = this,
						elem = wrapper.element,
						translateX = wrapper.translateX || 0,
						translateY = wrapper.translateY || 0,
						x = wrapper.x || 0,
						y = wrapper.y || 0,
						rotation = wrapper.rotation || 0,
						radians = rotation * deg2rad, // deg to rad
						costheta = mathCos(radians),
						sintheta = mathSin(radians), 
						align = wrapper.textAlign || 'left',
						alignCorrection = { right: 1, center: 2 }[align],
						nonLeft = align && align != 'left';			


					// apply translate
					if (translateX || translateY) {
						wrapper.css({
							marginLeft: translateX,
							marginTop: translateY
						});
					}

					// apply inversion
					if (wrapper.inverted) { // wrapper is a group
						each(elem.childNodes, function(child) {
							wrapper.renderer.invertChild(child, elem);
						});
					}

					if (elem.tagName == 'SPAN') {
						// Adjust for alignment and rotation.
						// Test case: http://highcharts.com/tests/?file=text-rotation
						css(elem, {
							filter: rotation ? ['progid:DXImageTransform.Microsoft.Matrix(M11=', costheta, 
								', M12=', -sintheta, ', M21=', sintheta, ', M22=', costheta, 
								', sizingMethod=\'auto expand\')'].join('') : NONE
						});

						var width = elem.offsetWidth,
							height = elem.offsetHeight,
							lineHeight = mathRound(pInt(elem.style.fontSize || 12) * 1.2);

						// correct x and y
						x += width * mathMin(costheta, 0) + mathMin(sintheta, 0) * lineHeight;
						y += height * mathMin(sintheta, 0) - mathMax(costheta, 0) * lineHeight;

						if (nonLeft) {
							x -= width / alignCorrection * costheta;
							y -= height / alignCorrection * sintheta;
						}

						css(elem, {
							textAlign: align,
							left: x,
							top: y
						});

					}
				},

				/**
				 * Apply a drop shadow by copying elements and giving them different strokes 
				 * @param {Boolean} apply
				 */
				shadow: function(apply) {
					var shadows = [],
						i,
						element = this.element,
						renderer = this.renderer,
						shadow,
						elemStyle = element.style,
						markup,
						path = element.path;

					// the path is some mysterious string-like object that can be cast to a string
					if (''+ element.path === '') {
						path = 'x';
					}

					if (apply) {
						for (i = 1; i <= 3; i++) {
							markup = ['<shape isShadow="true" strokeweight="', ( 7 - 2 * i ) ,
								'" filled="false" path="', path,
								'" coordsize="100,100" style="', element.style.cssText, '" />'];
							shadow = createElement(renderer.prepVML(markup),
								null, {
									left: pInt(elemStyle.left) + 1,
									top: pInt(elemStyle.top) + 1
								}
							);

							// apply the opacity
							markup = ['<stroke color="black" opacity="', (0.05 * i), '"/>'];
							createElement(renderer.prepVML(markup), null, null, shadow);				


							// insert it
							element.parentNode.insertBefore(shadow, element);

							// record it
							shadows.push(shadow);				

						}

						this.shadows = shadows;
					}
					return this;

				}
			});

			/**
			 * The VML renderer
			 */
			VMLRenderer = function() {
				this.init.apply(this, arguments);
			};
			VMLRenderer.prototype = merge( SVGRenderer.prototype, { // inherit SVGRenderer

				isIE8: userAgent.indexOf('MSIE 8.0') > -1,


				/**
				 * Initialize the VMLRenderer
				 * @param {Object} container
				 * @param {Number} width
				 * @param {Number} height
				 */
				init: function(container, width, height) {
					var renderer = this,
						boxWrapper;

					renderer.Element = VMLElement;
					renderer.alignedObjects = [];

					boxWrapper = renderer.createElement(DIV);
					container.appendChild(boxWrapper.element);


					// generate the containing box
					renderer.box = boxWrapper.element;
					renderer.boxWrapper = boxWrapper;


					renderer.setSize(width, height, false);

					// The only way to make IE6 and IE7 print is to use a global namespace. However,
					// with IE8 the only way to make the dynamic shapes visible in screen and print mode
					// seems to be to add the xmlns attribute and the behaviour style inline. 
					if (!doc.namespaces.hcv) {			

						doc.namespaces.add('hcv', 'urn:schemas-microsoft-com:vml');

						// setup default css
						doc.createStyleSheet().cssText = 
							'hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke'+
							'{ behavior:url(#default#VML); display: inline-block; } ';

					}	
				},

				/**
				 * Define a clipping rectangle. In VML it is accomplished by storing the values
				 * for setting the CSS style to all associated members.
				 * 
				 * @param {Number} x
				 * @param {Number} y
				 * @param {Number} width
				 * @param {Number} height
				 */
				clipRect: function (x, y, width, height) {

					// create a dummy element
					var clipRect = this.createElement();

					// mimic a rectangle with its style object for automatic updating in attr
					return extend(clipRect, {
						members: [],
						left: x,
						top: y,
						width: width,
						height: height,
						getCSS: function(inverted) {
							var rect = this,//clipRect.element.style,
								top = rect.top,
								left = rect.left,
								right = left + rect.width,
								bottom = top + rect.height,
								ret = {
									clip: 'rect('+ 
										mathRound(inverted ? left : top) + 'px,'+ 
										mathRound(inverted ? bottom : right) + 'px,'+ 
										mathRound(inverted ? right : bottom) + 'px,'+ 
										mathRound(inverted ? top : left) +'px)'
								};

							// issue 74 workaround
							if (!inverted && docMode8) {
								extend(ret, {
									width: right +PX,
									height: bottom +PX
								});
							}
							return ret;
						},

						// used in attr and animation to update the clipping of all members
						updateClipping: function() {
							each(clipRect.members, function(member) {
								member.css(clipRect.getCSS(member.inverted));
							});
						}
					});

				},


				/**
				 * Take a color and return it if it's a string, make it a gradient if it's a
				 * gradient configuration object, and apply opacity.
				 * 
				 * @param {Object} color The color or config object
				 */
				color: function(color, elem, prop) {
					var colorObject,
						regexRgba = /^rgba/,
						markup;

					if (color && color.linearGradient) {

						var stopColor, 
							stopOpacity,
							linearGradient = color.linearGradient,
							angle,
							color1,
							opacity1,
							color2,
							opacity2;	

						each(color.stops, function(stop, i) {
							if (regexRgba.test(stop[1])) {
								colorObject = Color(stop[1]);
								stopColor = colorObject.get('rgb');
								stopOpacity = colorObject.get('a');
							} else {
								stopColor = stop[1];
								stopOpacity = 1;
							}

							if (!i) { // first
								color1 = stopColor;
								opacity1 = stopOpacity;
							} else {
								color2 = stopColor;
								opacity2 = stopOpacity;
							}
						});



						// calculate the angle based on the linear vector
						angle = 90  - math.atan(
							(linearGradient[3] - linearGradient[1]) / // y vector
							(linearGradient[2] - linearGradient[0]) // x vector
							) * 180 / mathPI;

						// when colors attribute is used, the meanings of opacity and o:opacity2
						// are reversed.
						markup = ['<', prop, ' colors="0% ', color1, ',100% ', color2, '" angle="', angle,
							'" opacity="', opacity2, '" o:opacity2="', opacity1,
							'" type="gradient" focus="100%" />'];
						createElement(this.prepVML(markup), null, null, elem);



					// if the color is an rgba color, split it and add a fill node
					// to hold the opacity component
					} else if (regexRgba.test(color) && elem.tagName != 'IMG') {

						colorObject = Color(color);

						markup = ['<', prop, ' opacity="', colorObject.get('a'), '"/>'];
						createElement(this.prepVML(markup), null, null, elem);

						return colorObject.get('rgb');


					} else {
						return color;
					}

				},

				/**
				 * Take a VML string and prepare it for either IE8 or IE6/IE7. 
				 * @param {Array} markup A string array of the VML markup to prepare
				 */
				prepVML: function(markup) {
					var vmlStyle = 'display:inline-block;behavior:url(#default#VML);',
						isIE8 = this.isIE8;

					markup = markup.join('');

					if (isIE8) { // add xmlns and style inline
						markup = markup.replace('/>', ' xmlns="urn:schemas-microsoft-com:vml" />');
						if (markup.indexOf('style="') == -1) {
							markup = markup.replace('/>', ' style="'+ vmlStyle +'" />');
						} else {
							markup = markup.replace('style="', 'style="'+ vmlStyle);
						}

					} else { // add namespace
						markup = markup.replace('<', '<hcv:');
					}

					return markup;
				},

				/**
				 * Create rotated and aligned text
				 * @param {String} str
				 * @param {Number} x
				 * @param {Number} y
				 */
				text: function(str, x, y) {

					var defaultChartStyle = defaultOptions.chart.style; 

					return this.createElement('span')
						.attr({
							text: str,
							x: mathRound(x),
							y: mathRound(y)
						})
						.css({
							whiteSpace: 'nowrap',
							fontFamily: defaultChartStyle.fontFamily,
							fontSize: defaultChartStyle.fontSize
						});
				},

				/**
				 * Create and return a path element
				 * @param {Array} path
				 */
				path: function (path) {
					// create the shape
					return this.createElement('shape').attr({
						// subpixel precision down to 0.1 (width and height = 10px)
						coordsize: '100 100',
						d: path
					});
				},

				/**
				 * Create and return a circle element. In VML circles are implemented as
				 * shapes, which is faster than v:oval
				 * @param {Number} x
				 * @param {Number} y
				 * @param {Number} r
				 */
				circle: function(x, y, r) {
					return this.path(this.symbols.circle(x, y, r));
				},

				/**
				 * Create a group using an outer div and an inner v:group to allow rotating 
				 * and flipping. A simple v:group would have problems with positioning
				 * child HTML elements and CSS clip.
				 * 
				 * @param {String} name The name of the group
				 */
				g: function(name) {
					var wrapper,
						attribs;

					// set the class name	
					if (name) {
						attribs = { 'className': PREFIX + name, 'class': PREFIX + name };
					}

					// the div to hold HTML and clipping	
					wrapper = this.createElement(DIV).attr(attribs);

					return wrapper;
				},

				/**
				 * VML override to create a regular HTML image
				 * @param {String} src
				 * @param {Number} x
				 * @param {Number} y
				 * @param {Number} width
				 * @param {Number} height
				 */
				image: function(src, x, y, width, height) {
					var obj = this.createElement('img')
						.attr({ src: src });

					if (arguments.length > 1) {
						obj.css({
							left: x,
							top: y,
							width: width,
							height: height
						});
					}
					return obj;
				},

				/**
				 * VML uses a shape for rect to overcome bugs and rotation problems
				 */
				rect: function(x, y, width, height, r, strokeWidth) {
					// todo: share this code with SVG
					if (arguments.length > 1) {
						var normalizer = (strokeWidth || 0) % 2 / 2;

						// normalize for crisp edges
						x = mathRound(x || 0) + normalizer;
						y = mathRound(y || 0) + normalizer;
						width = mathRound((width || 0) - 2 * normalizer);
						height = mathRound((height || 0) - 2 * normalizer);
					}

					if (isObject(x)) { // the attributes can be passed as the first argument 
						y = x.y;
						width = x.width;
						height = x.height;
						r = x.r;
						x = x.x;
					} 

					return this.symbol('rect', x || 0, y || 0, r || 0, {
						width: width || 0,
						height: height || 0
					});		
				},

				/**
				 * In the VML renderer, each child of an inverted div (group) is inverted
				 * @param {Object} element
				 * @param {Object} parentNode
				 */
				invertChild: function(element, parentNode) {
					var parentStyle = parentNode.style;

					css(element, { 
						flip: 'x',
						left: pInt(parentStyle.width) - 10,
						top: pInt(parentStyle.height) - 10,
						rotation: -90
					});
				},

				/**
				 * Symbol definitions that override the parent SVG renderer's symbols
				 * 
				 */
				symbols: {
					// VML specific arc function
					arc: function (x, y, radius, options) {
						var start = options.start,
							end = options.end,
							cosStart = mathCos(start),
							sinStart = mathSin(start),
							cosEnd = mathCos(end),
							sinEnd = mathSin(end),
							innerRadius = options.innerR;

						if (end - start === 0) { // no angle, don't show it. 
							return ['x'];

						} else if (end - start == 2 * mathPI) { // full circle
							// empirical correction found by trying out the limits for different radii
							cosEnd = -0.07 / radius;
						}

						return [
							'wa', // clockwise arc to
							x - radius, // left
							y - radius, // top
							x + radius, // right
							y + radius, // bottom
							x + radius * cosStart, // start x
							y + radius * sinStart, // start y
							x + radius * cosEnd, // end x
							y + radius * sinEnd, // end y


							'at', // anti clockwise arc to
							x - innerRadius, // left
							y - innerRadius, // top
							x + innerRadius, // right
							y + innerRadius, // bottom
							x + innerRadius * cosEnd, // start x
							y + innerRadius * sinEnd, // start y
							x + innerRadius * cosStart, // end x
							y + innerRadius * sinStart, // end y

							'x', // finish path
							'e' // close
						];

					},
					// Add circle symbol path. This performs significantly faster than v:oval.
					circle: function (x, y, r) {
						return [
							'wa', // clockwisearcto
							x - r, // left
							y - r, // top
							x + r, // right
							y + r, // bottom
							x + r, // start x
							y,     // start y
							x + r, // end x
							y,     // end y
							//'x', // finish path
							'e' // close
						];
					},
					/** 
					 * Add rectangle symbol path which eases rotation and omits arcsize problems
					 * compared to the built-in VML roundrect shape
					 * 
					 * @param {Object} left Left position
					 * @param {Object} top Top position
					 * @param {Object} r Border radius
					 * @param {Object} options Width and height
					 */

					rect: function (left, top, r, options) {
						var width = options.width,
							height = options.height,
							right = left + width,
							bottom = top + height;

						r = mathMin(r, width, height);

						return [
							M,
							left + r, top,

							L,
							right - r, top,
							'wa',
							right - 2 * r, top,
							right, top + 2 * r,
							right - r, top,
							right, top + r,

							L,
							right, bottom - r,
							'wa',
							right - 2 * r, bottom - 2 * r,
							right, bottom,
							right, bottom - r,
							right - r, bottom,

							L,
							left + r, bottom,
							'wa',
							left, bottom - 2 * r,
							left + 2 * r, bottom, 
							left + r, bottom,
							left, bottom - r,

							L,
							left, top + r,
							'wa',
							left, top,
							left + 2 * r, top + 2 * r,
							left, top + r,
							left + r, top,


							'x',
							'e'
						];

					}
				}
			});
			}
			/* **************************************************************************** 
			 *                                                                            * 
			 * END OF INTERNET EXPLORER <= 8 SPECIFIC CODE                                *
			 *                                                                            *
			 *****************************************************************************/

			/**
			 * General renderer
			 */
			var Renderer = hasSVG ?	SVGRenderer : VMLRenderer;


			/**
			 * The chart class
			 * @param {Object} options
			 * @param {Function} callback Function to run when the chart has loaded
			 */
			function Chart (options, callback) {

				defaultXAxisOptions = merge(defaultXAxisOptions, defaultOptions.xAxis);
				defaultYAxisOptions = merge(defaultYAxisOptions, defaultOptions.yAxis);
				defaultOptions.xAxis = defaultOptions.yAxis = null;

				// Handle regular options
				options = merge(defaultOptions, options);

				// Define chart variables
				var optionsChart = options.chart,
					optionsMargin = optionsChart.margin,
					margin = isObject(optionsMargin) ?
						optionsMargin : 
						[optionsMargin, optionsMargin, optionsMargin, optionsMargin],
					optionsMarginTop = pick(optionsChart.marginTop, margin[0]),
					optionsMarginRight = pick(optionsChart.marginRight, margin[1]),
					optionsMarginBottom = pick(optionsChart.marginBottom, margin[2]),
					optionsMarginLeft = pick(optionsChart.marginLeft, margin[3]),
					spacingTop = optionsChart.spacingTop,
					spacingRight = optionsChart.spacingRight,
					spacingBottom = optionsChart.spacingBottom,
					spacingLeft = optionsChart.spacingLeft,
					spacingBox, 
					chartTitleOptions,
					chartSubtitleOptions,
					plotTop,
					marginRight,
					marginBottom,
					plotLeft,
					axisOffset,
					renderTo,
					renderToClone,
					container,
					containerId,
					containerWidth,
					containerHeight,
					chartWidth,
					chartHeight,
					oldChartWidth,
					oldChartHeight,
					chartBackground,
					plotBackground,
					plotBGImage,
					plotBorder,
					chart = this,
					chartEvents = optionsChart.events,
					eventType,
					isInsidePlot, // function
					tooltip,
					mouseIsDown,
					loadingDiv,
					loadingSpan,
					loadingShown,
					plotHeight,
					plotWidth,
					tracker,
					trackerGroup,
					placeTrackerGroup,
					legend,
					legendWidth,
					legendHeight,
					chartPosition,// = getPosition(container),
					hasCartesianSeries = optionsChart.showAxes,
					isResizing = 0,
					axes = [],
					maxTicks, // handle the greatest amount of ticks on grouped axes
					series = [], 
					inverted,
					renderer,
					tooltipTick,
					tooltipInterval,
					hoverX,
					drawChartBox, // function
					getMargins, // function
					resetMargins, // function
					setChartSize, // function
					resize,
					zoom, // function
					zoomOut; // function


				/**
				 * Create a new axis object
				 * @param {Object} chart
				 * @param {Object} options
				 */
				function Axis (chart, options) {

					// Define variables
					var isXAxis = options.isX,
						opposite = options.opposite, // needed in setOptions			
						horiz = inverted ? !isXAxis : isXAxis,
						side = horiz ? 
							(opposite ? 0 /* top */  : 2 /* bottom */) :
							(opposite ? 1 /* right*/ : 3 /* left */  ),
						stacks = {};


					options = merge(
							isXAxis ? defaultXAxisOptions : defaultYAxisOptions,
							[defaultTopAxisOptions, defaultRightAxisOptions, 
								defaultBottomAxisOptions, defaultLeftAxisOptions][side],
							options
						);

					var axis = this,
						isDatetimeAxis = options.type == 'datetime',
						offset = options.offset || 0,
						xOrY = isXAxis ? 'x' : 'y',
						axisLength,
						transA, // translation factor
						oldTransA, // used for prerendering
						transB = horiz ? plotLeft : marginBottom, // translation addend
						translate, // fn
						getPlotLinePath, // fn
						axisGroup,
						gridGroup,
						axisLine,
						dataMin,
						dataMax,
						associatedSeries,
						userSetMin,
						userSetMax,
						max = null,
						min = null,
						oldMin,
						oldMax,
						minPadding = options.minPadding,
						maxPadding = options.maxPadding,
						isLinked = defined(options.linkedTo),
						ignoreMinPadding, // can be set to true by a column or bar series
						ignoreMaxPadding,
						usePercentage,
						events = options.events,
						eventType,
						plotLinesAndBands = [],
						tickInterval,
						minorTickInterval,
						magnitude,
						tickPositions, // array containing predefined positions
						ticks = {},
						minorTicks = {},
						alternateBands = {},
						tickAmount,
						labelOffset,
						axisTitleMargin,// = options.title.margin,
						dateTimeLabelFormat,
						categories = options.categories,
						labelFormatter = options.labels.formatter ||  // can be overwritten by dynamic format
							function() {
								var value = this.value, 
									ret;

								if (dateTimeLabelFormat) { // datetime axis
									ret = dateFormat(dateTimeLabelFormat, value);

								} else if (tickInterval % 1000000 === 0) { // use M abbreviation
									ret = (value / 1000000) +'M';

								} else if (tickInterval % 1000 === 0) { // use k abbreviation
									ret = (value / 1000) +'k';

								} else if (!categories && value >= 1000) { // add thousands separators
									ret = numberFormat(value, 0);

								} else { // strings (categories) and small numbers
									ret = value;
								}
								return ret;
							},

						staggerLines = horiz && options.labels.staggerLines,
						reversed = options.reversed,
						tickmarkOffset = (categories && options.tickmarkPlacement == 'between') ? 0.5 : 0;		

					/**
					 * The Tick class
					 */
					function Tick(pos, minor) {
						var tick = this;
						tick.pos = pos;
						tick.minor = minor;
						tick.isNew = true;				

						if (!minor) {
							tick.addLabel();
						}
					}
					Tick.prototype = {
						/**
						 * Write the tick label
						 */
						addLabel: function() {
							var pos = this.pos,
								labelOptions = options.labels,
								str,
								withLabel = !((pos == min && !pick(options.showFirstLabel, 1)) ||
									(pos == max && !pick(options.showLastLabel, 0))),
								label = this.label;


							// get the string
							str = labelFormatter.call({
									isFirst: pos == tickPositions[0],
									isLast: pos == tickPositions[tickPositions.length - 1],
									dateTimeLabelFormat: dateTimeLabelFormat,
									value: (categories && categories[pos] ? categories[pos] : pos)
								});

							// first call	
							if (label === UNDEFINED) {
								this.label =  
									defined(str) && withLabel && labelOptions.enabled ?
										renderer.text(
												str,
												0,
												0
											)
											.attr({
												align: labelOptions.align,
												rotation: labelOptions.rotation
											})
											.css(labelOptions.style)
											.add(axisGroup):
										null;

							// update
							} else if (label) {
								label.attr({ text: str });
							}

						},
						/**
						 * Get the offset height or width of the label
						 */
						getLabelSize: function() {
							var label = this.label;
							return label ? 
								((this.labelBBox = label.getBBox()))[horiz ? 'height' : 'width'] :
								0;
						},
						/**
						 * Put everything in place
						 * 
						 * @param index {Number}
						 * @param old {Boolean} Use old coordinates to prepare an animation into new position
						 */
						render: function(index, old) {
							var tick = this,
								major = !tick.minor,
								label = tick.label,
								pos = tick.pos,
								labelOptions = options.labels,
								gridLine = tick.gridLine,
								gridLineWidth = major ? options.gridLineWidth : options.minorGridLineWidth,
								gridLineColor = major ? options.gridLineColor : options.minorGridLineColor,
								dashStyle = major ? 
									options.gridLineDashStyle : 
									options.minorGridLineDashStyle,
								gridLinePath,
								mark = tick.mark,
								markPath,
								tickLength = major ? options.tickLength : options.minorTickLength,
								tickWidth = major ? options.tickWidth : (options.minorTickWidth || 0),
								tickColor = major ? options.tickColor : options.minorTickColor,
								tickPosition = major ? options.tickPosition : options.minorTickPosition,
								step = labelOptions.step,
								cHeight = old && oldChartHeight || chartHeight,
								attribs,
								x,
								y;

							// get x and y position for ticks and labels
							x = horiz ? 
								translate(pos + tickmarkOffset, null, null, old) + transB : 
								plotLeft + offset + (opposite ? (old && oldChartWidth || chartWidth) - marginRight - plotLeft : 0);

							y = horiz ?
								cHeight - marginBottom + offset - (opposite ? plotHeight : 0) :
								cHeight - translate(pos + tickmarkOffset, null, null, old) - transB;

							// create the grid line
							if (gridLineWidth) {
								gridLinePath = getPlotLinePath(pos + tickmarkOffset, gridLineWidth, old);

								if (gridLine === UNDEFINED) {
									attribs = {
										stroke: gridLineColor,
										'stroke-width': gridLineWidth
									};
									if (dashStyle) {
										attribs.dashstyle = dashStyle;
									}
									tick.gridLine = gridLine =
										gridLineWidth ?
											renderer.path(gridLinePath)
												.attr(attribs).add(gridGroup) :
											null;
								} 
								if (gridLine) {
									gridLine.animate({
										d: gridLinePath
									});
								}
							}

							// create the tick mark
							if (tickWidth) {

								// negate the length
								if (tickPosition == 'inside') {
									tickLength = -tickLength;
								}
								if (opposite) {
									tickLength = -tickLength;
								}

								markPath = renderer.crispLine([
									M, 
									x, 
									y, 
									L, 
									x + (horiz ? 0 : -tickLength), 
									y + (horiz ? tickLength : 0)
								], tickWidth);

								if (mark) { // updating
									mark.animate({
										d: markPath
									});
								} else { // first time
									tick.mark = renderer.path(
										markPath
									).attr({
										stroke: tickColor,
										'stroke-width': tickWidth
									}).add(axisGroup);
								}
							}

							// the label is created on init - now move it into place
							if (label) { 
								x = x + labelOptions.x - (tickmarkOffset && horiz ? 
									tickmarkOffset * transA * (reversed ? -1 : 1) : 0); 
								y = y + labelOptions.y - (tickmarkOffset && !horiz ? 
									tickmarkOffset * transA * (reversed ? 1 : -1) : 0);

								// correct for staggered labels
								if (staggerLines) {
									y += (index % staggerLines) * 16;
								}
								// apply step
								if (step) {
									// show those indices dividable by step 
									label[index % step ? 'hide' : 'show']();
								}

								label[tick.isNew ? 'attr' : 'animate']({
									x: x,
									y: y
								});
							}

							tick.isNew = false;
						},
						/**
						 * Destructor for the tick prototype
						 */
						destroy: function() {
							var tick = this,
								n;
							for (n in tick) {
								if (tick[n] && tick[n].destroy) {
									tick[n].destroy();
								}
							}
						}
					};

					/**
					 * The object wrapper for plot lines and plot bands
					 * @param {Object} options
					 */
					function PlotLineOrBand(options) {
						var plotLine = this;
						if (options) {
							plotLine.options = options;
							plotLine.id = options.id;
						}

						//plotLine.render()
						return plotLine;
					}

					PlotLineOrBand.prototype = {

					/**
					 * Render the plot line or plot band. If it is already existing,
					 * move it.
					 */
					render: function () {
						var plotLine = this,
							options = plotLine.options,
							optionsLabel = options.label,
							label = plotLine.label,
							width = options.width,
							to = options.to,
							toPath, // bands only
							from = options.from,
							dashStyle = options.dashStyle,
							svgElem = plotLine.svgElem,
							path = [],
							addEvent,
							eventType,
							xs,
							ys,
							x,
							y,
							color = options.color,
							zIndex = options.zIndex,
							events = options.events,
							attribs;

						// plot line
						if (width) {
							path = getPlotLinePath(options.value, width);
							attribs = {
								stroke: color,
								'stroke-width': width
							};
							if (dashStyle) {
								attribs.dashstyle = dashStyle;
							}
						}

						// plot band
						else if (defined(from) && defined(to)) {
							// keep within plot area
							from = mathMax(from, min);
							to = mathMin(to, max);  

							toPath = getPlotLinePath(to);
							path = getPlotLinePath(from);
							if (path && toPath) {
								path.push(
									toPath[4],
									toPath[5],
									toPath[1],
									toPath[2]
								);
							} else { // outside the axis area
								path = null;
							}
							attribs = {
								fill: color
							};
						} else {
							return;
						}
						// zIndex 
						if (defined(zIndex)) {
							attribs.zIndex = zIndex;
						}

						// common for lines and bands
						if (svgElem) {
							if (path) {
								svgElem.animate({
									d: path
								}, null, svgElem.onGetPath);
							} else {
								svgElem.hide();
								svgElem.onGetPath = function() {
									svgElem.show();
								}
							}
						} else if (path && path.length) {
							plotLine.svgElem = svgElem = renderer.path(path)
								.attr(attribs).add();

							// events
							if (events) {
								addEvent = function(eventType) {
									svgElem.on(eventType, function(e) {
										events[eventType].apply(plotLine, [e]);
									});
								};
								for (eventType in events) {
									addEvent(eventType);
								}
							}
						}

						// the plot band/line label
						if (optionsLabel && defined(optionsLabel.text) && path && path.length && plotWidth > 0 && plotHeight > 0) {
							// apply defaults
							optionsLabel = merge({
								align: horiz && toPath && 'center',
								x: horiz ? !toPath && 4 : 10,
								verticalAlign : !horiz && toPath && 'middle',
								y: horiz ? toPath ? 16 : 10 : toPath ? 6 : -4,
								rotation: horiz && !toPath && 90
							}, optionsLabel);

							// add the SVG element
							if (!label) {
								plotLine.label = label = renderer.text(
										optionsLabel.text,
										0,
										0
									)
									.attr({
										align: optionsLabel.textAlign || optionsLabel.align,
										rotation: optionsLabel.rotation,
										zIndex: zIndex
									})
									.css(optionsLabel.style)
									.add();
							}

							// get the bounding box and align the label
							xs = [path[1], path[4], path[6] || path[1]];
							ys = [path[2], path[5], path[7] || path[2]];
							x = mathMin.apply(math, xs);
							y = mathMin.apply(math, ys);

							label.align(optionsLabel, false, {
								x: x,
								y: y,
								width: mathMax.apply(math, xs) - x,
								height: mathMax.apply(math, ys) - y
							});
							label.show();

						} else if (label) { // move out of sight
							label.hide();
						}

						// chainable
						return plotLine;
					},

					/**
					 * Remove the plot line or band
					 */
					destroy: function() {
						var obj = this,
							n;

						for (n in obj) {
							if (obj[n] && obj[n].destroy) {
								obj[n].destroy(); // destroy SVG wrappers
							}
							delete obj[n];
						}
						// remove it from the lookup
						erase(plotLinesAndBands, obj);
					}
					};


					/**
					 * Get the minimum and maximum for the series of each axis 
					 */
					function getSeriesExtremes() {
						var posStack = [],
							negStack = [],
							run;

						// reset dataMin and dataMax in case we're redrawing
						dataMin = dataMax = null;

						// get an overview of what series are associated with this axis
						associatedSeries = [];

						each(series, function(serie) {
							run = false;


							// match this axis against the series' given or implicated axis
							each(['xAxis', 'yAxis'], function(strAxis) {
								if (
									// the series is a cartesian type, and...
									serie.isCartesian &&
									// we're in the right x or y dimension, and...
									(strAxis == 'xAxis' && isXAxis || strAxis == 'yAxis' && !isXAxis) && (
										// the axis number is given in the options and matches this axis index, or
										(serie.options[strAxis] == options.index) || 
										// the axis index is not given
										(serie.options[strAxis] === UNDEFINED && options.index === 0)
									)
								) {
									serie[strAxis] = axis;
									associatedSeries.push(serie);

									// the series is visible, run the min/max detection
									run = true;		
								}
							});
							// ignore hidden series if opted 
							if (!serie.visible && optionsChart.ignoreHiddenSeries) {
								run = false;
							}				

							if (run) {

								var stacking,
									posPointStack,
									negPointStack,
									stackKey,
									negKey;

								if (!isXAxis) {
									stacking = serie.options.stacking;
									usePercentage = stacking == 'percent';

									// create a stack for this particular series type
									if (stacking) {
										stackKey = serie.type + pick(serie.options.stack, '');
										negKey = '-'+ stackKey;
										serie.stackKey = stackKey; // used in translate

										posPointStack = posStack[stackKey] || []; // contains the total values for each x
										posStack[stackKey] = posPointStack;

										negPointStack = negStack[negKey] || [];
										negStack[negKey] = negPointStack;
									}
									if (usePercentage) {
										dataMin = 0;
										dataMax = 99;			
									}
								} 
								if (serie.isCartesian) { // line, column etc. need axes, pie doesn't
									each(serie.data, function(point, i) {
										var pointX = point.x,
											pointY = point.y,
											isNegative = pointY < 0, 
											pointStack = isNegative ? negPointStack : posPointStack,
											key = isNegative ? negKey : stackKey,
											totalPos;

										// initial values
										if (dataMin === null) {

											// start out with the first point
											dataMin = dataMax = point[xOrY]; 
										}

										// x axis
										if (isXAxis) {
											if (pointX > dataMax) {
												dataMax = pointX;
											} else if (pointX < dataMin) {
												dataMin = pointX;
											}
										}

										// y axis
										else if (defined(pointY)) {
											if (stacking) {
												pointStack[pointX] = 
													defined(pointStack[pointX]) ? 
													pointStack[pointX] + pointY : pointY;
											}

											totalPos = pointStack ? pointStack[pointX] : pointY;
											if (!usePercentage) {
												if (totalPos > dataMax) {
													dataMax = totalPos;
												} else if (totalPos < dataMin) {
													dataMin = totalPos;
												}
											}
											if (stacking) {		
												// add the series
												if (!stacks[key]) {
													stacks[key] = {};
												}
												stacks[key][pointX] = {
													total: totalPos,
													cum: totalPos 
												};
											}
										}
									});


									// For column, areas and bars, set the minimum automatically to zero
									// and prevent that minPadding is added in setScale
									if (/(area|column|bar)/.test(serie.type) && !isXAxis) {
										if (dataMin >= 0) {
											dataMin = 0;
											ignoreMinPadding = true;
										} else if (dataMax < 0) {
											dataMax = 0;
											ignoreMaxPadding = true;
										}
									}
								}
							}
						});

					}

					/**
					 * Translate from axis value to pixel position on the chart, or back
					 * 
					 */
					translate = function(val, backwards, cvsCoord, old) {
						var sign = 1,
							cvsOffset = 0,
							localA = old ? oldTransA : transA,
							localMin = old ? oldMin : min,
							returnValue;

						if (!localA) {
							localA = transA;
						}

						if (cvsCoord) {
							sign *= -1; // canvas coordinates inverts the value
							cvsOffset = axisLength;
						}
						if (reversed) { // reversed axis
							sign *= -1; 
							cvsOffset -= sign * axisLength;
						}

						if (backwards) { // reverse translation
							if (reversed) {
								val = axisLength - val;
							}
							returnValue = val / localA + localMin; // from chart pixel to value				

						} else { // normal translation
							returnValue = sign * (val - localMin) * localA + cvsOffset; // from value to chart pixel
						}

						return returnValue;
					};

					/**
					 * Create the path for a plot line that goes from the given value on 
					 * this axis, across the plot to the opposite side
					 * @param {Number} value
					 * @param {Number} lineWidth Used for calculation crisp line
					 * @param {Number] old Use old coordinates (for resizing and rescaling)
					 */
					getPlotLinePath = function(value, lineWidth, old) {
						var x1, 
							y1, 
							x2, 
							y2,
							translatedValue = translate(value, null, null, old),
							cHeight = old && oldChartHeight || chartHeight,
							cWidth = old && oldChartWidth || chartWidth,
							skip;

						x1 = x2 = mathRound(translatedValue + transB);
						y1 = y2 = mathRound(cHeight - translatedValue - transB);

						if (isNaN(translatedValue)) { // no min or max
							skip = true;

						} else if (horiz) { 
							y1 = plotTop;
							y2 = cHeight - marginBottom;
							if (x1 < plotLeft || x1 > plotLeft + plotWidth) {
								skip = true;
							}
						} else {
							x1 = plotLeft;
							x2 = cWidth - marginRight;
							if (y1 < plotTop || y1 > plotTop + plotHeight) {
								skip = true;
							}
						}
						return skip ? 
							null : 
							renderer.crispLine([M, x1, y1, L, x2, y2], lineWidth || 0);
					};

					/**
					 * Take an interval and normalize it to multiples of 1, 2, 2.5 and 5
					 * @param {Number} interval
					 */
					function normalizeTickInterval(interval, multiples) {
						var normalized;

						// round to a tenfold of 1, 2, 2.5 or 5
						magnitude = multiples ? 1 : math.pow(10, mathFloor(math.log(interval) / math.LN10));
						normalized = interval / magnitude;

						// multiples for a linear scale
						if (!multiples) {
							multiples = [1, 2, 2.5, 5, 10];
							//multiples = [1, 2, 2.5, 4, 5, 7.5, 10];

							// the allowDecimals option
							if (options.allowDecimals === false) {
								if (magnitude == 1) {
									multiples = [1, 2, 5, 10];
								} else if (magnitude <= 0.1) {
									multiples = [1 / magnitude];
								}					
							}
						}

						// normalize the interval to the nearest multiple
						for (var i = 0; i < multiples.length; i++) {
							interval = multiples[i];
							if (normalized <= (multiples[i] + (multiples[i+1] || multiples[i])) / 2) {
								break;
							}
						}

						// multiply back to the correct magnitude
						interval *= magnitude;

						return interval;
					}

					/**
					 * Set the tick positions to a time unit that makes sense, for example
					 * on the first of each month or on every Monday.
					 */
					function setDateTimeTickPositions() {
						tickPositions = [];
						var i,
							useUTC = defaultOptions.global.useUTC,
							oneSecond = 1000 / timeFactor,
							oneMinute = 60000 / timeFactor,
							oneHour = 3600000 / timeFactor,
							oneDay = 24 * 3600000 / timeFactor,
							oneWeek = 7 * 24 * 3600000 / timeFactor,
							oneMonth = 30 * 24 * 3600000 / timeFactor,
							oneYear = 31556952000 / timeFactor,

							units = [[
								'second',						// unit name
								oneSecond,						// fixed incremental unit
								[1, 2, 5, 10, 15, 30]			// allowed multiples
							], [
								'minute',						// unit name
								oneMinute,						// fixed incremental unit
								[1, 2, 5, 10, 15, 30]			// allowed multiples
							], [
								'hour',							// unit name
								oneHour,						// fixed incremental unit
								[1, 2, 3, 4, 6, 8, 12]			// allowed multiples
							], [
								'day',							// unit name
								oneDay,							// fixed incremental unit
								[1, 2]							// allowed multiples
							], [
								'week',							// unit name
								oneWeek,						// fixed incremental unit
								[1, 2]							// allowed multiples
							], [
								'month',
								oneMonth,
								[1, 2, 3, 4, 6]
							], [
								'year',
								oneYear,
								null
							]],

							unit = units[6], // default unit is years
							interval = unit[1], 
							multiples = unit[2];

						// loop through the units to find the one that best fits the tickInterval
						for (i = 0; i < units.length; i++)  {
							unit = units[i];
							interval = unit[1];
							multiples = unit[2];


							if (units[i+1]) {
								// lessThan is in the middle between the highest multiple and the next unit.
								var lessThan = (interval * multiples[multiples.length - 1] + 
											units[i + 1][1]) / 2;

								// break and keep the current unit
								if (tickInterval <= lessThan) {
									break;
								}
							}
						}

						// prevent 2.5 years intervals, though 25, 250 etc. are allowed
						if (interval == oneYear && tickInterval < 5 * interval) {
							multiples = [1, 2, 5];
						}

						// get the minimum value by flooring the date
						var multitude = normalizeTickInterval(tickInterval / interval, multiples),
							minYear, // used in months and years as a basis for Date.UTC()
							minDate = new Date(min * timeFactor);

						minDate.setMilliseconds(0);

						if (interval >= oneSecond) { // second
							minDate.setSeconds(interval >= oneMinute ? 0 :
								multitude * mathFloor(minDate.getSeconds() / multitude));
						}

						if (interval >= oneMinute) { // minute
							minDate[setMinutes](interval >= oneHour ? 0 :
								multitude * mathFloor(minDate[getMinutes]() / multitude));
						}

						if (interval >= oneHour) { // hour
							minDate[setHours](interval >= oneDay ? 0 :
								multitude * mathFloor(minDate[getHours]() / multitude));
						}

						if (interval >= oneDay) { // day
							minDate[setDate](interval >= oneMonth ? 1 :
								multitude * mathFloor(minDate[getDate]() / multitude));
						}

						if (interval >= oneMonth) { // month
							minDate[setMonth](interval >= oneYear ? 0 :
								multitude * mathFloor(minDate[getMonth]() / multitude));
							minYear = minDate[getFullYear]();
						}

						if (interval >= oneYear) { // year
							minYear -= minYear % multitude;
							minDate[setFullYear](minYear);
						}

						// week is a special case that runs outside the hierarchy
						if (interval == oneWeek) {
							// get start of current week, independent of multitude
							minDate[setDate](minDate[getDate]() - minDate[getDay]() + 
								options.startOfWeek);
						}


						// get tick positions
						i = 1; // prevent crash just in case
						minYear = minDate[getFullYear]();
						var time = minDate.getTime() / timeFactor,
							minMonth = minDate[getMonth](),
							minDateDate = minDate[getDate]();

						// iterate and add tick positions at appropriate values
						while (time < max && i < plotWidth) {
							tickPositions.push(time);

							// if the interval is years, use Date.UTC to increase years
							if (interval == oneYear) {
								time = makeTime(minYear + i * multitude, 0) / timeFactor;

							// if the interval is months, use Date.UTC to increase months
							} else if (interval == oneMonth) {
								time = makeTime(minYear, minMonth + i * multitude) / timeFactor;

							// if we're using global time, the interval is not fixed as it jumps
							// one hour at the DST crossover
							} else if (!useUTC && (interval == oneDay || interval == oneWeek)) {
								time = makeTime(minYear, minMonth, minDateDate + 
									i * multitude * (interval == oneDay ? 1 : 7));

							// else, the interval is fixed and we use simple addition
							} else {
								time += interval * multitude;
							}

							i++;
						}
						// push the last time
						tickPositions.push(time);

						// dynamic label formatter 
						dateTimeLabelFormat = options.dateTimeLabelFormats[unit[0]];

					}

					/**
					 * Fix JS round off float errors
					 * @param {Number} num
					 */
					function correctFloat(num) {
						var invMag = (magnitude < 1 ? mathRound(1 / magnitude) : 1) * 10;
						return mathRound(num * invMag) / invMag;
					}

					/**
					 * Set the tick positions of a linear axis to round values like whole tens or every five.
					 */
					function setLinearTickPositions() {

						var i,
							roundedMin = mathFloor(min / tickInterval) * tickInterval,
							roundedMax = mathCeil(max / tickInterval) * tickInterval;

						tickPositions = [];

						// populate the intermediate values
						i = correctFloat(roundedMin);
						while (i <= roundedMax) {
							tickPositions.push(i);
							i = correctFloat(i + tickInterval);
						}

					}

					/**
					 * Set the tick positions to round values and optionally extend the extremes
					 * to the nearest tick
					 */
					function setTickPositions(secondPass) {
						var length,
							catPad,
							linkedParent,
							linkedParentExtremes,
							tickIntervalOption = options.tickInterval,
							tickPixelIntervalOption = options.tickPixelInterval,
							maxZoom = options.maxZoom || (
								isXAxis ? 
									mathMin(chart.smallestInterval * 5, dataMax - dataMin) : 
									null					
							),
							zoomOffset;


						axisLength = horiz ? plotWidth : plotHeight;

						// linked axis gets the extremes from the parent axis
						if (isLinked) {
							linkedParent = chart[isXAxis ? 'xAxis' : 'yAxis'][options.linkedTo];
							linkedParentExtremes = linkedParent.getExtremes();
							min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);
							max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);
						}

						// initial min and max from the extreme data values
						else {
							min = pick(userSetMin, options.min, dataMin);
							max = pick(userSetMax, options.max, dataMax);
						}

						// maxZoom exceeded, just center the selection
						if (max - min < maxZoom) { 
							zoomOffset = (maxZoom - max + min) / 2;
							// if min and max options have been set, don't go beyond it
							min = mathMax(min - zoomOffset, pick(options.min, min - zoomOffset), dataMin);
							max = mathMin(min + maxZoom, pick(options.max, min + maxZoom), dataMax);
						}

						// pad the values to get clear of the chart's edges
						if (!categories && !usePercentage && !isLinked && defined(min) && defined(max)) {
							length = (max - min) || 1;
							if (!defined(options.min) && !defined(userSetMin) && minPadding && (dataMin < 0 || !ignoreMinPadding)) { 
								min -= length * minPadding; 
							}
							if (!defined(options.max) && !defined(userSetMax)  && maxPadding && (dataMax > 0 || !ignoreMaxPadding)) { 
								max += length * maxPadding;
							}
						}

						// get tickInterval
						if (min == max) {
							tickInterval = 1;
						} else if (isLinked && !tickIntervalOption &&
								tickPixelIntervalOption == linkedParent.options.tickPixelInterval) {
							tickInterval = linkedParent.tickInterval;
						} else {
							tickInterval = pick(
								tickIntervalOption,
								categories ? // for categoried axis, 1 is default, for linear axis use tickPix 
									1 : 
									(max - min) * tickPixelIntervalOption / axisLength
							);
						}

						if (!isDatetimeAxis && !defined(options.tickInterval)) { // linear
							axis.tickInterval = tickInterval = normalizeTickInterval(tickInterval);
						}

						// get minorTickInterval
						minorTickInterval = options.minorTickInterval === 'auto' && tickInterval ?
								tickInterval / 5 : options.minorTickInterval;

						// find the tick positions
						if (isDatetimeAxis)	{
							setDateTimeTickPositions();
						} else {
							setLinearTickPositions();
						}

						if (!isLinked) {
							// pad categorised axis to nearest half unit
							if (categories || (isXAxis && chart.hasColumn)) {
								catPad = (categories ? 1 : tickInterval) * 0.5;
								min -= catPad;
								max += catPad;
							}

							// reset min/max or remove extremes based on start/end on tick
							var roundedMin = tickPositions[0],
								roundedMax = tickPositions[tickPositions.length - 1];

							if (options.startOnTick) {
								min = roundedMin;
							} else if (min > roundedMin) {
								tickPositions.shift();
							}

							if (options.endOnTick) {
								max = roundedMax;
							} else if (max < roundedMax) {
								tickPositions.pop();
							}

							// record the greatest number of ticks for multi axis
							if (!maxTicks) { // first call, or maxTicks have been reset after a zoom operation
								maxTicks = {
									x: 0,
									y: 0
								};
							}

							if (!isDatetimeAxis && tickPositions.length > maxTicks[xOrY]) {
								maxTicks[xOrY] = tickPositions.length;
							}
						}


					}

					/**
					 * When using multiple axes, adjust the number of ticks to match the highest
					 * number of ticks in that group
					 */ 
					function adjustTickAmount() {

						if (!isDatetimeAxis && !categories && !isLinked) { // only apply to linear scale
							var oldTickAmount = tickAmount,
								calculatedTickAmount = tickPositions.length;

							// set the axis-level tickAmount to use below
							tickAmount = maxTicks[xOrY];

							if (calculatedTickAmount < tickAmount) {
								while (tickPositions.length < tickAmount) {
									tickPositions.push( correctFloat(
										tickPositions[tickPositions.length - 1] + tickInterval
									));
								}
								transA *= (calculatedTickAmount - 1) / (tickAmount - 1);
								max = tickPositions[tickPositions.length - 1];

							}
							if (defined(oldTickAmount) && tickAmount != oldTickAmount) {
								axis.isDirty = true;	
							}
						}

					}

					/**
					 * Set the scale based on data min and max, user set min and max or options
					 * 
					 */
					function setScale() {
						var type, 
							i;

						oldMin = min;
						oldMax = max;

						// get data extremes if needed
						getSeriesExtremes();

						// get fixed positions based on tickInterval
						setTickPositions();

						// the translation factor used in translate function
						oldTransA = transA;
						transA = axisLength / ((max - min) || 1);

						// reset stacks
						if (!isXAxis) {
							for (type in stacks) {
								for (i in stacks[type]) {
									stacks[type][i].cum = stacks[type][i].total;
								}
							}
						}

						// mark as dirty if it is not already set to dirty and extremes have changed
						if (!axis.isDirty) {
							axis.isDirty = (min != oldMin || max != oldMax);
						}

					}

					/**
					 * Set the extremes and optionally redraw
					 * @param {Number} newMin
					 * @param {Number} newMax
					 * @param {Boolean} redraw
					 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
					 *    configuration
					 * 
					 */
					function setExtremes(newMin, newMax, redraw, animation) {

						setAnimation(animation, chart);
						redraw = pick(redraw, true); // defaults to true

						fireEvent(axis, 'setExtremes', { // fire an event to enable syncing of multiple charts
							min: newMin,
							max: newMax
						}, function() { // the default event handler

							userSetMin = newMin;
							userSetMax = newMax;


							// redraw
							if (redraw) {
								chart.redraw();
							}
						});

					}

					/**
					 * Get the actual axis extremes
					 */
					function getExtremes() {
						return {
							min: min,
							max: max,
							dataMin: dataMin,
							dataMax: dataMax
						};
					}

					/**
					 * Get the zero plane either based on zero or on the min or max value.
					 * Used in bar and area plots
					 */
					function getThreshold(threshold) {
						if (min > threshold) {
							threshold = min;
						} else if (max < threshold) {
							threshold = max;
						}

						return translate(threshold, 0, 1);
					}

					/**
					 * Add a plot band or plot line after render time
					 * 
					 * @param options {Object} The plotBand or plotLine configuration object
					 */
					function addPlotBandOrLine(options) {
						var obj = new PlotLineOrBand(options).render();
						plotLinesAndBands.push(obj);
						return obj;
					}

					/**
					 * Render the tick labels to a preliminary position to get their sizes
					 */
					function getOffset() {

						var hasData = associatedSeries.length && defined(min) && defined(max),
							titleOffset = 0,
							titleMargin = 0,
							axisTitleOptions = options.title,
							labelOptions = options.labels,
							directionFactor = [-1, 1, 1, -1][side];

						if (!axisGroup) {
							axisGroup = renderer.g('axis')
								.attr({ zIndex: 7 })
								.add();
							gridGroup = renderer.g('grid')
								.attr({ zIndex: 1 })
								.add();
						}

						labelOffset = 0; // reset

						if (hasData || isLinked) {
							each(tickPositions, function(pos) {
								if (!ticks[pos]) {
									ticks[pos] = new Tick(pos);
								} else {
									ticks[pos].addLabel(); // update labels depending on tick interval
								}

								// left side must be align: right and right side must have align: left for labels
								if (side === 0 || side == 2 || { 1: 'left', 3: 'right' }[side] == labelOptions.align) {

									// get the highest offset
									labelOffset = mathMax(
										ticks[pos].getLabelSize(),
										labelOffset
									);
								}
							});

							if (staggerLines) {
								labelOffset += (staggerLines - 1) * 16;
							}

						} else { // doesn't have data
							for (var n in ticks) {
								ticks[n].destroy();
								delete ticks[n];
							}
						}

						if (axisTitleOptions && axisTitleOptions.text) {
							if (!axis.axisTitle) {
								axis.axisTitle = renderer.text(
									axisTitleOptions.text,
									0,
									0
								)
								.attr({ 
									zIndex: 7,
									rotation: axisTitleOptions.rotation || 0,
									align: 
										axisTitleOptions.textAlign || 
										{ low: 'left', middle: 'center', high: 'right' }[axisTitleOptions.align]
								})
								.css(axisTitleOptions.style)
								.add();
							}

							titleOffset = axis.axisTitle.getBBox()[horiz ? 'height' : 'width'];
							titleMargin = pick(axisTitleOptions.margin, horiz ? 5 : 10);

						}

						// handle automatic or user set offset
						offset = directionFactor * (options.offset || axisOffset[side]);

						axisTitleMargin = 
							labelOffset +
							(side != 2 && labelOffset && directionFactor * options.labels[horiz ? 'y' : 'x']) + 
							titleMargin;

						axisOffset[side] = mathMax(
							axisOffset[side], 
							axisTitleMargin + titleOffset + directionFactor * offset
						);
					}

					/**
					 * Render the axis
					 */
					function render() {
						var axisTitleOptions = options.title,
							alternateGridColor = options.alternateGridColor,
							lineWidth = options.lineWidth,
							lineLeft,
							lineTop,
							linePath,
							hasRendered = chart.hasRendered,
							slideInTicks = hasRendered && defined(oldMin) && !isNaN(oldMin),
							hasData = associatedSeries.length && defined(min) && defined(max);

						// update metrics
						axisLength = horiz ? plotWidth : plotHeight;
						transA = axisLength / ((max - min) || 1);
						transB = horiz ? plotLeft : marginBottom; // translation addend

						// If the series has data draw the ticks. Else only the line and title
						if (hasData || isLinked) {

							// minor ticks
							if (minorTickInterval && !categories) {
								var pos = min + (tickPositions[0] - min) % minorTickInterval;
								for (pos; pos <= max; pos += minorTickInterval) {
									if (!minorTicks[pos]) {
										minorTicks[pos] = new Tick(pos, true);
									}

									// render new ticks in old position
									if (slideInTicks && minorTicks[pos].isNew) {
										minorTicks[pos].render(null, true);
									}


									minorTicks[pos].isActive = true;
									minorTicks[pos].render();
								}
							}

							// major ticks
							each(tickPositions, function(pos, i) {
								// linked axes need an extra check to find out if 
								if (!isLinked || (pos >= min && pos <= max)) {

									// render new ticks in old position
									if (slideInTicks && ticks[pos].isNew) {
										ticks[pos].render(i, true);
									}

									ticks[pos].isActive = true;
									ticks[pos].render(i);
								}
							});

							// alternate grid color
							if (alternateGridColor) {
								each(tickPositions, function(pos, i) {
									if (i % 2 === 0 && pos < max) {
										/*plotLinesAndBands.push(new PlotLineOrBand({
											from: pos,
											to: tickPositions[i + 1] !== UNDEFINED ? tickPositions[i + 1] : max,
											color: alternateGridColor 
										}));*/

										if (!alternateBands[pos]) {
											alternateBands[pos] = new PlotLineOrBand();
										}
										alternateBands[pos].options = {
											from: pos,
											to: tickPositions[i + 1] !== UNDEFINED ? tickPositions[i + 1] : max,
											color: alternateGridColor 
										};
										alternateBands[pos].render();
										alternateBands[pos].isActive = true;
									}
								});
							}

							// custom plot bands (behind grid lines)
							/*if (!hasRendered) { // only first time
								each(options.plotBands || [], function(plotBandOptions) {
									plotLinesAndBands.push(new PlotLineOrBand(
										extend({ zIndex: 1 }, plotBandOptions)
									).render());
								});
							}*/




							// custom plot lines and bands
							if (!hasRendered) { // only first time
								each((options.plotLines || []).concat(options.plotBands || []), function(plotLineOptions) {
									plotLinesAndBands.push(new PlotLineOrBand(plotLineOptions).render());
								});
							}



						} // end if hasData

						// remove inactive ticks
						each([ticks, minorTicks, alternateBands], function(coll) {
							for (var pos in coll) {
								if (!coll[pos].isActive) {
									coll[pos].destroy();
									delete coll[pos];
								} else {
									coll[pos].isActive = false; // reset
								}
							}
						});




						// Static items. As the axis group is cleared on subsequent calls
						// to render, these items are added outside the group.	
						// axis line
						if (lineWidth) {
							lineLeft = plotLeft + (opposite ? plotWidth : 0) + offset;
							lineTop = chartHeight - marginBottom - (opposite ? plotHeight : 0) + offset;

							linePath = renderer.crispLine([
									M,
									horiz ? 
										plotLeft: 
										lineLeft,
									horiz ? 
										lineTop: 
										plotTop,
									L, 
									horiz ? 
										chartWidth - marginRight : 
										lineLeft,
									horiz ? 
										lineTop:
										chartHeight - marginBottom
								], lineWidth);
							if (!axisLine) {
								axisLine = renderer.path(linePath)
									.attr({ 
										stroke: options.lineColor, 
										'stroke-width': lineWidth,
										zIndex: 7
									})
									.add();
							} else {
								axisLine.animate({ d: linePath });
							}

						}

						if (axis.axisTitle) {
							// compute anchor points for each of the title align options
							var margin = horiz ? plotLeft : plotTop,
								fontSize = pInt(axisTitleOptions.style.fontSize || 12),
							// the position in the length direction of the axis
							alongAxis = { 
								low: margin + (horiz ? 0 : axisLength), 
								middle: margin + axisLength / 2, 
								high: margin + (horiz ? axisLength : 0)
							}[axisTitleOptions.align],

							// the position in the perpendicular direction of the axis
							offAxis = (horiz ? plotTop + plotHeight : plotLeft) +
								(horiz ? 1 : -1) * // horizontal axis reverses the margin
								(opposite ? -1 : 1) * // so does opposite axes
								axisTitleMargin +
								//(isIE ? fontSize / 3 : 0)+ // preliminary fix for vml's centerline
								(side == 2 ? fontSize : 0);

							axis.axisTitle[hasRendered ? 'animate' : 'attr']({
								x: horiz ? 
									alongAxis: 
									offAxis + (opposite ? plotWidth : 0) + offset +
										(axisTitleOptions.x || 0), // x
								y: horiz ? 
									offAxis - (opposite ? plotHeight : 0) + offset: 
									alongAxis + (axisTitleOptions.y || 0) // y
							});

						}

						axis.isDirty = false;
					}

					/**
					 * Remove a plot band or plot line from the chart by id
					 * @param {Object} id
					 */
					function removePlotBandOrLine(id) {
						for (var i = 0; i < plotLinesAndBands.length; i++) {
							if (plotLinesAndBands[i].id == id) {
								plotLinesAndBands[i].destroy();
							}
						}
					}

					/**
					 * Redraw the axis to reflect changes in the data or axis extremes
					 */
					function redraw() {

						// hide tooltip and hover states
						if (tracker.resetTracker) {
							tracker.resetTracker();
						}

						// render the axis
						render();			

						// move plot lines and bands
						each(plotLinesAndBands, function(plotLine) {
							plotLine.render();
						});

						// mark associated series as dirty and ready for redraw
						each(associatedSeries, function(series) {
							series.isDirty = true;
						});

					}

					/**
					 * Set new axis categories and optionally redraw
					 * @param {Array} newCategories
					 * @param {Boolean} doRedraw
					 */
					function setCategories(newCategories, doRedraw) {
							// set the categories
							axis.categories = categories = newCategories;

							// force reindexing tooltips
							each(associatedSeries, function(series) {
								series.translate();
								series.setTooltipPoints(true);
							});


							// optionally redraw
							axis.isDirty = true;

							if (pick(doRedraw, true)) {
								chart.redraw();
							}
					}



					// Run Axis

					// inverted charts have reversed xAxes as default
					if (inverted && isXAxis && reversed === UNDEFINED) {
						reversed = true;
					}


					// expose some variables
					extend(axis, {
						addPlotBand: addPlotBandOrLine,
						addPlotLine: addPlotBandOrLine,
						adjustTickAmount: adjustTickAmount,
						categories: categories,
						getExtremes: getExtremes,
						getPlotLinePath: getPlotLinePath,
						getThreshold: getThreshold,
						isXAxis: isXAxis,
						options: options,
						plotLinesAndBands: plotLinesAndBands,
						getOffset: getOffset,
						render: render,
						setCategories: setCategories,
						setExtremes: setExtremes,
						setScale: setScale,
						setTickPositions: setTickPositions,
						translate: translate,
						redraw: redraw,
						removePlotBand: removePlotBandOrLine,
						removePlotLine: removePlotBandOrLine,
						reversed: reversed,
						stacks: stacks
					});

					// register event listeners
					for (eventType in events) {
						addEvent(axis, eventType, events[eventType]);
					}

					// set min and max
					setScale();

				} // end Axis


				/**
				 * The toolbar object
				 * 
				 * @param {Object} chart 
				 */
				function Toolbar(chart) {
					var buttons = {};

					function add(id, text, title, fn) {
						if (!buttons[id]) {
							var button = renderer.text(
								text,
								0,
								0
							)
							.css(options.toolbar.itemStyle)
							.align({
								align: 'right',
								x: - marginRight - 20,
								y: plotTop + 30
							})
							.on('click', fn)
							/*.on('touchstart', function(e) {
								e.stopPropagation(); // don't fire the container event
								fn();
							})*/
							.attr({
								align: 'right', 
								zIndex: 20
							})
							.add();
							buttons[id] = button;
						}
					}
					function remove(id) {
						discardElement(buttons[id].element);
						buttons[id] = null;
					}

					// public
					return {
						add: add,
						remove: remove
					};
				}

				/**
				 * The tooltip object
				 * @param {Object} options Tooltip options
				 */
				function Tooltip (options) {
					var currentSeries,
						borderWidth = options.borderWidth,
						crosshairsOptions = options.crosshairs,
						crosshairs = [],
						style = options.style,
						shared = options.shared,
						padding = pInt(style.padding),
						boxOffLeft = borderWidth + padding, // off left/top position as IE can't 
							//properly handle negative positioned shapes
						tooltipIsHidden = true,
						boxWidth,
						boxHeight,
						currentX = 0,			
						currentY = 0;

					// remove padding CSS and apply padding on box instead
					style.padding = 0;

					// create the elements
					var group = renderer.g('tooltip')
						.attr({	zIndex: 8 })
						.add(),

						box = renderer.rect(boxOffLeft, boxOffLeft, 0, 0, options.borderRadius, borderWidth)
							.attr({
								fill: options.backgroundColor,
								'stroke-width': borderWidth
							})
							.add(group)
							.shadow(options.shadow),
						label = renderer.text('', padding + boxOffLeft, pInt(style.fontSize) + padding + boxOffLeft)
							.attr({ zIndex: 1 })
							.css(style)
							.add(group);

					group.hide();

					/**
					 * In case no user defined formatter is given, this will be used
					 */
					function defaultFormatter() {
						var pThis = this,
							points = pThis.points || splat(pThis.point),
							xAxis = points[0].series.xAxis,				
							x = pThis.x,
							isDateTime = xAxis && xAxis.options.type == 'datetime',
							useHeader = isString(x) || isDateTime,
							series,
							s;

						// build the header	
						s = useHeader ? 
							['<span style="font-size: 10px">',
							(isDateTime ? dateFormat('%A, %b %e, %Y', x) :  x),
							'</span><br/>'] : [];

						// build the values
						each(points, function(point) {
							series = point.series;
							s.push('<span style="color:'+ series.color +'">', (point.name || series.name), '</span>: ',
								(!useHeader ? ('<b>x = '+ (point.name || point.x) + ',</b> ') : ''), 
								'<b>', (!useHeader ? 'y = ' : '' ), point.y, '</b><br/>');
						});
						return s.join('');
					}

					/**
					 * Provide a soft movement for the tooltip
					 * 
					 * @param {Number} finalX
					 * @param {Number} finalY 
					 */
					function move(finalX, finalY) {

						currentX = tooltipIsHidden ? finalX : (2 * currentX + finalX) / 3;
						currentY = tooltipIsHidden ? finalY : (currentY + finalY) / 2;

						group.translate(currentX, currentY);


						// run on next tick of the mouse tracker
						if (mathAbs(finalX - currentX) > 1 || mathAbs(finalY - currentY) > 1) {
							tooltipTick = function() {
								move(finalX, finalY);
							};
						} else {
							tooltipTick = null;
						}
					}

					/**
					 * Hide the tooltip
					 */
					function hide() {
						if (!tooltipIsHidden) {
							group.hide();

							each(crosshairs, function(crosshair) {
								crosshair.hide();
							});

							// local hover points for shared tooltip
							each(series, function(item) {
								if (item.hoverPoint) {
									item.hoverPoint.setState();
								}
							});

							tooltipIsHidden = true;
						}

					}

					/**
					 * Refresh the tooltip's text and position. 
					 * @param {Object} point
					 * 
					 */
					function refresh(point) {
						var x,
							y,
							boxX,
							boxY,
							show,
							bBox,
							plotX,
							plotY = 0,
							textConfig = {},
							text,
							pointConfig = [],
							tooltipPos = point.tooltipPos,
							formatter = options.formatter || defaultFormatter,
							getConfig = function(point) {
								return {
									series: point.series,
									point: point,
									x: point.category, 
									y: point.y,
									percentage: point.percentage,
									total: point.total || point.stackTotal
								};
							};

						// shared tooltip, array is sent over
						if (shared) { 
							each(point, function(item, i) {
								var series = item.series,
									hoverPoint = series.hoverPoint;
								if (hoverPoint) {
									hoverPoint.setState();
								}
								series.hoverPoint = item;
								item.setState(HOVER_STATE);
								plotY += item.plotY; // for average

								pointConfig.push(getConfig(item));
							});
							plotX = point[0].plotX;
							plotY /= point.length;

							textConfig = {
								x: point[0].category
							};
							textConfig.points = pointConfig;
							point = point[0];

						// single point tooltip
						} else {
							textConfig = getConfig(point);
						}
						text = formatter.call(textConfig);

						// register the current series
						currentSeries = point.series;

						// get the reference point coordinates (pie charts use tooltipPos)
						plotX = shared ? plotX : point.plotX;
						plotY = shared ? plotY : point.plotY;
						x = mathRound(tooltipPos ? tooltipPos[0] : (inverted ? plotWidth - plotY : plotX));
						y = mathRound(tooltipPos ? tooltipPos[1] : (inverted ? plotHeight - plotX : plotY));


						// hide tooltip if the point falls outside the plot
						show = !point.series.isCartesian || isInsidePlot(x, y);

						// update the inner HTML
						if (text === false || !show) { 
							hide();
						} else {

						    // show it
							if (tooltipIsHidden) {
								group.show();
								tooltipIsHidden = false;
							}

							// update text
							label.attr({
								text: text
							});

							// get the bounding box
							bBox = label.getBBox();
							boxWidth = bBox.width;
							boxHeight = bBox.height;

							// set the size of the box
							box.attr({
								width: boxWidth + 2 * padding,
								height: boxHeight + 2 * padding,
								stroke: options.borderColor || point.color || currentSeries.color || '#606060'
							});

							// keep the box within the chart area
							boxX = x - boxWidth + plotLeft - 25;
							boxY = y - boxHeight + plotTop + 10;

							// it is too far to the left, adjust it
							if (boxX < 7) {
								boxX = 7;
								boxY -= 30;
							}


							if (boxY < 5) {
								boxY = 5; // above
							} else if (boxY + boxHeight > chartHeight) { 
								boxY = chartHeight - boxHeight - 5; // below
							}

							// do the move
							move(mathRound(boxX - boxOffLeft), mathRound(boxY - boxOffLeft));


						}


						// crosshairs
						if (crosshairsOptions) {
							crosshairsOptions = splat(crosshairsOptions); // [x, y]

							var path, 
								i = crosshairsOptions.length,
								attribs,
								axis;

							while (i--) {
								if (crosshairsOptions[i] && (axis = point.series[i ? 'yAxis' : 'xAxis'])) {
									path = axis
										.getPlotLinePath(point[i ? 'y' : 'x'], 1);
									if (crosshairs[i]) {
										crosshairs[i].attr({ d: path, visibility: VISIBLE });

									} else {
										attribs = {
											'stroke-width': crosshairsOptions[i].width || 1,
											stroke: crosshairsOptions[i].color || '#C0C0C0',
											zIndex: 2
										};
										if (crosshairsOptions[i].dashStyle) {
											attribs.dashstyle = crosshairsOptions[i].dashStyle;
										}
										crosshairs[i] = renderer.path(path)
											.attr(attribs)
											.add();
									}
								}
							}				
						}		
					}



					// public members
					return {
						shared: shared,
						refresh: refresh,
						hide: hide
					};	
				}

				/**
				 * The mouse tracker object
				 * @param {Object} chart
				 * @param {Object} options
				 */
				function MouseTracker (chart, options) {


					var mouseDownX, 
						mouseDownY,
						hasDragged,
						selectionMarker,
						zoomType = optionsChart.zoomType,
						zoomX = /x/.test(zoomType),
						zoomY = /y/.test(zoomType),
						zoomHor = zoomX && !inverted || zoomY && inverted,
						zoomVert = zoomY && !inverted || zoomX && inverted;

					/**
					 * Add crossbrowser support for chartX and chartY
					 * @param {Object} e The event object in standard browsers
					 */
					function normalizeMouseEvent(e) {
						var ePos;

						// common IE normalizing
						e = e || win.event;
						if (!e.target) {
							e.target = e.srcElement;
						}

						// iOS
						ePos = e.touches ? e.touches.item(0) : e;

						// in certain cases, get mouse position
						if (e.type != 'mousemove' || win.opera) { // only Opera needs position on mouse move, see below
							chartPosition = getPosition(container);
						}

						// chartX and chartY
						if (isIE) { // IE including IE9 that has chartX but in a different meaning
							e.chartX = e.x;
							e.chartY = e.y;
						} else {
							if (ePos.layerX === UNDEFINED) { // Opera and iOS
								e.chartX = ePos.pageX - chartPosition.left;
								e.chartY = ePos.pageY - chartPosition.top;
							} else {
								e.chartX = e.layerX;
								e.chartY = e.layerY;
							}
						}

						return e;
					}

					/**
					 * Get the click position in terms of axis values.
					 * 
					 * @param {Object} e A mouse event
					 */
					function getMouseCoordinates(e) {
						var coordinates = {
							xAxis: [],
							yAxis: []
						}; 
						each(axes, function(axis, i) {
							var translate = axis.translate,
								isXAxis = axis.isXAxis,
								isHorizontal = inverted ? !isXAxis : isXAxis;

							coordinates[isXAxis ? 'xAxis' : 'yAxis'].push({
								axis: axis,
								value: translate(
									isHorizontal ? 
										e.chartX - plotLeft  : 
										plotHeight - e.chartY + plotTop,
									true
								)								
							});
						});
						return coordinates;
					}

					/**
					 * With line type charts with a single tracker, get the point closest to the mouse
					 */
					function onmousemove (e) {
						var point,
							points,
							hoverPoint = chart.hoverPoint,
							hoverSeries = chart.hoverSeries,
							i,
							j,
							distance = chartWidth,
							index = inverted ? e.chartY : e.chartX - plotLeft; // wtf?

						// shared tooltip
						if (tooltip && options.shared) {
							points = [];

							// loop over all series and find the ones with points closest to the mouse
							i = series.length;
							for (j = 0; j < i; j++) {
								if (series[j].visible && series[j].tooltipPoints.length) {
									point = series[j].tooltipPoints[index];
									point._dist = mathAbs(index - point.plotX);
									distance = mathMin(distance, point._dist);
									points.push(point);
								}
							}
							// remove furthest points
							i = points.length;
							while (i--) {
								if (points[i]._dist > distance) {
									points.splice(i, 1);
								}
							}
							// refresh the tooltip if necessary
							if (points.length && (points[0].plotX != hoverX)) {
								tooltip.refresh(points);
								hoverX = points[0].plotX;
							}
						}

						// separate tooltip and general mouse events
						if (hoverSeries && hoverSeries.tracker) { // only use for line-type series with common tracker

							// get the point
							point = hoverSeries.tooltipPoints[index];

							// a new point is hovered, refresh the tooltip
							if (point && point != hoverPoint) {

								// trigger the events
								point.onMouseOver();

							}				
						}
					}



					/**
					 * Reset the tracking by hiding the tooltip, the hover series state and the hover point
					 */
					function resetTracker() {
						var hoverSeries = chart.hoverSeries,
							hoverPoint = chart.hoverPoint;				

						if (hoverPoint) {
							hoverPoint.onMouseOut();
						}

						if (hoverSeries) {
							hoverSeries.onMouseOut();
						}

						if (tooltip) {
							tooltip.hide();
						}

						hoverX = null;
					}

					/**
					 * Mouse up or outside the plot area
					 */
					function drop() {
						if (selectionMarker) {
							var selectionData = {
									xAxis: [],
									yAxis: []
								},
								selectionBox = selectionMarker.getBBox(),
								selectionLeft = selectionBox.x - plotLeft,
								selectionTop = selectionBox.y - plotTop;


							// a selection has been made
							if (hasDragged) {

								// record each axis' min and max
								each(axes, function(axis, i) {
									var translate = axis.translate,
										isXAxis = axis.isXAxis,
										isHorizontal = inverted ? !isXAxis : isXAxis,
										selectionMin = translate(
											isHorizontal ? 
												selectionLeft : 
												plotHeight - selectionTop - selectionBox.height, 
											true
										),
										selectionMax = translate(
											isHorizontal ? 
												selectionLeft + selectionBox.width : 
												plotHeight - selectionTop, 
											true
										);

										selectionData[isXAxis ? 'xAxis' : 'yAxis'].push({
											axis: axis,
											min: mathMin(selectionMin, selectionMax), // for reversed axes
											max: mathMax(selectionMin, selectionMax)
										});

								});
								fireEvent(chart, 'selection', selectionData, zoom);

							}
							selectionMarker = selectionMarker.destroy();
						}

						chart.mouseIsDown = mouseIsDown = hasDragged = false;
						removeEvent(doc, hasTouch ? 'touchend' : 'mouseup', drop);

					}

					/**
					 * Set the JS events on the container element
					 */
					function setDOMEvents () {
						var lastWasOutsidePlot = true;

						/*
						 * Record the starting position of a dragoperation
						 */
						container.onmousedown = function(e) {
							e = normalizeMouseEvent(e);

							// record the start position
							//e.preventDefault && e.preventDefault();

							chart.mouseIsDown = mouseIsDown = true;
							mouseDownX = e.chartX;
							mouseDownY = e.chartY;

							addEvent(doc, hasTouch ? 'touchend' : 'mouseup', drop);
						};

						// The mousemove, touchmove and touchstart event handler
						var mouseMove = function(e) {

							// let the system handle multitouch operations like two finger scroll
							// and pinching
							if (e && e.touches && e.touches.length > 1) {
								return;
							}

							// normalize
							e = normalizeMouseEvent(e);
							if (e.type == 'mousemove') { // not for touch devices
								e.returnValue = false;
							}


							var chartX = e.chartX,
								chartY = e.chartY,
								isOutsidePlot = !isInsidePlot(chartX - plotLeft, chartY - plotTop);

							// cancel on mouse outside
							if (isOutsidePlot) {

								if (!lastWasOutsidePlot) {
									// reset the tracker					
									resetTracker();	
								}

								// drop the selection if any and reset mouseIsDown and hasDragged
								//drop();
								if (chartX < plotLeft) {
									chartX = plotLeft;
								} else if (chartX > plotLeft + plotWidth) {
									chartX = plotLeft + plotWidth;
								}

								if (chartY < plotTop) {
									chartY = plotTop;
								} else if (chartY > plotTop + plotHeight) {
									chartY = plotTop + plotHeight;
								}	

							}	

							if (mouseIsDown && e.type != 'touchstart') { // make selection

								// determine if the mouse has moved more than 10px
								if ((hasDragged = Math.sqrt(
									Math.pow(mouseDownX - chartX, 2) + 
									Math.pow(mouseDownY - chartY, 2)
								) > 10)) {

									// make a selection
									if (hasCartesianSeries && (zoomX || zoomY) && 
											isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop)) {
										if (!selectionMarker) {
											selectionMarker = renderer.rect(
												plotLeft,
												plotTop,
												zoomHor ? 1 : plotWidth,
												zoomVert ? 1 : plotHeight,
												0
											)
											.attr({
												fill: 'rgba(69,114,167,0.25)',
												zIndex: 7
											})
											.add();
										}
									}

									// adjust the width of the selection marker
									if (selectionMarker && zoomHor) {
										var xSize = chartX - mouseDownX;
										selectionMarker.attr({
											width: mathAbs(xSize),
											x: (xSize > 0 ? 0 : xSize) + mouseDownX
										});
									}
									// adjust the height of the selection marker
									if (selectionMarker && zoomVert) {
										var ySize = chartY - mouseDownY;
										selectionMarker.attr({
											height: mathAbs(ySize),
											y: (ySize > 0 ? 0 : ySize) + mouseDownY
										});
									}
								}

							} else if (!isOutsidePlot) {
								// show the tooltip
								onmousemove(e);
							}

							lastWasOutsidePlot = isOutsidePlot;
							return false;
						};

						/*
						 * When the mouse enters the container, run mouseMove
						 */
						container.onmousemove = mouseMove;

						/*
						 * When the mouse leaves the container, hide the tracking (tooltip).
						 */
						addEvent(container, 'mouseleave', resetTracker);


						container.ontouchstart = function(e) {
							// For touch devices, use touchmove to zoom
							if (zoomX || zoomY) {
								container.onmousedown(e);
							}
							// Show tooltip and prevent the lower mouse pseudo event
							mouseMove(e);
						};

						/*
						 * Allow dragging the finger over the chart to read the values on touch 
						 * devices
						 */
						container.ontouchmove = mouseMove;

						/*
						 * Allow dragging the finger over the chart to read the values on touch 
						 * devices
						 */
						container.ontouchend = function() {
							if (hasDragged) {
								resetTracker();
							}
						};			


						// MooTools 1.2.3 doesn't fire this in IE when using addEvent
						container.onclick = function(e) {
							var hoverPoint = chart.hoverPoint;
							e = normalizeMouseEvent(e);

							e.cancelBubble = true; // IE specific


							if (!hasDragged) {
								if (hoverPoint && attr(e.target, 'isTracker')) {
									var plotX = hoverPoint.plotX,
										plotY = hoverPoint.plotY;

									// add page position info
									extend(hoverPoint, {
										pageX: chartPosition.left + plotLeft + 
											(inverted ? plotWidth - plotY : plotX),
										pageY: chartPosition.top + plotTop + 
											(inverted ? plotHeight - plotX : plotY)
									});

									// the series click event
									fireEvent(hoverPoint.series, 'click', extend(e, {
										point: hoverPoint
									}));

									// the point click event
									hoverPoint.firePointEvent('click', e);

								} else { 
									extend(e, getMouseCoordinates(e));

									// fire a click event in the chart
									if (isInsidePlot(e.chartX - plotLeft, e.chartY - plotTop)) {
										fireEvent(chart, 'click', e);
									}
								}


							}
							// reset mouseIsDown and hasDragged
							hasDragged = false;
						};

					}

					/**
					 * Create the image map that listens for mouseovers
					 */
					placeTrackerGroup = function() {

						// first create - plot positions is not final at this stage
						if (!trackerGroup) {
							chart.trackerGroup = trackerGroup = renderer.g('tracker')
								.attr({ zIndex: 9 })
								.add();

						// then position - this happens on load and after resizing and changing
						// axis or box positions
						} else {				
							trackerGroup.translate(plotLeft, plotTop);
							if (inverted) {
								trackerGroup.attr({
									width: chart.plotWidth,
									height: chart.plotHeight
								}).invert();
							}
						}			
					};


					// Run MouseTracker
					placeTrackerGroup();
					if (options.enabled) {
						chart.tooltip = tooltip = Tooltip(options);
					}

					setDOMEvents();

					// set the fixed interval ticking for the smooth tooltip
					tooltipInterval = setInterval(function() {
						if (tooltipTick) {
							tooltipTick();
						}
					}, 32);

					// expose properties
					extend(this, {
						zoomX: zoomX,
						zoomY: zoomY,
						resetTracker: resetTracker
					});
				}



				/**
				 * The overview of the chart's series
				 * @param {Object} chart
				 */
				var Legend = function(chart) {

					var options = chart.options.legend;

					if (!options.enabled) {
						return;
					}

					var horizontal = options.layout == 'horizontal',
						symbolWidth = options.symbolWidth,
						symbolPadding = options.symbolPadding,
						allItems = [],
						style = options.style,
						itemStyle = options.itemStyle,
						itemHoverStyle = options.itemHoverStyle,
						itemHiddenStyle = options.itemHiddenStyle,
						padding = pInt(style.padding),
						rightPadding = 20,
						//lineHeight = options.lineHeight || 16,
						y = 18,
						initialItemX = 4 + padding + symbolWidth + symbolPadding,
						itemX,
						itemY,
						lastItemY,
						lastItemHeight = 0,
						box,
						legendBorderWidth = options.borderWidth,
						legendBackgroundColor = options.backgroundColor,
						legendGroup,
						offsetWidth,
						widthOption = options.width,
						series = chart.series,
						reversedLegend = options.reversed;



					/**
					 * Set the colors for the legend item
					 * @param {Object} item A Series or Point instance
					 * @param {Object} visible Dimmed or colored
					 */
					function colorizeItem(item, visible) {
						var legendItem = item.legendItem,
							legendLine = item.legendLine,
							legendSymbol = item.legendSymbol,
							hiddenColor = itemHiddenStyle.color,
							textColor = visible ? options.itemStyle.color : hiddenColor,
							symbolColor = visible ? item.color : hiddenColor;
						if (legendItem) {
							legendItem.css({ fill: textColor });
						}
						if (legendLine) {
							legendLine.attr({ stroke: symbolColor });
						}
						if (legendSymbol) {
							legendSymbol.attr({ 
								stroke: symbolColor,
								fill: symbolColor
							});
						}
					}

					/**
					 * Position the legend item
					 * @param {Object} item A Series or Point instance
					 * @param {Object} visible Dimmed or colored
					 */
					function positionItem(item, itemX, itemY) {
						var legendItem = item.legendItem,
							legendLine = item.legendLine,
							legendSymbol = item.legendSymbol,
							checkbox = item.checkbox;
						if (legendItem) {
							legendItem.attr({ 
								x: itemX,
								y: itemY
							});
						}
						if (legendLine) {
							legendLine.translate(itemX, itemY - 4);
						}
						if (legendSymbol) {
							legendSymbol.attr({
								x: itemX + legendSymbol.xOff, 
								y: itemY + legendSymbol.yOff
							});
						}
						if (checkbox) {
							checkbox.x = itemX;
							checkbox.y = itemY;
						}
					}

					/**
					 * Destroy a single legend item
					 * @param {Object} item The series or point
					 */
					function destroyItem(item) {
						var checkbox = item.checkbox;

						// pull out from the array
						erase(allItems, item);

						// destroy SVG elements
						each(['legendItem', 'legendLine', 'legendSymbol'], function(key) {
							if (item[key]) {
								item[key].destroy();
							}
						});

						if (checkbox) {
							discardElement(item.checkbox);
						}


					}


					/**
					 * Position the checkboxes after the width is determined
					 */ 
					function positionCheckboxes() {
						each(allItems, function(item) {
							var checkbox = item.checkbox;
							if (checkbox) {
								css(checkbox, {
									left: (legendGroup.attr('translateX') + item.legendItemWidth + checkbox.x - 40) +PX,
									top: (legendGroup.attr('translateY') + checkbox.y - 11) + PX 
								});
							}
						});
					}

					/**
					 * Render a single specific legend item
					 * @param {Object} item A series or point
					 */
					function renderItem(item) {
						var	bBox,
							itemWidth,
							legendSymbol,
							symbolX,
							symbolY,
							attribs,
							simpleSymbol,
							li = item.legendItem,
							series = item.series || item;


						if (!li) { // generate it once, later move it

							// let these series types use a simple symbol
							simpleSymbol = /^(bar|pie|area|column)$/.test(series.type);

							// generate the list item text
							item.legendItem = li = renderer.text(
									options.labelFormatter.call(item),
									0, 
									0
								)
								.css(item.visible ? itemStyle : itemHiddenStyle)
								.on('mouseover', function() {
									item.setState(HOVER_STATE);
									li.css(itemHoverStyle);
								})
								.on('mouseout', function() {
									li.css(item.visible ? itemStyle : itemHiddenStyle);
									item.setState();
								})
								.on('click', function(event) {
									var strLegendItemClick = 'legendItemClick',
										fnLegendItemClick = function() {
											item.setVisible();
										};

									// click the name or symbol
									if (item.firePointEvent) { // point
										item.firePointEvent(strLegendItemClick, null, fnLegendItemClick);
									} else {
										fireEvent(item, strLegendItemClick, null, fnLegendItemClick);
									}
								})
								.attr({ zIndex: 2 })
								.add(legendGroup);

							// draw the line
							if (!simpleSymbol && item.options && item.options.lineWidth) {
								var itemOptions = item.options;
									attribs = {
										'stroke-width': itemOptions.lineWidth,
										zIndex: 2
									};
								if (itemOptions.dashStyle) {
									attribs.dashstyle = itemOptions.dashStyle;
								}
								item.legendLine = renderer.path([
									M,
									-symbolWidth - symbolPadding, 
									0,
									L, 
									-symbolPadding, 
									0
								])
								.attr(attribs)
								.add(legendGroup);
							}

							// draw a simple symbol
							if (simpleSymbol) { // bar|pie|area|column
								//legendLayer.drawRect(
								legendSymbol = renderer.rect(
									(symbolX = -symbolWidth - symbolPadding),
									(symbolY = -11),
									symbolWidth,
									12,
									2
								).attr({
									'stroke-width': 0,
									zIndex: 3
								}).add(legendGroup);
							}

							// draw the marker
							else if (item.options && item.options.marker && item.options.marker.enabled) {
								legendSymbol = renderer.symbol(
									item.symbol,
									(symbolX = -symbolWidth / 2 - symbolPadding), 
									(symbolY = -4),
									item.options.marker.radius
								)
								.attr(item.pointAttr[NORMAL_STATE])
								.attr({ zIndex: 3 })
								.add(legendGroup);


							}
							if (legendSymbol) {
								legendSymbol.xOff = symbolX;
								legendSymbol.yOff = symbolY;
							}

							item.legendSymbol = legendSymbol;

							// colorize the items
							colorizeItem(item, item.visible);


							// add the HTML checkbox on top
							if (item.options && item.options.showCheckbox) {
								item.checkbox = createElement('input', {
									type: 'checkbox',
									checked: item.selected,
									defaultChecked: item.selected // required by IE7						
								}, options.itemCheckboxStyle, container);

								addEvent(item.checkbox, 'click', function(event) {
									var target = event.target;
									fireEvent(item, 'checkboxClick', { 
											checked: target.checked 
										}, 
										function() {
											item.select();
										}
									);
								});
							}
						}



						// position the newly generated or reordered items
						positionItem(item, itemX, itemY);

						// calculate the positions for the next line
						bBox = li.getBBox();
						lastItemY = itemY;
						lastItemHeight = bBox.height;

						item.legendItemWidth = itemWidth = 
							options.itemWidth || symbolWidth + symbolPadding + bBox.width + rightPadding;
						if (horizontal) {
							itemX += itemWidth;
							offsetWidth = widthOption || mathMax(itemX - initialItemX, offsetWidth);

							if (itemX - initialItemX + itemWidth > 
									(widthOption || (chartWidth - 2 * padding - initialItemX))) { // new line
								itemX = initialItemX;
								itemY += lastItemHeight;
							}

						} else {
							itemY += lastItemHeight;
							// the width of the widest item
							offsetWidth = widthOption || mathMax(itemWidth, offsetWidth);			
						}		

						// add it all to an array to use below
						allItems.push(item);
					}

					/**
					 * Render the legend. This method can be called both before and after
					 * chart.render. If called after, it will only rearrange items instead
					 * of creating new ones.
					 */
					function renderLegend() {
						itemX = initialItemX;
						itemY = y;
						offsetWidth = 0;
						lastItemY = 0;

						if (!legendGroup) {
							legendGroup = renderer.g('legend')
								.attr({ zIndex: 7 })
								.add();
						}


						// add HTML for each series
						if (reversedLegend) {
							series.reverse();
						}
						each(series, function(serie) {
							if (!serie.options.showInLegend) {
								return;
							}

							// use points or series for the legend item depending on legendType
							var items = (serie.options.legendType == 'point') ?
								serie.data : [serie];

							// render all items
							each(items, renderItem);
						});
						if (reversedLegend) { // restore
							series.reverse();
						}



						// Draw the border
						legendWidth = widthOption || offsetWidth;
						legendHeight = lastItemY - y + lastItemHeight;

						if (legendBorderWidth || legendBackgroundColor) {
							legendWidth += 2 * padding;
							legendHeight += 2 * padding;

							if (!box) {
								box = renderer.rect(
									0, 
									0,
									legendWidth,
									legendHeight,
									options.borderRadius,
									legendBorderWidth || 0
								).attr({
									stroke: options.borderColor,
									'stroke-width': legendBorderWidth || 0,
									fill: legendBackgroundColor || NONE
								})
								.add(legendGroup)
								.shadow(options.shadow);

							} else {
								box.animate({
									width: legendWidth,
									height: legendHeight
								});
							}
						}

						// 1.x compatibility: positioning based on style
						var props = ['left', 'right', 'top', 'bottom'],
							prop,
							i = 4;
						while(i--) {
							prop = props[i];
							if (style[prop] && style[prop] != 'auto') {
								options[i < 2 ? 'align' : 'verticalAlign'] = prop;
								options[i < 2 ? 'x' : 'y'] = pInt(style[prop]) * (i % 2 ? -1 : 1);
							}
						}

						legendGroup.align(extend(options, {
							width: legendWidth,
							height: legendHeight
						}), true, spacingBox);

						if (!isResizing) {
							positionCheckboxes();
						}
					}


					// run legend
					renderLegend();

					// move checkboxes
					addEvent(chart, 'endResize', positionCheckboxes);

					// expose 
					return {
						colorizeItem: colorizeItem,
						destroyItem: destroyItem,
						renderLegend: renderLegend
					};
				};






				/** 
				 * Initialize an individual series, called internally before render time
				 */
				function initSeries(options) {
					var type = options.type || optionsChart.type || optionsChart.defaultSeriesType,
						typeClass = seriesTypes[type],
						serie,
						hasRendered = chart.hasRendered;

					// an inverted chart can't take a column series and vice versa
					if (hasRendered) {
						if (inverted && type == 'column') {
							typeClass = seriesTypes.bar;
						} else if (!inverted && type == 'bar') {
							typeClass = seriesTypes.column;
						}
					}

					serie = new typeClass();

					serie.init(chart, options);

					// set internal chart properties
					if (!hasRendered && serie.inverted) {
						inverted = true;
					}
					if (serie.isCartesian) {
						hasCartesianSeries = serie.isCartesian;
					}

					series.push(serie);

					return serie;
				}

				/**
				 * Add a series dynamically after  time
				 * 
				 * @param {Object} options The config options
				 * @param {Boolean} redraw Whether to redraw the chart after adding. Defaults to true.
				 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
				 *    configuration
				 * 
				 * @return {Object} series The newly created series object
				 */
				function addSeries(options, redraw, animation) {
					var series;

					setAnimation(animation, chart);
					redraw = pick(redraw, true); // defaults to true

					fireEvent(chart, 'addSeries', { options: options }, function() {
						series = initSeries(options);
						series.isDirty = true;

						chart.isDirtyLegend = true; // the series array is out of sync with the display
						if (redraw) {
							chart.redraw();
						}
					});

					return series;
				}

				/**
				 * Check whether a given point is within the plot area
				 * 
				 * @param {Number} x Pixel x relative to the coordinateSystem
				 * @param {Number} y Pixel y relative to the coordinateSystem
				 */
				isInsidePlot = function(x, y) {
					return x >= 0 &&
						x <= plotWidth &&
						y >= 0 &&
						y <= plotHeight;
				};

				/**
				 * Adjust all axes tick amounts
				 */
				function adjustTickAmounts() {
					if (optionsChart.alignTicks !== false) {
						each(axes, function(axis) {
							axis.adjustTickAmount();
						});
					}
					maxTicks = null;
				}

				/**
				 * Redraw legend, axes or series based on updated data
				 * 
				 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
				 *    configuration
				 */
				function redraw(animation) {
					var redrawLegend = chart.isDirtyLegend,
						hasStackedSeries,
						isDirtyBox = chart.isDirtyBox,
						seriesLength = series.length,
						i = seriesLength,
						serie;

					setAnimation(animation, chart);

					// link stacked series
					while (i--) {
						serie = series[i];
						if (serie.isDirty && serie.options.stacking) {
							hasStackedSeries = true;
							break;
						}
					}
					if (hasStackedSeries) { // mark others as dirty
						i = seriesLength;
						while (i--) {
							serie = series[i];
							if (serie.options.stacking) {
								serie.isDirty = true;
							}
						}
					}

					// handle updated data in the series		
					each(series, function(serie) {
						if (serie.isDirty) { // prepare the data so axis can read it
							serie.cleanData();
							serie.getSegments();

							if (serie.options.legendType == 'point') {
								redrawLegend = true;
							}
						}
					});

					// handle added or removed series
					if (redrawLegend && legend.renderLegend) { // series or pie points are added or removed
						// draw legend graphics
						legend.renderLegend();

						chart.isDirtyLegend = false;
					}

					if (hasCartesianSeries) {
						if (!isResizing) {

							// reset maxTicks
							maxTicks = null;				

							// set axes scales
							each(axes, function(axis) {
								axis.setScale();
							});
						}
						adjustTickAmounts();
						getMargins();

						// redraw axes
						each(axes, function(axis) {
							if (axis.isDirty || isDirtyBox) {
								axis.redraw();
								isDirtyBox = true; // always redraw box to reflect changes in the axis labels 
							}
						});
					}

					// the plot areas size has changed
					if (isDirtyBox) {
						drawChartBox();
						placeTrackerGroup();
					}

					// redraw affected series
					each(series, function(serie) {
						if (serie.isDirty && serie.visible) { 
							serie.redraw();
						}
					});


					// hide tooltip and hover states
					if (tracker && tracker.resetTracker) {
						tracker.resetTracker();
					}

					// fire the event
					fireEvent(chart, 'redraw');
				}



				/**
				 * Dim the chart and show a loading text or symbol
				 * @param {String} str An optional text to show in the loading label instead of the default one
				 */
				function showLoading(str) {
					var loadingOptions = options.loading;

					// create the layer at the first call
					if (!loadingDiv) {
						loadingDiv = createElement(DIV, {
							className: 'highcharts-loading'
						}, extend(loadingOptions.style, {
							left: plotLeft + PX,
							top: plotTop + PX,
							width: plotWidth + PX,
							height: plotHeight + PX,
							zIndex: 10,
							display: NONE
						}), container);

						loadingSpan = createElement(
							'span', 
							null, 
							loadingOptions.labelStyle, 
							loadingDiv
						);

					}

					// update text
					loadingSpan.innerHTML = str || options.lang.loading;

					// show it
					if (!loadingShown) {
						css(loadingDiv, { opacity: 0, display: '' });
						animate(loadingDiv, {
							opacity: loadingOptions.style.opacity
						}, {
							duration: loadingOptions.showDuration
						});
						loadingShown = true;
					}
				}
				/**
				 * Hide the loading layer
				 */
				function hideLoading() {
					animate(loadingDiv, {
						opacity: 0
					}, {
						duration: options.loading.hideDuration, 
						complete: function() {
							css(loadingDiv, { display: NONE });
						}
					});
					loadingShown = false;
				}

				/**
				 * Get an axis, series or point object by id.
				 * @param id {String} The id as given in the configuration options
				 */
				function get(id) {
					var i,
						j,
						data;

					// search axes
					for (i = 0; i < axes.length; i++) {
						if (axes[i].options.id == id) {
							return axes[i];
						}
					}

					// search series
					for (i = 0; i < series.length; i++) {
						if (series[i].options.id == id) {
							return series[i];
						}
					}

					// search points
					for (i = 0; i < series.length; i++) {
						data = series[i].data;
						for (j = 0; j < data.length; j++) {
							if (data[j].id == id) {
								return data[j];
							}
						}
					}
					return null;	
				}

				/** 
				 * Create the Axis instances based on the config options
				 */
				function getAxes() {
					var xAxisOptions = options.xAxis || {},
						yAxisOptions = options.yAxis || {},
						axis;

					// make sure the options are arrays and add some members
					xAxisOptions = splat(xAxisOptions);
					each(xAxisOptions, function(axis, i) {
						axis.index = i; 
						axis.isX = true;
					});

					yAxisOptions = splat(yAxisOptions);
					each(yAxisOptions, function(axis, i) {
						axis.index = i;
					});

					// concatenate all axis options into one array
					axes = xAxisOptions.concat(yAxisOptions);

					// loop the options and construct axis objects
					chart.xAxis = [];
					chart.yAxis = [];
					axes = map(axes, function(axisOptions) {
						axis = new Axis(chart, axisOptions);
						chart[axis.isXAxis ? 'xAxis' : 'yAxis'].push(axis);

						return axis;
					});

					adjustTickAmounts();
				}


				/**
				 * Get the currently selected points from all series
				 */
				function getSelectedPoints() {
					var points = [];
					each(series, function(serie) {
						points = points.concat( grep( serie.data, function(point) {
							return point.selected;
						}));
					});
					return points;
				}

				/**
				 * Get the currently selected series
				 */
				function getSelectedSeries() {
					return grep(series, function (serie) {
						return serie.selected;
					});
				}

				/**
				 * Zoom out to 1:1
				 */
				zoomOut = function () {
					fireEvent(chart, 'selection', { resetSelection: true }, zoom);
					chart.toolbar.remove('zoom');

				};
				/**
				 * Zoom into a given portion of the chart given by axis coordinates
				 * @param {Object} event
				 */
				zoom = function (event) {

					// add button to reset selection
					var lang = defaultOptions.lang,
						animate = chart.pointCount < 100;
					chart.toolbar.add('zoom', lang.resetZoom, lang.resetZoomTitle, zoomOut);

					// if zoom is called with no arguments, reset the axes
					if (!event || event.resetSelection) {
						each(axes, function(axis) {
							axis.setExtremes(null, null, false, animate);
						});
					}

					// else, zoom in on all axes
					else {
						each(event.xAxis.concat(event.yAxis), function(axisData) {
							var axis = axisData.axis;

							// don't zoom more than maxZoom
							if (chart.tracker[axis.isXAxis ? 'zoomX' : 'zoomY']) {
								axis.setExtremes(axisData.min, axisData.max, false, animate);
							}
						});
					}

					// redraw chart
					redraw();
				};

				/**
				 * Show the title and subtitle of the chart
				 * 
				 * @param titleOptions {Object} New title options
				 * @param subtitleOptions {Object} New subtitle options
				 * 
				 */
				function setTitle (titleOptions, subtitleOptions) {

					chartTitleOptions = merge(options.title, titleOptions);
					chartSubtitleOptions = merge(options.subtitle, subtitleOptions);

					// add title and subtitle
					each([
						['title', titleOptions, chartTitleOptions],
						['subtitle', subtitleOptions, chartSubtitleOptions]
					], function(arr) {
						var name = arr[0],
							title = chart[name],
							titleOptions = arr[1],
							chartTitleOptions = arr[2];

						if (title && titleOptions) {
							title.destroy(); // remove old
							title = null;
						}

						if (chartTitleOptions && chartTitleOptions.text && !title) {
							chart[name] = renderer.text(
								chartTitleOptions.text, 
								0,
								0
							)
							.attr({
								align: chartTitleOptions.align,
								'class': 'highcharts-'+ name,
								zIndex: 1
							})
							.css(chartTitleOptions.style)
							.add()
							.align(chartTitleOptions, false, spacingBox);
						}

					});

				}

				/**
				 * Get chart width and height according to options and container size
				 */
				function getChartSize() {

					containerWidth = (renderToClone || renderTo).offsetWidth;
					containerHeight = (renderToClone || renderTo).offsetHeight;
					chart.chartWidth = chartWidth = optionsChart.width || containerWidth || 600;
					chart.chartHeight = chartHeight = optionsChart.height || 
						// the offsetHeight of an empty container is 0 in standard browsers, but 19 in IE7:
						(containerHeight > 19 ? containerHeight : 400);
				}


				/**
				 * Get the containing element, determine the size and create the inner container
				 * div to hold the chart
				 */
				function getContainer() {
					renderTo = optionsChart.renderTo;
					containerId = PREFIX + idCounter++;

					if (isString(renderTo)) {
						renderTo = doc.getElementById(renderTo);
					}

					// remove previous chart
					renderTo.innerHTML = '';

					// If the container doesn't have an offsetWidth, it has or is a child of a node
					// that has display:none. We need to temporarily move it out to a visible
					// state to determine the size, else the legend and tooltips won't render
					// properly 
					if (!renderTo.offsetWidth) {
						renderToClone = renderTo.cloneNode(0);
						css(renderToClone, {
							position: ABSOLUTE,
							top: '-9999px',
							display: ''
						});
						doc.body.appendChild(renderToClone);
					}

					// get the width and height
					getChartSize();

					// create the inner container
					chart.container = container = createElement(DIV, {
							className: 'highcharts-container' + 
								(optionsChart.className ? ' '+ optionsChart.className : ''),
							id: containerId
						}, extend({
							position: RELATIVE,
							//overflow: HIDDEN,
							width: chartWidth + PX,
							height: chartHeight + PX,
							textAlign: 'left'
						}, optionsChart.style),
						renderToClone || renderTo
					);

					chart.renderer = renderer = 
						optionsChart.renderer == 'SVG' ? // force SVG, used for SVG export
							new SVGRenderer(container, chartWidth, chartHeight) : 
							new Renderer(container, chartWidth, chartHeight);

					// Issue 110 workaround:
					// In Firefox, if a div is positioned by percentage, its pixel position may land
					// between pixels. The container itself doesn't display this, but an SVG element
					// inside this container will be drawn at subpixel precition. In order to draw
					// sharp lines, this must be compensated for.
					var subPixelFix;
					if (/Gecko/.test(userAgent)) {
						subPixelFix = function() {
							css(container, { left: 0, top: 0 });
							var rect = container.getBoundingClientRect();
							css(container, {
								left: (-rect.left % 1) + PX,
								top: (-rect.top % 1) + PX
							});
						};

						// run the fix now
						subPixelFix();

						// run it on resize
						addEvent(win, 'resize', subPixelFix);

						// remove it on chart destroy
						addEvent(chart, 'destroy', function() {
							removeEvent(win, 'resize', subPixelFix);
						});
					}
				}

				/**
				 * Calculate margins by rendering axis labels in a preliminary position. Title,
				 * subtitle and legend have already been rendered at this stage, but will be 
				 * moved into their final positions
				 */
				getMargins = function() {
					var legendOptions = options.legend,
						legendMargin = pick(legendOptions.margin, 10),
						legendX = legendOptions.x,
						legendY = legendOptions.y,
						align = legendOptions.align,
						verticalAlign = legendOptions.verticalAlign,
						titleOffset;

					resetMargins();

					// adjust for title and subtitle
					if ((chart.title || chart.subtitle) && !defined(optionsMarginTop)) {
						titleOffset = mathMax(
							chart.title && !chartTitleOptions.floating && !chartTitleOptions.verticalAlign && chartTitleOptions.y || 0, 
							chart.subtitle && !chartSubtitleOptions.floating && !chartSubtitleOptions.verticalAlign && chartSubtitleOptions.y || 0				
						);
						if (titleOffset) {
							plotTop = mathMax(plotTop, titleOffset + pick(chartTitleOptions.margin, 15) + spacingTop);
						}
					}

					// adjust for legend
					if (legendOptions.enabled && !legendOptions.floating) {
						if (align == 'right') { // horizontal alignment handled first
							if (!defined(optionsMarginRight)) {
								marginRight = mathMax(
									marginRight,
									legendWidth - legendX + legendMargin + spacingRight
								);
							}
						} else if (align == 'left') {
							if (!defined(optionsMarginLeft)) {
								plotLeft = mathMax(
									plotLeft,
									legendWidth + legendX + legendMargin + spacingLeft
								);
							}

						} else if (verticalAlign == 'top') {
							if (!defined(optionsMarginTop)) {
								plotTop = mathMax(
									plotTop, 
									legendHeight + legendY + legendMargin + spacingTop
								);
							}

						} else if (verticalAlign == 'bottom') {
							if (!defined(optionsMarginBottom)) {
								marginBottom = mathMax(
									marginBottom, 
									legendHeight - legendY + legendMargin + spacingBottom
								);
							}
						}
					}

					// pre-render axes to get labels offset width
					if (hasCartesianSeries) {
						each(axes, function(axis) {
							axis.getOffset();
						});
					}

					if (!defined(optionsMarginLeft)) {
						plotLeft += axisOffset[3];
					}
					if (!defined(optionsMarginTop)) {
						plotTop += axisOffset[0];
					}
					if (!defined(optionsMarginBottom)) {
						marginBottom += axisOffset[2];
					}
					if (!defined(optionsMarginRight)) {
						marginRight += axisOffset[1];
					}

					setChartSize();

				};

				/**
				 * Add the event handlers necessary for auto resizing
				 * 
				 */
				function initReflow() {
					var reflowTimeout;
					function reflow() {
						var width = optionsChart.width || renderTo.offsetWidth,
							height = optionsChart.height || renderTo.offsetHeight;

						if (width != containerWidth || height != containerHeight) {
							clearTimeout(reflowTimeout);
							reflowTimeout = setTimeout(function() {
								resize(width, height, false);
							}, 100);
						}
						containerWidth = width;
						containerHeight = height;
					}
					addEvent(window, 'resize', reflow);
					addEvent(chart, 'destroy', function() {
						removeEvent(window, 'resize', reflow);
					});
				}

				/**
				 * Resize the chart to a given width and height
				 * @param {Number} width
				 * @param {Number} height
				 * @param {Object|Boolean} animation
				 */
				resize = function(width, height, animation) {
					var chartTitle = chart.title,
						chartSubtitle = chart.subtitle;

					isResizing += 1;

					// set the animation for the current process
					setAnimation(animation, chart);

					oldChartHeight = chartHeight;
					oldChartWidth = chartWidth;
					chartWidth = mathRound(width);
					chartHeight = mathRound(height);

					css(container, {
						width: chartWidth + PX,
						height: chartHeight + PX
					});
					renderer.setSize(chartWidth, chartHeight);

					// update axis lengths for more correct tick intervals:
					plotWidth = chartWidth - plotLeft - marginRight; 
					plotHeight = chartHeight - plotTop - marginBottom;

					// handle axes
					maxTicks = null;
					each(axes, function(axis) {
						axis.isDirty = true;
						axis.setScale();
					});

					// make sure non-cartesian series are also handled
					each(series, function(serie) {
						serie.isDirty = true;
					});

					chart.isDirtyLegend = true; // force legend redraw
					chart.isDirtyBox = true; // force redraw of plot and chart border

					getMargins();

					// move titles
					if (chartTitle) {
						chartTitle.align(null, null, spacingBox);
					}
					if (chartSubtitle) {
						chartSubtitle.align(null, null, spacingBox);
					}

					redraw();


					oldChartHeight = null;
					fireEvent(chart, 'resize');

					// fire endResize and set isResizing back 
					setTimeout(function() {
						fireEvent(chart, 'endResize', null, function() {
							isResizing -= 1;
						});
					}, globalAnimation && globalAnimation.duration || 500);
				};

				/**
				 * Set the public chart properties. This is done before and after the pre-render
				 * to determine margin sizes
				 */
				setChartSize = function() {

					chart.plotLeft = plotLeft = mathRound(plotLeft);
					chart.plotTop = plotTop = mathRound(plotTop);
					chart.plotWidth = plotWidth = mathRound(chartWidth - plotLeft - marginRight);
					chart.plotHeight = plotHeight = mathRound(chartHeight - plotTop - marginBottom);

					chart.plotSizeX = inverted ? plotHeight : plotWidth;
					chart.plotSizeY = inverted ? plotWidth : plotHeight;

					spacingBox = {
						x: spacingLeft,
						y: spacingTop,
						width: chartWidth - spacingLeft - spacingRight,
						height: chartHeight - spacingTop - spacingBottom
					};
				};

				/**
				 * Initial margins before auto size margins are applied
				 */
				resetMargins = function() {
					plotTop = pick(optionsMarginTop, spacingTop);
					marginRight = pick(optionsMarginRight, spacingRight);
					marginBottom = pick(optionsMarginBottom, spacingBottom);
					plotLeft = pick(optionsMarginLeft, spacingLeft);
					axisOffset = [0, 0, 0, 0]; // top, right, bottom, left
				};

				/**
				 * Draw the borders and backgrounds for chart and plot area
				 */
				drawChartBox = function() {
					var chartBorderWidth = optionsChart.borderWidth || 0,
						chartBackgroundColor = optionsChart.backgroundColor,
						plotBackgroundColor = optionsChart.plotBackgroundColor,
						plotBackgroundImage = optionsChart.plotBackgroundImage,
						mgn,
						plotSize = {
							x: plotLeft,
							y: plotTop,
							width: plotWidth,
							height: plotHeight
						};

					// Chart area
					mgn = 2 * chartBorderWidth + (optionsChart.shadow ? 8 : 0);

					if (chartBorderWidth || chartBackgroundColor) {
						if (!chartBackground) {
							chartBackground = renderer.rect(mgn / 2, mgn / 2, chartWidth - mgn, chartHeight - mgn, 
									optionsChart.borderRadius, chartBorderWidth)
								.attr({ 
									stroke: optionsChart.borderColor,
									'stroke-width': chartBorderWidth,
									fill: chartBackgroundColor || NONE
								})
								.add()
								.shadow(optionsChart.shadow);
						} else { // resize
							chartBackground.animate({
								width: chartWidth - mgn,
								height:chartHeight - mgn
							});
						}
					}


					// Plot background
					if (plotBackgroundColor) {
						if (!plotBackground) {
							plotBackground = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0)
								.attr({
									fill: plotBackgroundColor
								})
								.add()
								.shadow(optionsChart.plotShadow);
						} else {
							plotBackground.animate(plotSize);
						}
					}
					if (plotBackgroundImage) {
						if (!plotBGImage) {
							plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight)
								.add();
						} else {
							plotBGImage.animate(plotSize);
						}
					}

					// Plot area border
					if (optionsChart.plotBorderWidth) {
						if (!plotBorder) {
							plotBorder = renderer.rect(plotLeft, plotTop, plotWidth, plotHeight, 0, optionsChart.plotBorderWidth)
								.attr({
									stroke: optionsChart.plotBorderColor,
									'stroke-width': optionsChart.plotBorderWidth,
									zIndex: 4
								})
								.add();
						} else {
							plotBorder.animate(plotSize);
						}
					}

					// reset
					chart.isDirtyBox = false;
				};

				/**
				 * Render all graphics for the chart
				 */
				function render () {
					var labels = options.labels,
						credits = options.credits,
						creditsHref;

					// Title
					setTitle();


					// Legend
					legend = chart.legend = new Legend(chart);

					// Get margins by pre-rendering axes
					getMargins();
					each(axes, function(axis) {
						axis.setTickPositions(true); // update to reflect the new margins 
					});
					adjustTickAmounts();
					getMargins(); // second pass to check for new labels


					// Draw the borders and backgrounds
					drawChartBox();

					// Axes
					if (hasCartesianSeries) {
						each(axes, function(axis) { 
							axis.render();
						});
					}


					// The series
					if (!chart.seriesGroup) {
						chart.seriesGroup = renderer.g('series-group')
							.attr({ zIndex: 3 })
							.add();
					}
					each(series, function(serie) {
						serie.translate();
						serie.setTooltipPoints();
						serie.render();
					});


					// Labels
					if (labels.items) {
						each(labels.items, function() {
							var style = extend(labels.style, this.style),
								x = pInt(style.left) + plotLeft,
								y = pInt(style.top) + plotTop + 12;

							// delete to prevent rewriting in IE
							delete style.left;
							delete style.top;

							renderer.text(
								this.html,
								x,
								y
							)
							.attr({ zIndex: 2 })
							.css(style)
							.add();

						});
					}

					// Toolbar (don't redraw)
					if (!chart.toolbar) {
						chart.toolbar = Toolbar(chart);
					}

					// Credits

					// beta mark
					credits.enabled = true;
					credits.text = 'Highcharts v2.1 Beta';
					if (credits.enabled && !chart.credits) {
						creditsHref = credits.href;
						renderer.text(
							credits.text,
							0,
							0
						)
						.on('click', function() {
							if (creditsHref) {
								location.href = creditsHref;
							}
						})
						.attr({
							align: credits.position.align, 
							zIndex: 8
						})
						.css(credits.style)
						.add()
						.align(credits.position); 
					}

					placeTrackerGroup();

					// Set flag
					chart.hasRendered = true;

					// If the chart was rendered outside the top container, put it back in
					if (renderToClone) {
						renderTo.appendChild(container);
						discardElement(renderToClone);
						//updatePosition(container);
					}
				}

				/**
				 * Clean up memory usage
				 */
				function destroy() {
					var i = series.length,
						parentNode = container.parentNode;

					// fire the chart.destoy event
					fireEvent(chart, 'destroy');

					// remove events
					removeEvent(win, 'unload', destroy);
					removeEvent(chart);

					each(axes, function(axis) {
						removeEvent(axis);
					});

					// destroy each series
					while (i--) {
						series[i].destroy();
					}

					// remove container and all SVG
					container.innerHTML = '';
					removeEvent(container);
					if (parentNode) {
						parentNode.removeChild(container);
					}

					// IE6 leak 
					container =	null;
					// IE7 leak
					renderer.alignedObjects = null;

					// memory and CPU leak
					clearInterval(tooltipInterval);

					// clean it all up
					for (i in chart) {
						delete chart[i];
					}

				}
				/**
				 * Prepare for first rendering after all data are loaded
				 */
				function firstRender() {

					// VML namespaces can't be added until after complete. Listening
					// for Perini's doScroll hack is not enough.
					var onreadystatechange = 'onreadystatechange';
					if (!hasSVG && doc.readyState != 'complete') {
						doc.attachEvent(onreadystatechange, function() {
							doc.detachEvent(onreadystatechange, firstRender);
							firstRender();
						});
						return;
					}

					// create the container
					getContainer();

					resetMargins();
					setChartSize();

					// Initialize the series
					each(options.series || [], function(serieOptions) {
						initSeries(serieOptions);
					});

					// Set the common inversion and transformation for inverted series after initSeries
					chart.inverted = inverted = pick(inverted, options.chart.inverted); 


					getAxes();


					chart.render = render;

					// depends on inverted and on margins being set	
					chart.tracker = tracker = new MouseTracker(chart, options.tooltip);

					//globalAnimation = false;
					render();

					fireEvent(chart, 'load');

					//globalAnimation = true;

					// run callbacks
					if (callback) {
						callback.apply(chart, [chart]);
					}
					each(chart.callbacks, function(fn) {
						fn.apply(chart, [chart]);
					});
				}

				// Run chart



				// Set to zero for each new chart
				colorCounter = 0;
				symbolCounter = 0;

				// Destroy the chart and free up memory. 
				addEvent(win, 'unload', destroy);

				// Set up auto resize
				if (optionsChart.reflow !== false) {
					addEvent(chart, 'load', initReflow);
				}

				// Chart event handlers
				if (chartEvents) {
					for (eventType in chartEvents) { 
						addEvent(chart, eventType, chartEvents[eventType]);
					}
				}


				chart.options = options;
				chart.series = series;






				// Expose methods and variables
				chart.addSeries = addSeries;
				chart.animation = pick(optionsChart.animation, true);
				chart.destroy = destroy;
				chart.get = get;
				chart.getSelectedPoints = getSelectedPoints;
				chart.getSelectedSeries = getSelectedSeries;
				chart.hideLoading = hideLoading;
				chart.isInsidePlot = isInsidePlot;
				chart.redraw = redraw;
				chart.setSize = resize;
				chart.setTitle = setTitle;
				chart.showLoading = showLoading;	
				chart.pointCount = 0;
				/*
				if ($) $(function() {
					$container = $('#container');
					var origChartWidth,
						origChartHeight;
					if ($container) {
						$('<button>+</button>')
							.insertBefore($container)
							.click(function() {
								if (origChartWidth === UNDEFINED) {
									origChartWidth = chartWidth;
									origChartHeight = chartHeight;
								}				
								chart.resize(chartWidth *= 1.1, chartHeight *= 1.1);
							});
						$('<button>-</button>')
							.insertBefore($container)
							.click(function() {
								if (origChartWidth === UNDEFINED) {
									origChartWidth = chartWidth;
									origChartHeight = chartHeight;
								}							
								chart.resize(chartWidth *= 0.9, chartHeight *= 0.9);
							});
						$('<button>1:1</button>')
							.insertBefore($container)
							.click(function() {				
								if (origChartWidth === UNDEFINED) {
									origChartWidth = chartWidth;
									origChartHeight = chartHeight;
								}							
								chart.resize(origChartWidth, origChartHeight);
							});
					}
				})
				*/




				firstRender();


			} // end Chart

			// Hook for exporting module
			Chart.prototype.callbacks = [];

			/**
			 * The Point object and prototype. Inheritable and used as base for PiePoint
			 */
			var Point = function() {};
			Point.prototype = {

				/**
				 * Initialize the point
				 * @param {Object} series The series object containing this point
				 * @param {Object} options The data in either number, array or object format
				 */
				init: function(series, options) {
					var point = this,
						defaultColors;
					point.series = series;
					point.applyOptions(options);
					point.pointAttr = {};

					if (series.options.colorByPoint) {
						defaultColors = series.chart.options.colors;
						if (!point.options) {
							point.options = {};
						}
						point.color = point.options.color = point.color || defaultColors[colorCounter++];

						// loop back to zero
						if (colorCounter >= defaultColors.length) {
							colorCounter = 0;
						}
					}

					series.chart.pointCount++;
					return point;
				},
				/**
				 * Apply the options containing the x and y data and possible some extra properties.
				 * This is called on point init or from point.update.
				 * 
				 * @param {Object} options
				 */
				applyOptions: function(options) {
					var point = this,
						series = point.series;

					point.config = options;

					// onedimensional array input
					if (isNumber(options) || options === null) {
						point.y = options;	
					}

					// object input
					else if (isObject(options) && !isNumber(options.length)) {

						// copy options directly to point
						extend(point, options);
						point.options = options;
					}

					// categorized data with name in first position
					else if (isString(options[0])) {
						point.name = options[0];
						point.y = options[1];
					}

					// two-dimentional array
					else if (isNumber(options[0])) {
						point.x = options[0];
						point.y = options[1];
					}

					/* 
					 * If no x is set by now, get auto incremented value. All points must have an
					 * x value, however the y value can be null to create a gap in the series
					 */
					if (point.x === UNDEFINED) {
						point.x = series.autoIncrement();
					}
				},

				/**
				 * Destroy a point to clear memory. Its reference still stays in series.data.
				 */
				destroy: function() {
					var point = this,
						series = point.series,
						prop;

					series.chart.pointCount--;

					if (point == series.chart.hoverPoint) {
						point.onMouseOut();
					}
					if (point == series.hoverPoint) {
						series.hoverPoint = null;
					}

					// remove all events
					removeEvent(point);

					each(['graphic', 'tracker', 'group', 'dataLabel', 'connector'], function(prop) {
						if (point[prop]) {
							point[prop].destroy();
						}
					});		

					if (point.legendItem) { // pies have legend items
						point.series.chart.legend.destroyItem(point);
					}

					for (prop in point) {
						point[prop] = null;
					}


				},	

				/**
				 * Toggle the selection status of a point
				 * @param {Boolean} selected Whether to select or unselect the point.
				 * @param {Boolean} accumulate Whether to add to the previous selection. By default,
				 *     this happens if the control key (Cmd on Mac) was pressed during clicking.
				 */
				select: function(selected, accumulate) {
					var point = this,
						series = point.series,
						chart = series.chart;

					point.selected = selected = pick(selected, !point.selected);

					//series.isDirty = true;
					point.firePointEvent(selected ? 'select' : 'unselect');
					point.setState(selected && SELECT_STATE);

					// unselect all other points unless Ctrl or Cmd + click
					if (!accumulate) {
						each(chart.getSelectedPoints(), function (loopPoint) {
							if (loopPoint.selected && loopPoint != point) {
								loopPoint.selected = false;
								loopPoint.setState(NORMAL_STATE);
								loopPoint.firePointEvent('unselect');
							}
						});
					}

				},

				onMouseOver: function() {
					var point = this,
						chart = point.series.chart,
						tooltip = chart.tooltip,
						hoverPoint = chart.hoverPoint;

					// set normal state to previous series
					if (hoverPoint && hoverPoint != point) {
						hoverPoint.onMouseOut();
					}

					// trigger the event
					point.firePointEvent('mouseOver');

					// update the tooltip
					if (tooltip && !tooltip.shared) {
						tooltip.refresh(point);
					}

					// hover this
					point.setState(HOVER_STATE);
					chart.hoverPoint = point;
				},

				onMouseOut: function() {
					var point = this;
					point.firePointEvent('mouseOut');

					point.setState();
					point.series.chart.hoverPoint = null;
				},

				/**
				 * Update the point with new options (typically x/y data) and optionally redraw the series.
				 * 
				 * @param {Object} options Point options as defined in the series.data array
				 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
				 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
				 *    configuration
				 * 
				 */
				update: function(options, redraw, animation) {
					var point = this,
						series = point.series,
						chart = series.chart;

					setAnimation(animation, chart);
					redraw = pick(redraw, true);

					// fire the event with a default handler of doing the update
					point.firePointEvent('update', { options: options }, function() {

						point.applyOptions(options);

						// redraw
						series.isDirty = true;
						if (redraw) {
							chart.redraw();
						}
					});
				},

				/**
				 * Remove a point and optionally redraw the series and if necessary the axes
				 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
				 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
				 *    configuration
				 */
				remove: function(redraw, animation) {
					var point = this,
						series = point.series,
						chart = series.chart,
						data = series.data;

					setAnimation(animation, chart);
					redraw = pick(redraw, true);

					// fire the event with a default handler of removing the point			
					point.firePointEvent('remove', null, function() {

						erase(data, point);

						point.destroy();


						// redraw
						series.isDirty = true;
						if (redraw) {
							chart.redraw();
						}
					});


				},

				/**
				 * Fire an event on the Point object. Must not be renamed to fireEvent, as this
				 * causes a name clash in MooTools
				 * @param {String} eventType
				 * @param {Object} eventArgs Additional event arguments
				 * @param {Function} defaultFunction Default event handler
				 */
				firePointEvent: function(eventType, eventArgs, defaultFunction) {
					var point = this,
						series = this.series,
						seriesOptions = series.options;

					// load event handlers on demand to save time on mouseover/out
					if (seriesOptions.point.events[eventType] || (
							point.options && point.options.events && point.options.events[eventType])) {
						this.importEvents();
					}

					// add default handler if in selection mode
					if (eventType == 'click' && seriesOptions.allowPointSelect) {
						defaultFunction = function (event) {
							// Control key is for Windows, meta (= Cmd key) for Mac, Shift for Opera
							point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);
						};
					}

					fireEvent(this, eventType, eventArgs, defaultFunction);
				},
				/**
				 * Import events from the series' and point's options. Only do it on 
				 * demand, to save processing time on hovering.
				 */
				importEvents: function() {
					if (!this.hasImportedEvents) {
						var point = this,
							options = merge(point.series.options.point, point.options),
							events = options.events,
							eventType;

						point.events = events;

						for (eventType in events) {
							addEvent(point, eventType, events[eventType]);
						}
						this.hasImportedEvents = true;
					}
				},

				/**
				 * Set the point's state
				 * @param {String} state
				 */
				setState: function(state) {
					var point = this,
						series = point.series,
						stateOptions = series.options.states,
						markerOptions = defaultPlotOptions[series.type].marker && series.options.marker,
						normalDisabled = markerOptions && !markerOptions.enabled,
						markerStateOptions = markerOptions && markerOptions.states[state],
						stateDisabled = markerStateOptions && markerStateOptions.enabled === false,
						stateMarkerGraphic = series.stateMarkerGraphic,
						chart = series.chart,
						pointAttr = point.pointAttr;

					if (!state) {
						state = NORMAL_STATE; // empty string
					}

					if (
							// already has this state
							state == point.state ||
							// selected points don't respond to hover
							(point.selected && state != SELECT_STATE) ||
							// series' state options is disabled
							(stateOptions[state] && stateOptions[state].enabled === false) ||
							// point marker's state options is disabled
							(state && (stateDisabled || normalDisabled && !markerStateOptions.enabled))

						) {
						return;
					}

					// apply hover styles to the existing point
					if (point.graphic) {
						point.graphic.attr(pointAttr[state]);
					}
					// if a graphic is not applied to each point in the normal state, create a shared
					// graphic for the hover state
					else {
						if (state) {
							if (!stateMarkerGraphic) {
								series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.circle(
									0, 0, pointAttr[state].r
								)
								.attr(pointAttr[state])
								.add(series.group);
							}

							stateMarkerGraphic.translate(
								point.plotX, 
								point.plotY
							);
						}

						if (stateMarkerGraphic) {
							stateMarkerGraphic[state ? 'show' : 'hide']();
						}
					}

					point.state = state;
				}
			};

			/**
			 * The base function which all other series types inherit from
			 * @param {Object} chart
			 * @param {Object} options
			 */
			var Series = function() {};

			Series.prototype = {

				isCartesian: true,
				type: 'line',
				pointClass: Point,
				pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
					stroke: 'lineColor',
					'stroke-width': 'lineWidth',
					fill: 'fillColor',
					r: 'radius'
				},
				init: function(chart, options) {
					var series = this,
						eventType,
						events,
						//pointEvent,
						index = chart.series.length;

					series.chart = chart;
					options = series.setOptions(options); // merge with plotOptions

					// set some variables
					extend(series, {
						index: index,
						options: options,
						name: options.name || 'Series '+ (index + 1),
						state: NORMAL_STATE,
						pointAttr: {},
						visible: options.visible !== false, // true by default
						selected: options.selected === true // false by default
					});

					// register event listeners
					events = options.events;
					for (eventType in events) {
						addEvent(series, eventType, events[eventType]);
					}

					series.getColor();
					series.getSymbol();

					// set the data
					series.setData(options.data, false);

				},


				/**
				 * Return an auto incremented x value based on the pointStart and pointInterval options. 
				 * This is only used if an x value is not given for the point that calls autoIncrement.
				 */
				autoIncrement: function() {
					var series = this,
						options = series.options,
						xIncrement = series.xIncrement;

					xIncrement = pick(xIncrement, options.pointStart, 0);

					series.pointInterval = pick(series.pointInterval, options.pointInterval, 1);

					series.xIncrement = xIncrement + series.pointInterval;
					return xIncrement;
				},

				/**
				 * Sort the data and remove duplicates 
				 */
				cleanData: function() {
					var series = this,
						chart = series.chart,
						data = series.data,
						closestPoints,
						smallestInterval,
						chartSmallestInterval = chart.smallestInterval,
						interval,
						i;

					// sort the data points
					data.sort(function(a, b){
						return (a.x - b.x);
					});

					// remove points with equal x values
					// record the closest distance for calculation of column widths
					for (i = data.length - 1; i >= 0; i--) {
						if (data[i - 1]) {
							if (data[i - 1].x == data[i].x)	{
								data.splice(i - 1, 1); // remove the duplicate
							}

						}
					}


					// find the closes pair of points
					for (i = data.length - 1; i >= 0; i--) {
						if (data[i - 1]) {
							interval = data[i].x - data[i - 1].x;
							if (smallestInterval === UNDEFINED || interval < smallestInterval) {
								smallestInterval = interval;
								closestPoints = i;	
							}
						}
					}

					if (chartSmallestInterval === UNDEFINED || smallestInterval < chartSmallestInterval) {
						chart.smallestInterval = smallestInterval;
					}
					series.closestPoints = closestPoints;
				},		

				/**
				 * Divide the series data into segments divided by null values. Also sort
				 * the data points and delete duplicate values.
				 */
				getSegments: function() {
					var lastNull = -1,
						segments = [],
						data = this.data;

					// create the segments
					each(data, function(point, i) {
						if (point.y === null) {
							if (i > lastNull + 1) {
								segments.push(data.slice(lastNull + 1, i));
							}
							lastNull = i;	
						} else if (i == data.length - 1) { // last value
							segments.push(data.slice(lastNull + 1, i + 1));
						}
					});
					this.segments = segments;


				},
				/**
				 * Set the series options by merging from the options tree
				 * @param {Object} itemOptions
				 */
				setOptions: function(itemOptions) {
					var plotOptions = this.chart.options.plotOptions,
						options = merge(
							plotOptions[this.type],
							plotOptions.series,
							itemOptions
						);

					return options;

				},
				/**
				 * Get the series' color
				 */
				getColor: function(){
					var defaultColors = this.chart.options.colors;
					this.color = this.options.color || defaultColors[colorCounter++] || '#0000ff';
					if (colorCounter >= defaultColors.length) {
						colorCounter = 0;
					}
				},
				/**
				 * Get the series' symbol
				 */
				getSymbol: function(){
					var defaultSymbols = this.chart.options.symbols,
						symbol = this.options.marker.symbol || defaultSymbols[symbolCounter++];
					this.symbol = symbol;
					if (symbolCounter >= defaultSymbols.length) { 
						symbolCounter = 0;
					}
				},

				/**
				 * Add a point dynamically after chart load time
				 * @param {Object} options Point options as given in series.data
				 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
				 * @param {Boolean} shift If shift is true, a point is shifted off the start 
				 *    of the series as one is appended to the end.
				 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
				 *    configuration
				 */
				addPoint: function(options, redraw, shift, animation) {
					var series = this,
						data = series.data,
						graph = series.graph,
						area = series.area,
						chart = series.chart,
						point = (new series.pointClass()).init(series, options);

					setAnimation(animation, chart);

					if (graph && shift) { // make graph animate sideways
						graph.shift = shift;
					}
					if (area) {
						area.shift = shift;
						area.isArea = true;
					}

					redraw = pick(redraw, true);

					data.push(point);
					if (shift) {
						data[0].remove(false);
					}


					// redraw
					series.isDirty = true;
					if (redraw) {
						chart.redraw();
					}
				},

				/**
				 * Replace the series data with a new set of data
				 * @param {Object} data
				 * @param {Object} redraw
				 */
				setData: function(data, redraw) {
					var series = this,
						oldData = series.data,
						initialColor = series.initialColor,
						chart = series.chart,
						i = oldData && oldData.length || 0;

					series.xIncrement = null; // reset for new data
					if (defined(initialColor)) { // reset colors for pie
						colorCounter = initialColor;
					}

					data = map(splat(data || []), function(pointOptions) {
						return (new series.pointClass()).init(series, pointOptions);
					});

					// destroy old points
					while (i--) {
						oldData[i].destroy();
					}

					// set the data
					series.data = data;

					series.cleanData();	
					series.getSegments();

					// redraw
					series.isDirty = true;
					chart.isDirtyBox = true;
					if (pick(redraw, true)) {
						chart.redraw(false);
					}
				},

				/**
				 * Remove a series and optionally redraw the chart
				 * 
				 * @param {Boolean} redraw Whether to redraw the chart or wait for an explicit call
				 * @param {Boolean|Object} animation Whether to apply animation, and optionally animation
				 *    configuration
				 */

				remove: function(redraw, animation) {
					var series = this,
						chart = series.chart;

					setAnimation(animation, chart);
					redraw = pick(redraw, true);

					if (!series.isRemoving) {  /* prevent triggering native event in jQuery
							(calling the remove function from the remove event) */ 
						series.isRemoving = true;

						// fire the event with a default handler of removing the point			
						fireEvent(series, 'remove', null, function() {


							// destroy elements
							series.destroy();


							// redraw
							chart.isDirtyLegend = chart.isDirtyBox = true;
							if (redraw) {
								chart.redraw();
							}
						});

					} 
					series.isRemoving = false;
				},

				/**
				 * Translate data points from raw data values to chart specific positioning data
				 * needed later in drawPoints, drawGraph and drawTracker. 
				 */
				translate: function() {
					var series = this, 
						chart = series.chart, 
						stacking = series.options.stacking,
						categories = series.xAxis.categories,
						yAxis = series.yAxis,
						data = series.data,
						i = data.length;

					// do the translation
					while (i--) {
						var point = data[i],
							xValue = point.x, 
							yValue = point.y, 
							yBottom,
							stack = yAxis.stacks[(yValue < 0 ? '-' : '') + series.stackKey],
							pointStack,
							pointStackTotal;
						point.plotX = series.xAxis.translate(xValue);

						// calculate the bottom y value for stacked series
						if (stacking && series.visible && stack[xValue]) {
							pointStack = stack[xValue];
							pointStackTotal = pointStack.total;
							pointStack.cum = yBottom = pointStack.cum - yValue; // start from top
							yValue = yBottom + yValue;

							if (stacking == 'percent') {
								yBottom = pointStackTotal ? yBottom * 100 / pointStackTotal : 0;
								yValue = pointStackTotal ? yValue * 100 / pointStackTotal : 0;
							}

							point.percentage = pointStackTotal ? point.y * 100 / pointStackTotal : 0;
							point.stackTotal = pointStackTotal;
							point.yBottom = yAxis.translate(yBottom, 0, 1);				
						}

						// set the y value
						if (yValue !== null) {
							point.plotY = yAxis.translate(yValue, 0, 1);
						}

						// set client related positions for mouse tracking
						point.clientX = chart.inverted ? 
							chart.plotHeight - point.plotX : 
							point.plotX; // for mouse tracking

						// some API data
						point.category = categories && categories[point.x] !== UNDEFINED ? 
							categories[point.x] : point.x;

					}
				},
				/**
				 * Memoize tooltip texts and positions
				 */
				setTooltipPoints: function (renew) {
					var series = this,
						chart = series.chart,
						inverted = chart.inverted,
						data = [],
						plotSize = mathRound((inverted ? chart.plotTop : chart.plotLeft) + chart.plotSizeX),
						low,
						high,
						tooltipPoints = []; // a lookup array for each pixel in the x dimension

					// renew
					if (renew) {
						series.tooltipPoints = null;
					}

					// concat segments to overcome null values
					each(series.segments, function(segment){
						data = data.concat(segment);
					});

					// loop the concatenated data and apply each point to all the closest
					// pixel positions
					if (series.xAxis && series.xAxis.reversed) {
						data = data.reverse();//reverseArray(data);
					}

					each(data, function(point, i) {

						low = data[i - 1] ? data[i - 1].high + 1 : 0;
						high = point.high = data[i + 1] ? (
							mathFloor((point.plotX + (data[i + 1] ? 
								data[i + 1].plotX : plotSize)) / 2)) :
								plotSize;

						while (low <= high) {
							tooltipPoints[inverted ? plotSize - low++ : low++] = point;
						}
					});
					series.tooltipPoints = tooltipPoints;
				},




				/**
				 * Series mouse over handler
				 */
				onMouseOver: function() {
					var series = this,
						chart = series.chart,
						hoverSeries = chart.hoverSeries;

					if (chart.mouseIsDown) {
						return;
					}

					// set normal state to previous series
					if (hoverSeries && hoverSeries != series) {
						hoverSeries.onMouseOut();
					}

					// trigger the event, but to save processing time, 
					// only if defined
					if (series.options.events.mouseOver) { 
						fireEvent(series, 'mouseOver');
					}


					// bring to front
					// Todo: optimize. This is one of two operations slowing down the tooltip in Firefox.
					// Can the tracking be done otherwise?
					if (series.tracker) {
						series.tracker.toFront();
					}

					// hover this
					series.setState(HOVER_STATE);
					chart.hoverSeries = series;

				},

				/**
				 * Series mouse out handler
				 */
				onMouseOut: function() {
					// trigger the event only if listeners exist
					var series = this,
						options = series.options,
						chart = series.chart,
						tooltip = chart.tooltip,
						hoverPoint = chart.hoverPoint;

					// trigger mouse out on the point, which must be in this series
					if (hoverPoint) {
						hoverPoint.onMouseOut();
					}		

					// fire the mouse out event
					if (series && options.events.mouseOut) { 
						fireEvent(series, 'mouseOut');
					}


					// hide the tooltip
					if (tooltip && !options.stickyTracking) {
						tooltip.hide();
					}

					// set normal state
					series.setState();
					chart.hoverSeries = null;		
				},

				/**
				 * Animate in the series
				 */
				animate: function(init) {
					var series = this,
						chart = series.chart,
						clipRect = series.clipRect,
						animation = series.options.animation;

					if (animation && !isObject(animation)) {
						animation = {};
					}

					if (init) { // initialize the animation
						if (!clipRect.isAnimating) { // apply it only for one of the series
							clipRect.attr( 'width', 0 );
							clipRect.isAnimating = true;
						}

					} else { // run the animation
						clipRect.animate({ 
							width: chart.plotSizeX 
						}, animation && extend(animation, {
							complete: function() {
								clipRect.isAnimating = false;
							}
						}));

						// delete this function to allow it only once
						this.animate = null;
					}
				},

				/**
				 * Draw the markers
				 */
				drawPoints: function(){
					var series = this,
						pointAttr,
						data = series.data, 
						chart = series.chart,
						plotX,
						plotY,
						i,
						point,
						radius,
						graphic;

					if (series.options.marker.enabled) {
						i = data.length;
						while (i--) {
							point = data[i];
							plotX = point.plotX;
							plotY = point.plotY;
							graphic = point.graphic;

							// only draw the point if y is defined
							if (plotY !== UNDEFINED && !isNaN(plotY)) {

								/* && removed this code because points stayed after zoom
									point.plotX >= 0 && point.plotX <= chart.plotSizeX &&
									point.plotY >= 0 && point.plotY <= chart.plotSizeY*/

								// shortcuts
								pointAttr = point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE];
								radius = pointAttr.r;

								if (graphic) { // update
									graphic.animate({
										x: plotX,
										y: plotY,
										r: radius
									});
								} else {
									point.graphic = chart.renderer.symbol(
										pick(point.marker && point.marker.symbol, series.symbol),
										plotX,
										plotY, 
										radius
									)
									.attr(pointAttr)
									.add(series.group);
								}
							}
						}
					}

				},

				/**
				 * Convert state properties from API naming conventions to SVG attributes
				 * 
				 * @param {Object} options API options object
				 * @param {Object} base1 SVG attribute object to inherit from
				 * @param {Object} base2 Second level SVG attribute object to inherit from
				 */
				convertAttribs: function(options, base1, base2, base3) {
					var conversion = this.pointAttrToOptions,
						attr,
						option,
						obj = {};

					options = options || {};
					base1 = base1 || {};
					base2 = base2 || {};
					base3 = base3 || {};

					for (attr in conversion) {
						option = conversion[attr];
						obj[attr] = pick(options[option], base1[attr], base2[attr], base3[attr]);		 
					}
					return obj;
				},

				/**
				 * Get the state attributes. Each series type has its own set of attributes
				 * that are allowed to change on a point's state change. Series wide attributes are stored for
				 * all series, and additionally point specific attributes are stored for all 
				 * points with individual marker options. If such options are not defined for the point,
				 * a reference to the series wide attributes is stored in point.pointAttr.
				 */
				getAttribs: function() {
					var series = this, 
						normalOptions = defaultPlotOptions[series.type].marker ? series.options.marker : series.options,
						stateOptions = normalOptions.states,
						stateOptionsHover = stateOptions[HOVER_STATE],
						pointStateOptionsHover,
						normalDefaults = {},
						seriesColor = series.color,
						data = series.data,
						i,
						point,
						seriesPointAttr = [],
						pointAttr,
						pointAttrToOptions = series.pointAttrToOptions,
						hasPointSpecificOptions;

					// series type specific modifications
					if (series.options.marker) { // line, spline, area, areaspline, scatter

						// if no color is given for the point, use the general series color
						normalDefaults = {
							stroke: seriesColor,
							fill: seriesColor
						};

						// if no hover radius is given, default to normal radius + 2  
						stateOptionsHover.radius = stateOptionsHover.radius || normalOptions.radius + 2;
						stateOptionsHover.lineWidth = stateOptionsHover.lineWidth || normalOptions.lineWidth + 1;

					} else { // column, bar, pie

						// if no color is given for the point, use the general series color
						normalDefaults = {
							fill: seriesColor
						};

						// if no hover color is given, brighten the normal color
						stateOptionsHover.color = stateOptionsHover.color || 
							Color(stateOptionsHover.color || seriesColor)
								.brighten(stateOptionsHover.brightness).get();
					}

					// general point attributes for the series normal state
					seriesPointAttr[NORMAL_STATE] = series.convertAttribs(normalOptions, normalDefaults);

					// HOVER_STATE and SELECT_STATE states inherit from normal state except the default radius
					each([HOVER_STATE, SELECT_STATE], function(state) {
						seriesPointAttr[state] = 
								series.convertAttribs(stateOptions[state], seriesPointAttr[NORMAL_STATE]);
					});

					// set it
					series.pointAttr = seriesPointAttr;


					// Generate the point-specific attribute collections if specific point
					// options are given. If not, create a referance to the series wide point 
					// attributes
					i = data.length;
					while (i--) {
						point = data[i];
						normalOptions = (point.options && point.options.marker) || point.options;
						if (normalOptions && normalOptions.enabled === false) {
							normalOptions.radius = 0;
						}
						hasPointSpecificOptions = false;

						// check if the point has specific visual options
						if (point.options) {
							for (var key in pointAttrToOptions) {
								if (defined(normalOptions[pointAttrToOptions[key]])) {
									hasPointSpecificOptions = true;
								}
							}
						}



						// a specific marker config object is defined for the individual point:
						// create it's own attribute collection
						if (hasPointSpecificOptions) {

							pointAttr = [];
							stateOptions = normalOptions.states || {}; // reassign for individual point
							pointStateOptionsHover = stateOptions[HOVER_STATE] = stateOptions[HOVER_STATE] || {};

							// if no hover color is given, brighten the normal color
							if (!series.options.marker) { // column, bar, point
								pointStateOptionsHover.color = 
									Color(pointStateOptionsHover.color || point.options.color)
										.brighten(pointStateOptionsHover.brightness || 
											stateOptionsHover.brightness).get();

							}

							// normal point state inherits series wide normal state
							pointAttr[NORMAL_STATE] = series.convertAttribs(normalOptions, seriesPointAttr[NORMAL_STATE]);

							// inherit from point normal and series hover
							pointAttr[HOVER_STATE] = series.convertAttribs(
								stateOptions[HOVER_STATE],
								seriesPointAttr[HOVER_STATE],
								pointAttr[NORMAL_STATE]
							);
							// inherit from point normal and series hover
							pointAttr[SELECT_STATE] = series.convertAttribs(
								stateOptions[SELECT_STATE],
								seriesPointAttr[SELECT_STATE],
								pointAttr[NORMAL_STATE]
							);



						// no marker config object is created: copy a reference to the series-wide
						// attribute collection
						} else {
							pointAttr = seriesPointAttr;
						}

						point.pointAttr = pointAttr;

					}

				},


				/**
				 * Clear DOM objects and free up memory
				 */
				destroy: function() {
					var series = this,
						chart = series.chart,
						//chartSeries = series.chart.series,
						clipRect = series.clipRect,
						prop;

					// remove all events
					removeEvent(series);

					// remove legend items
					if (series.legendItem) {
						series.chart.legend.destroyItem(series);
					}

					// destroy all points with their elements
					each(series.data, function(point) {
						point.destroy();
					});
					// destroy all SVGElements associated to the series
					each(['area', 'graph', 'dataLabelsGroup', 'group', 'tracker'], function(prop) {
						if (series[prop]) {
							series[prop].destroy();
						}
					});
					if (clipRect && clipRect != series.chart.clipRect) {
						clipRect.destroy();
					}

					// remove from hoverSeries
					if (chart.hoverSeries == series) {
						chart.hoverSeries = null;
					}
					erase(chart.series, series);

					// clear all members
					for (prop in series) {
						delete series[prop];
					} 
				},

				/**
				 * Draw the data labels
				 */
				drawDataLabels: function() {
					if (this.options.dataLabels.enabled) {
						var series = this,
							x, 
							y, 
							data = series.data, 
							options = series.options.dataLabels,
							str, 
							dataLabelsGroup = series.dataLabelsGroup, 
							chart = series.chart, 
							inverted = chart.inverted,
							seriesType = series.type,
							color;

						// create a separate group for the data labels to avoid rotation
						if (!dataLabelsGroup) {
							dataLabelsGroup = series.dataLabelsGroup = 
								chart.renderer.g(PREFIX +'data-labels')
									.attr({ 
										visibility: series.visible ? VISIBLE : HIDDEN,
										zIndex: 5
									})
									.translate(chart.plotLeft, chart.plotTop)
									.add();
						}

						// determine the color
						color = options.color;
						if (color == 'auto') { // 1.0 backwards compatibility
							color = null;	
						}
						options.style.color = pick(color, series.color);

						// make the labels for each point
						each(data, function(point, i){
							var plotX = pick(point.barX, point.plotX, -999),
								plotY = pick(point.plotY, -999),
								dataLabel = point.dataLabel,
								align = options.align;

							// get the string
							str = options.formatter.call({
								x: point.x,
								y: point.y,
								series: series,
								point: point,
								percentage: point.percentage,
								total: point.total || point.stackTotal
							});
							x = (inverted ? chart.plotWidth - plotY : plotX) + options.x;
							y = (inverted ? chart.plotHeight - plotX : plotY) + options.y;
							//align = labelPos ? labelPos[6] : options.align;

							// in columns, align the string to the column
							if (seriesType == 'column') {
								x += {
									center: point.barW / 2,
									right: point.barW
								}[align] || 0;
							}

							if (dataLabel) {
								dataLabel.animate({
									x: x,
									y: y
								});
							} else if (str) {
								point.dataLabel = chart.renderer.text(
									str, 
									x, 
									y
								)
								.attr({
									align: align,
									rotation: options.rotation,
									zIndex: 1
								})
								.css(options.style)
								.add(dataLabelsGroup);
							}


						});
					}
				},

				/**
				 * Draw the actual graph
				 */
				drawGraph: function(state) {
					var series = this, 
						options = series.options, 
						chart = series.chart,
						graph = series.graph,
						graphPath = [],
						fillColor,
						area = series.area,
						group = series.group,
						color = options.lineColor || series.color, 
						lineWidth = options.lineWidth,
						dashStyle =  options.dashStyle,
						segmentPath,
						renderer = chart.renderer,
						translatedThreshold = series.yAxis.getThreshold(options.threshold || 0),
						useArea = /^area/.test(series.type),
						singlePoints = [], // used in drawTracker
						areaPath = [],
						attribs;


					// divide into segments and build graph and area paths
					each(series.segments, function(segment) {
						if (segment.length > 1) {
							segmentPath = [];

							// build the segment line
							each(segment, function(point, i) {

								if (series.getPointSpline) { // generate the spline as defined in the SplineSeries object
									segmentPath.push.apply(segmentPath, series.getPointSpline(segment, point, i));

								} else {

									// moveTo or lineTo
									segmentPath.push(i ? L : M);

									// step line?
									if (i && options.step) {
										var lastPoint = segment[i - 1];
										segmentPath.push(
											point.plotX, 
											lastPoint.plotY						
										);
									}

									// normal line to next point
									segmentPath.push(
										point.plotX, 
										point.plotY
									);
								}
							});
							graphPath = graphPath.concat(segmentPath);

							// build the area
							if (useArea) {
								var areaSegmentPath = [],
									i,
									segLength = segmentPath.length;
								for (i = 0; i < segLength; i++) {
									areaSegmentPath.push(segmentPath[i]);
								}
								if (options.stacking && series.type != 'areaspline') {
									// follow stack back. Todo: implement areaspline
									for (i = segment.length - 1; i >= 0; i--) {
										areaSegmentPath.push(segment[i].plotX, segment[i].yBottom);
									}

								} else { // follow zero line back
									areaSegmentPath.push(
										L,
										segment[segment.length - 1].plotX, 
										translatedThreshold,
										L,
										segment[0].plotX, 
										translatedThreshold
									);
								}
								areaPath = areaPath.concat(areaSegmentPath);
							}
						} else {
							singlePoints.push(segment[0]);
						}
					});

					// used in drawTracker:
					series.graphPath = graphPath;
					series.singlePoints = singlePoints;

					// draw the area if area series or areaspline
					if (useArea) {
						fillColor = pick(
							options.fillColor,
							Color(series.color).setOpacity(options.fillOpacity || 0.75).get()
						);
						if (area) {
							area.animate({ d: areaPath });

						} else {
							// draw the area
							series.area = series.chart.renderer.path(areaPath)
								.attr({
									fill: fillColor
								}).add(group);
						}
					}

					// draw the graph
					if (graph) {
						//graph.animate({ d: graphPath.join(' ') });
						graph.animate({ d: graphPath });

					} else {
						if (lineWidth) {
							attribs = {
								'stroke': color,
								'stroke-width': lineWidth
							};
							if (dashStyle) {
								attribs.dashstyle = dashStyle;
							}

							series.graph = renderer.path(graphPath)
								.attr(attribs).add(group).shadow(options.shadow);
						}
					}
				},


				/**
				 * Render the graph and markers
				 */
				render: function() {
					var series = this,
						chart = series.chart,
						group,
						setInvert,
						options = series.options,
						doAnimation = options.animation && series.animate,
						renderer = chart.renderer;


					// Add plot area clipping rectangle. If this is before chart.hasRendered,
					// create one shared clipRect. 
					if (!series.clipRect) {
						series.clipRect = !chart.hasRendered && chart.clipRect ?
							chart.clipRect : 
							renderer.clipRect(0, 0, chart.plotSizeX, chart.plotSizeY);
						if (!chart.clipRect) {
							chart.clipRect = series.clipRect;
						}
					}


					// the group
					if (!series.group) {
						group = series.group = renderer.g('series');

						if (chart.inverted) {
							setInvert = function() {
								group.attr({
									width: chart.plotWidth,
									height: chart.plotHeight
								}).invert();
							};

							setInvert(); // do it now
							addEvent(chart, 'resize', setInvert); // do it on resize
						} 
						group.clip(series.clipRect)
							.attr({ 
								visibility: series.visible ? VISIBLE : HIDDEN,
								zIndex: options.zIndex
							})
							.translate(chart.plotLeft, chart.plotTop)
							.add(chart.seriesGroup);
					}

					series.drawDataLabels();

					// initiate the animation
					if (doAnimation) {
						series.animate(true);
					}

					// cache attributes for shapes
					series.getAttribs();

					// draw the graph if any
					if (series.drawGraph) {
						series.drawGraph();
					}

					// draw the points
					series.drawPoints();

					// draw the mouse tracking area
					if (series.options.enableMouseTracking !== false) {
						series.drawTracker();
					}

					// run the animation
					if (doAnimation) {
						series.animate();
					}


					series.isDirty = false; // means data is in accordance with what you see

				},

				/**
				 * Redraw the series after an update in the axes.
				 */
				redraw: function() {
					var series = this,
						chart = series.chart,
						clipRect = series.clipRect,
						group = series.group;

					if (clipRect) {
						stop(clipRect);
						clipRect.animate({ // for chart resize
							width: chart.plotSizeX,
							height: chart.plotSizeY
						});
					}

					// reposition on resize
					if (group) {
						group.animate({
							translateX: chart.plotLeft, 
							translateY: chart.plotTop
						});
					}

					series.translate();
					series.setTooltipPoints(true);
					series.render();
				},

				/**
				 * Set the state of the graph
				 */
				setState: function(state) {
					var series = this,
						options = series.options,
						graph = series.graph,
						stateOptions = options.states,
						lineWidth = options.lineWidth;

					state = state || NORMAL_STATE;

					if (series.state != state) {
						series.state = state;

						if (stateOptions[state] && stateOptions[state].enabled === false) {
							return;
						}

						if (state) {
							lineWidth = stateOptions[state].lineWidth || lineWidth + 1;
						}

						if (graph && !graph.dashstyle) { // hover is turned off for dashed lines in VML
							graph.attr({ // use attr because animate will cause any other animation on the graph to stop
								'stroke-width': lineWidth
							}, state ? 0 : 500);
						}
					}
				},

				/**
				 * Set the visibility of the graph
				 * 
				 * @param vis {Boolean} True to show the series, false to hide. If UNDEFINED,
				 *        the visibility is toggled.
				 */
				setVisible: function(vis, redraw) {
					var series = this,
						chart = series.chart,
						legendItem = series.legendItem,
						seriesGroup = series.group,
						seriesTracker = series.tracker,
						dataLabelsGroup = series.dataLabelsGroup,
						showOrHide,
						i,
						data = series.data,
						point,
						ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries,
						oldVisibility = series.visible;

					// if called without an argument, toggle visibility
					series.visible = vis = vis === UNDEFINED ? !oldVisibility : vis;
					showOrHide = vis ? 'show' : 'hide';

					// show or hide series
					if (seriesGroup) { // pies don't have one
						seriesGroup[showOrHide]();
					}

					// show or hide trackers
					if (seriesTracker) {
						seriesTracker[showOrHide]();
					} else {
						i = data.length;
						while (i--) {
							point = data[i];
							if (point.tracker) {
								point.tracker[showOrHide]();
							}
						}
					}


					if (dataLabelsGroup) {
						dataLabelsGroup[showOrHide]();
					}

					if (legendItem) {
						chart.legend.colorizeItem(series, vis);
					}


					// rescale or adapt to resized chart
					series.isDirty = true;
					// in a stack, all other series are affected
					if (series.options.stacking) {
						each(chart.series, function(otherSeries) {
							if (otherSeries.options.stacking && otherSeries.visible) { 
								otherSeries.isDirty = true;
							}
						});
					}

					if (ignoreHiddenSeries) {
						chart.isDirtyBox = true;
					}
					if (redraw !== false) {
						chart.redraw();
					}

					fireEvent(series, showOrHide);
				},

				/**
				 * Show the graph
				 */
				show: function() {
					this.setVisible(true);
				},

				/**
				 * Hide the graph
				 */
				hide: function() {
					this.setVisible(false);
				},


				/**
				 * Set the selected state of the graph
				 * 
				 * @param selected {Boolean} True to select the series, false to unselect. If
				 *        UNDEFINED, the selection state is toggled.
				 */
				select: function(selected) {
					var series = this;
					// if called without an argument, toggle
					series.selected = selected = (selected === UNDEFINED) ? !series.selected : selected;

					if (series.checkbox) {
						series.checkbox.checked = selected;
					}

					fireEvent(series, selected ? 'select' : 'unselect');
				},


				/**
				 * Draw the tracker object that sits above all data labels and markers to
				 * track mouse events on the graph or points. For the line type charts
				 * the tracker uses the same graphPath, but with a greater stroke width
				 * for better control.
				 */
				drawTracker: function() {
					var series = this,
						options = series.options,
						trackerPath = [].concat(series.graphPath),
						trackerPathLength = trackerPath.length,
						chart = series.chart,
						snap = chart.options.tooltip.snap,
						tracker = series.tracker,
						cursor = options.cursor,
						css = cursor && { cursor: cursor },
						singlePoints = series.singlePoints,
						singlePoint,
						i;


					// Extend end points. A better way would be to use round linecaps,
					// but those are not clickable in VML.
					if (trackerPathLength) {
						i = trackerPathLength + 1;
						while (i--) {
							if (trackerPath[i] == M) { // extend left side
								trackerPath.splice(i + 1, 0, trackerPath[i + 1] - snap, trackerPath[i + 2], L);
							}
							if ((i && trackerPath[i] == M) || i == trackerPathLength) { // extend right side
								trackerPath.splice(i, 0, L, trackerPath[i - 2] + snap, trackerPath[i - 1]);
							}
						}
					}

					// handle single points
					for (i = 0; i < singlePoints.length; i++) {
						singlePoint = singlePoints[i];
						trackerPath.push(M, singlePoint.plotX - snap, singlePoint.plotY,
							L, singlePoint.plotX + snap, singlePoint.plotY);
					}

					// draw the tracker
					if (tracker) {
						tracker.attr({ d: trackerPath });

					} else { // create
						series.tracker = chart.renderer.path(trackerPath)
							.attr({
								isTracker: true,
								stroke: TRACKER_FILL,
								fill: NONE,
								'stroke-width' : options.lineWidth + 2 * snap,
								visibility: series.visible ? VISIBLE : HIDDEN,
								zIndex: 1
							})
							.on(hasTouch ? 'touchstart' : 'mouseover', function() {
								if (chart.hoverSeries != series) {
									series.onMouseOver();
								}
							})
							.on('mouseout', function() {
								if (!options.stickyTracking) {
									series.onMouseOut();
								}
							})
							.css(css)
							.add(chart.trackerGroup);
					}

				}

			}; // end Series prototype


			/**
			 * LineSeries object
			 */
			var LineSeries = extendClass(Series);
			seriesTypes.line = LineSeries;

			/**
			 * AreaSeries object
			 */
			var AreaSeries = extendClass(Series, {
				type: 'area'
			});
			seriesTypes.area = AreaSeries;




			/**
			 * SplineSeries object
			 */
			var SplineSeries = extendClass( Series, {
				type: 'spline',

				/**
				 * Draw the actual graph
				 */
				getPointSpline: function(segment, point, i) {
					var smoothing = 1.5, // 1 means control points midway between points, 2 means 1/3 from the point, 3 is 1/4 etc
						denom = smoothing + 1,
						plotX = point.plotX,
						plotY = point.plotY,
						lastPoint = segment[i - 1],
						nextPoint = segment[i + 1],
						leftContX,
						leftContY,
						rightContX,
						rightContY,
						ret;

					// find control points
					if (i && i < segment.length - 1) {
						var lastX = lastPoint.plotX,
							lastY = lastPoint.plotY,
							nextX = nextPoint.plotX,
							nextY = nextPoint.plotY,
							correction;

						leftContX = (smoothing * plotX + lastX) / denom;
						leftContY = (smoothing * plotY + lastY) / denom;
						rightContX = (smoothing * plotX + nextX) / denom;
						rightContY = (smoothing * plotY + nextY) / denom;

						// have the two control points make a straight line through main point
						correction = ((rightContY - leftContY) * (rightContX - plotX)) / 
							(rightContX - leftContX) + plotY - rightContY;

						leftContY += correction;
						rightContY += correction;

						// to prevent false extremes, check that control points are between
						// neighbouring points' y values
						if (leftContY > lastY && leftContY > plotY) {
							leftContY = mathMax(lastY, plotY);
							rightContY = 2 * plotY - leftContY; // mirror of left control point
						} else if (leftContY < lastY && leftContY < plotY) {
							leftContY = mathMin(lastY, plotY);
							rightContY = 2 * plotY - leftContY;
						} 
						if (rightContY > nextY && rightContY > plotY) {
							rightContY = mathMax(nextY, plotY);
							leftContY = 2 * plotY - rightContY;
						} else if (rightContY < nextY && rightContY < plotY) {
							rightContY = mathMin(nextY, plotY);
							leftContY = 2 * plotY - rightContY;
						}

						// record for drawing in next point
						point.rightContX = rightContX;
						point.rightContY = rightContY;

					}

					// moveTo or lineTo
					if (!i) {
						ret = [M, plotX, plotY];
					}

					// curve from last point to this
					else {
						ret = [
							'C',
							lastPoint.rightContX || lastPoint.plotX, 
							lastPoint.rightContY || lastPoint.plotY,
							leftContX || plotX, 
							leftContY || plotY,
							plotX, 
							plotY
						];
						lastPoint.rightContX = lastPoint.rightContY = null; // reset for updating series later
					}
					return ret;
				}
			});
			seriesTypes.spline = SplineSeries;



			/**
			 * AreaSplineSeries object
			 */
			var AreaSplineSeries = extendClass(SplineSeries, {
				type: 'areaspline'
			});
			seriesTypes.areaspline = AreaSplineSeries;

			/**
			 * ColumnSeries object
			 */
			var ColumnSeries = extendClass(Series, {
				type: 'column',
				pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
					stroke: 'borderColor',
					'stroke-width': 'borderWidth',
					fill: 'color',
					r: 'borderRadius'
				},
				init: function() {
					Series.prototype.init.apply(this, arguments);

					var series = this,
						chart = series.chart;

					// flag the chart in order to pad the x axis
					chart.hasColumn = true;

					// if the series is added dynamically, force redraw of other
					// series affected by a new column
					if (chart.hasRendered) {
						each(chart.series, function(otherSeries) {
							if (otherSeries.type == series.type) {
								otherSeries.isDirty = true;
							}
						});
					}
				},

				/**
				 * Translate each point to the plot area coordinate system and find shape positions
				 */
				translate: function() {
					var series = this,
						chart = series.chart,
						columnCount = 0,
						reversedXAxis = series.xAxis.reversed,
						categories = series.xAxis.categories,
						stackGroups = {},
						stackKey,
						columnIndex;

					Series.prototype.translate.apply(series);

					// Get the total number of column type series.
					// This is called on every series. Consider moving this logic to a 
					// chart.orderStacks() function and call it on init, addSeries and removeSeries
					each(chart.series, function(otherSeries) {
						if (otherSeries.type == series.type) {
							if (otherSeries.options.stacking) {
								stackKey = otherSeries.stackKey;
								if (stackGroups[stackKey] === UNDEFINED) {
									stackGroups[stackKey] = columnCount++;	
								}					
								columnIndex = stackGroups[stackKey];
							} else {
								columnIndex = columnCount++;
							}
							otherSeries.columnIndex = columnIndex;
						}
					});

					// calculate the width and position of each column based on 
					// the number of column series in the plot, the groupPadding
					// and the pointPadding options
					var options = series.options,
						data = series.data,
						closestPoints = series.closestPoints,
						categoryWidth = mathAbs(
							data[1] ? data[closestPoints].plotX - data[closestPoints - 1].plotX : 
							chart.plotSizeX / (categories ? categories.length : 1)
						),
						groupPadding = categoryWidth * options.groupPadding,
						groupWidth = categoryWidth - 2 * groupPadding,
						pointOffsetWidth = groupWidth / columnCount,
						optionPointWidth = options.pointWidth,
						pointPadding = defined(optionPointWidth) ? (pointOffsetWidth - optionPointWidth) / 2 : 
							pointOffsetWidth * options.pointPadding,
						pointWidth = pick(optionPointWidth, pointOffsetWidth - 2 * pointPadding),
						colIndex = (reversedXAxis ? columnCount - 
							series.columnIndex : series.columnIndex) || 0,
						pointXOffset = pointPadding + (groupPadding + colIndex *
							pointOffsetWidth -(categoryWidth / 2)) *
							(reversedXAxis ? -1 : 1),
						threshold = options.threshold || 0,
						translatedThreshold = series.yAxis.getThreshold(threshold),
						minPointLength = pick(options.minPointLength, 5);

					// record the new values
					each(data, function(point) {
						var plotY = point.plotY,
							yBottom = point.yBottom || translatedThreshold,
							barX = point.plotX + pointXOffset,
							barY = mathCeil(mathMin(plotY, yBottom)), 
							barW = pointWidth,
							barH = mathCeil(mathMax(plotY, yBottom) - barY),
							trackerY;

						// handle options.minPointLength and tracker for small points
						if (mathAbs(barH) < minPointLength) { 
							if (minPointLength) {
								barH = minPointLength;
								barY = 
									mathAbs(barY - translatedThreshold) > minPointLength ? // stacked
										yBottom - minPointLength : // keep position
										translatedThreshold - (plotY <= translatedThreshold ? minPointLength : 0);
							}
							trackerY = barY - 3;
						}

						extend(point, {
							barX: barX,
							barY: barY, 
							barW: barW,
							barH: barH
						});
						point.shapeType = 'rect';
						point.shapeArgs = {
							x: barX,
							y: barY,
							width: barW,
							height: barH,
							r: options.borderRadius
						};

						// make small columns responsive to mouse
						point.trackerArgs = defined(trackerY) && merge(point.shapeArgs, {
							height: mathMax(6, barH + 3),
							y: trackerY
						});
					});

				},

				getSymbol: function(){
				},

				/** 
				 * Columns have no graph
				 */
				drawGraph: function() {},

				/**
				 * Draw the columns. For bars, the series.group is rotated, so the same coordinates
				 * apply for columns and bars. This method is inherited by scatter series.
				 * 
				 */
				drawPoints: function() {
					var series = this,
						options = series.options,
						renderer = series.chart.renderer,
						graphic,
						shapeArgs;		


					// draw the columns
					each(series.data, function(point) {			
						var plotY = point.plotY;
						if (plotY !== UNDEFINED && !isNaN(plotY)) {
							graphic = point.graphic;
							shapeArgs = point.shapeArgs;
							if (graphic) { // update
								stop(graphic);
								graphic.animate(shapeArgs);

							} else {
								point.graphic = renderer[point.shapeType](shapeArgs)
									.attr(point.pointAttr[point.selected ? SELECT_STATE : NORMAL_STATE])
									.add(series.group)
									.shadow(options.shadow);
							}

						}
					});
				},
				/**
				 * Draw the individual tracker elements.
				 * This method is inherited by scatter and pie charts too.
				 */
				drawTracker: function() {
					var series = this,
						chart = series.chart,
						renderer = chart.renderer,
						shapeArgs,
						tracker,
						trackerLabel = +new Date(),
						cursor = series.options.cursor,
						css = cursor && { cursor: cursor },
						rel;

					each(series.data, function(point) {
						tracker = point.tracker;
						shapeArgs = point.trackerArgs || point.shapeArgs;
						if (point.y !== null) {
							if (tracker) {// update
								tracker.attr(shapeArgs);

							} else {
								point.tracker = 
									renderer[point.shapeType](shapeArgs)
									.attr({
										isTracker: trackerLabel,
										fill: TRACKER_FILL,
										visibility: series.visible ? VISIBLE : HIDDEN,
										zIndex: 1
									})
									.on('mouseover', function(event) {
										rel = event.relatedTarget || event.fromElement;
										if (chart.hoverSeries != series && attr(rel, 'isTracker') != trackerLabel) {
											series.onMouseOver();
										}
										point.onMouseOver();

									})
									.on('mouseout', function(event) {
										if (!series.options.stickyTracking) {
											rel = event.relatedTarget || event.toElement;
											if (attr(rel, 'isTracker') != trackerLabel) {
												series.onMouseOut();
											}
										}
									})
									.css(css)
									.add(chart.trackerGroup);
							}
						}
					});				
				},


				/**
				 * Animate the column heights one by one from zero
				 * @param {Boolean} init Whether to initialize the animation or run it 
				 */
				animate: function(init) {
					var series = this,
						data = series.data;

					if (!init) { // run the animation
						/*
						 * Note: Ideally the animation should be initialized by calling
						 * series.group.hide(), and then calling series.group.show()
						 * after the animation was started. But this rendered the shadows
						 * invisible in IE8 standards mode. If the columns flicker on large
						 * datasets, this is the cause.
						 */

						each(data, function(point) {
							var graphic = point.graphic;

							if (graphic) {
								// start values
								graphic.attr({ 
									height: 0,
									y: series.yAxis.translate(0, 0, 1)
								});

								// animate
								graphic.animate({ 
									height: point.barH,
									y: point.barY
								}, series.options.animation);
							}
						});


						// delete this function to allow it only once
						series.animate = null;
					}

				},
				/**
				 * Remove this series from the chart
				 */
				remove: function() {
					var series = this,
						chart = series.chart;

					// column and bar series affects other series of the same type
					// as they are either stacked or grouped
					if (chart.hasRendered) {
						each(chart.series, function(otherSeries) {
							if (otherSeries.type == series.type) {
								otherSeries.isDirty = true;
							}
						});
					}

					Series.prototype.remove.apply(series, arguments);
				}
			});
			seriesTypes.column = ColumnSeries;

			var BarSeries = extendClass(ColumnSeries, {
				type: 'bar',
				init: function(chart) {
					chart.inverted = this.inverted = true;
					ColumnSeries.prototype.init.apply(this, arguments);
				}
			});
			seriesTypes.bar = BarSeries;

			/**
			 * The scatter series class
			 */
			var ScatterSeries = extendClass(Series, {
				type: 'scatter',

				/**
				 * Extend the base Series' translate method by adding shape type and
				 * arguments for the point trackers
				 */
				translate: function() {
					var series = this;

					Series.prototype.translate.apply(series);

					each(series.data, function(point) {
						point.shapeType = 'circle';
						point.shapeArgs = {
							x: point.plotX,
							y: point.plotY,
							r: series.chart.options.tooltip.snap
						};
					});
				},


				/**
				 * Create individual tracker elements for each point
				 */
				//drawTracker: ColumnSeries.prototype.drawTracker,
				drawTracker: function() {
					var series = this,
						cursor = series.options.cursor,
						css = cursor && { cursor: cursor },
						graphic;

					each(series.data, function(point) {
						graphic = point.graphic;
						if (graphic) { // doesn't exist for null points
							graphic
								.attr({ isTracker: true })
								.on('mouseover', function(event) {
									series.onMouseOver();
									point.onMouseOver();					
								})
								.on('mouseout', function(event) {
									if (!series.options.stickyTracking) {
										series.onMouseOut();
									}
								})
								.css(css);
						}
					});

				},

				/**
				 * Cleaning the data is not necessary in a scatter plot
				 */
				cleanData: function() {}
			});
			seriesTypes.scatter = ScatterSeries;

			/**
			 * Extended point object for pies
			 */
			var PiePoint = extendClass(Point, {
				/**
				 * Initiate the pie slice
				 */
				init: function () {

					Point.prototype.init.apply(this, arguments);

					var point = this,
						toggleSlice;

					//visible: options.visible !== false,
					extend(point, {
						visible: point.visible !== false,
						name: pick(point.name, 'Slice')
					});

					// add event listener for select
					toggleSlice = function() {
						point.slice();
					};
					addEvent(point, 'select', toggleSlice);
					addEvent(point, 'unselect', toggleSlice);

					return point;
				},

				/**
				 * Toggle the visibility of the pie slice
				 * @param {Boolean} vis Whether to show the slice or not. If undefined, the
				 *    visibility is toggled
				 */
				setVisible: function(vis) {	
					var point = this, 
						chart = point.series.chart,
						tracker = point.tracker,
						dataLabel = point.dataLabel,
						connector = point.connector,
						method;

					// if called without an argument, toggle visibility
					point.visible = vis = vis === UNDEFINED ? !point.visible : vis;

					method = vis ? 'show' : 'hide';

					point.group[method]();
					if (tracker) {
						tracker[method]();
					}
					if (dataLabel) {
						dataLabel[method]();
					}
					if (connector) {
						connector[method]();
					}
					if (point.legendItem) {
						chart.legend.colorizeItem(point, vis);
					}
				},

				/**
				 * Set or toggle whether the slice is cut out from the pie
				 * @param {Boolean} sliced When undefined, the slice state is toggled 
				 * @param {Boolean} redraw Whether to redraw the chart. True by default.
				 */
				slice: function(sliced, redraw, animation) {
					var point = this,
						series = point.series,
						chart = series.chart,
						slicedTranslation = point.slicedTranslation;

					setAnimation(animation, chart);

					// redraw is true by default
					redraw = pick(redraw, true);

					// if called without an argument, toggle
					sliced = point.sliced = defined(sliced) ? sliced : !point.sliced;

					point.group.animate({
						translateX: (sliced ? slicedTranslation[0] : chart.plotLeft),
						translateY: (sliced ? slicedTranslation[1] : chart.plotTop)
					});

				}
			});

			/**
			 * The Pie series class
			 */
			var PieSeries = extendClass(Series, {
				type: 'pie',
				isCartesian: false,
				pointClass: PiePoint,
				pointAttrToOptions: { // mapping between SVG attributes and the corresponding options
					stroke: 'borderColor',
					'stroke-width': 'borderWidth',
					fill: 'color'
				},

				/**
				 * Pies have one color each point
				 */
				getColor: function() {
					// record first color for use in setData
					this.initialColor = colorCounter;
				},

				/**
				 * Animate the column heights one by one from zero
				 * @param {Boolean} init Whether to initialize the animation or run it 
				 */
				animate: function(init) {
					var series = this,
						data = series.data;

					each(data, function(point) {
						var graphic = point.graphic,
							args = point.shapeArgs,
							up = -mathPI / 2;

						if (graphic) {
							// start values
							graphic.attr({ 
								r: 0,
								start: up,
								end: up
							});

							// animate
							graphic.animate({ 
								r: args.r,
								start: args.start,
								end: args.end
							}, series.options.animation);
						}
					});

					// delete this function to allow it only once
					series.animate = null;

				},
				/**
				 * Do translation for pie slices
				 */
				translate: function() {
					var total = 0,
						series = this,
						cumulative = -0.25, // start at top
						options = series.options,
						slicedOffset = options.slicedOffset,
						connectorOffset = slicedOffset + options.borderWidth,
						positions = options.center,
						chart = series.chart,
						plotWidth = chart.plotWidth,
						plotHeight = chart.plotHeight,
						start,
						end,
						angle,
						data = series.data,
						circ = 2 * mathPI,
						fraction,
						smallestSize = mathMin(plotWidth, plotHeight),
						isPercent,
						radiusX, // the x component of the radius vector for a given point
						radiusY,
						labelDistance = options.dataLabels.distance;

					// get positions - either an integer or a percentage string must be given
					positions.push(options.size, options.innerSize || 0);
					positions = map(positions, function(length, i) {

						isPercent = /%$/.test(length);			
						return isPercent ? 
							// i == 0: centerX, relative to width
							// i == 1: centerY, relative to height
							// i == 2: size, relative to smallestSize
							[plotWidth, plotHeight, smallestSize, smallestSize][i] *
								pInt(length) / 100:
							length;
					});

					// utility for getting the x value from a given y, used for anticollision logic in data labels
					series.getX = function(y, left) {

						angle = math.asin((y - positions[1]) / (positions[2] / 2 + labelDistance));

						return positions[0] + 
							(left ? -1 : 1) *
							(mathCos(angle) * (positions[2] / 2 + labelDistance));
					};

					// set center for later use
					series.center = positions;

					// get the total sum
					each(data, function(point) {
						total += point.y;
					});

					each(data, function(point) {
						// set start and end angle
						fraction = total ? point.y / total : 0;
						start = cumulative * circ;
						cumulative += fraction;
						end = cumulative * circ;


						// set the shape
						point.shapeType = 'arc';
						point.shapeArgs = {
							x: positions[0],
							y: positions[1],
							r: positions[2] / 2,
							innerR: positions[3] / 2,
							start: start,
							end: end
						};

						// center for the sliced out slice
						angle = (end + start) / 2;
						point.slicedTranslation = map([
							mathCos(angle) * slicedOffset + chart.plotLeft, 
							mathSin(angle) * slicedOffset + chart.plotTop
						], mathRound);


						// set the anchor point for tooltips
						radiusX = mathCos(angle) * positions[2] / 2;
						radiusY = mathSin(angle) * positions[2] / 2;
						point.tooltipPos = [
							positions[0] + radiusX * 0.7,
							positions[1] + radiusY * 0.7
						];

						// set the anchor point for data labels			
						point.labelPos = [
							positions[0] + radiusX + mathCos(angle) * labelDistance, // first break of connector
							positions[1] + radiusY + mathSin(angle) * labelDistance, // a/a
							positions[0] + radiusX + mathCos(angle) * connectorOffset, // second break, right outside pie
							positions[1] + radiusY + mathSin(angle) * connectorOffset, // a/a
							positions[0] + radiusX, // landing point for connector
							positions[1] + radiusY, // a/a
							labelDistance < 0 ? // alignment
								'center' :
								angle < circ / 4 ? 'left' : 'right', // alignment
							angle // center angle
						];


						// API properties
						point.percentage = fraction * 100;
						point.total = total;

					});

					this.setTooltipPoints();
				},

				/**
				 * Render the slices
				 */
				render: function() {
					var series = this;

					// cache attributes for shapes
					series.getAttribs();

					this.drawPoints();

					// draw the mouse tracking area
					if (series.options.enableMouseTracking !== false) {
						series.drawTracker();
					}

					this.drawDataLabels();

					if (series.options.animation && series.animate) {
						series.animate();
					}

					series.isDirty = false; // means data is in accordance with what you see
				},

				/**
				 * Draw the data points
				 */
				drawPoints: function() {
					var series = this,
						chart = series.chart,
						renderer = chart.renderer,
						groupTranslation,
						//center,
						graphic,
						shapeArgs;

					// draw the slices
					each(series.data, function(point) {
						graphic = point.graphic;
						shapeArgs = point.shapeArgs;

						// create the group the first time
						if (!point.group) {
							// if the point is sliced, use special translation, else use plot area traslation
							groupTranslation = point.sliced ? point.slicedTranslation : [chart.plotLeft, chart.plotTop];
							point.group = renderer.g('point')
								.attr({ zIndex: 5 })
								.add()
								.translate(groupTranslation[0], groupTranslation[1]);
						}

						// draw the slice
						if (graphic) {
							graphic.animate(shapeArgs);
						} else {
							point.graphic = 
								renderer.arc(shapeArgs)
								.attr(point.pointAttr[NORMAL_STATE])
								.add(point.group);
						}

						// detect point specific visibility
						if (point.visible === false) {
							point.setVisible(false);
						}

					});

				},

				/**
				 * Override the base drawDataLabels method by pie specific functionality
				 */
				drawDataLabels: function() {
					var series = this,
						data = series.data,
						point,
						chart = series.chart,
						options = series.options.dataLabels,
						connectorPadding = pick(options.connectorPadding, 10),
						connectorWidth = pick(options.connectorWidth, 1),
						connector,
						connectorPath,
						outside = options.distance > 0,
						dataLabel,
						labelPos,
						labelHeight,
						lastY,
						centerY = series.center[1],
						quarters = [// divide the points into quarters for anti collision
							[], // top right
							[], // bottom right
							[], // bottom left
							[] // top left
						], 
						x,
						y,
						visibility,
						overlapping,
						rankArr,
						secondPass,
						sign,
						lowerHalf,
						sort,
						i = 4,
						j;

					// run parent method
					Series.prototype.drawDataLabels.apply(series);

					// arrange points for detection collision
					each(data, function(point) {
						var angle = point.labelPos[7],
							quarter;
						if (angle < 0) {
							quarter = 0;
						} else if (angle < mathPI / 2) {
							quarter = 1;
						} else if (angle < mathPI) {
							quarter = 2;
						} else {
							quarter = 3;
						}
						quarters[quarter].push(point);
					});
					quarters[1].reverse();
					quarters[3].reverse();

					// define the sorting algorithm
					sort = function(a,b) {
						return a.y > b.y;
					};
					/* Loop over the points in each quartile, starting from the top and bottom
					 * of the pie to detect overlapping labels.
					 */
					while (i--) {
						overlapping = 0;

						// create an array for sorting and ranking the points within each quarter
						rankArr = [].concat(quarters[i]);
						rankArr.sort(sort);
						j = rankArr.length;
						while (j--) {
							rankArr[j].rank = j;
						}

						/* In the first pass, count the number of overlapping labels. In the second
						 * pass, remove the labels with lowest rank/values.
						 */
						for (secondPass = 0; secondPass < 2; secondPass++) {
							lowerHalf = i % 3;
							lastY = lowerHalf ? 9999 : -9999;
							sign = lowerHalf ? -1 : 1;

							for (j = 0; j < quarters[i].length; j++) {
								point = quarters[i][j];

								if ((dataLabel = point.dataLabel)) {
									labelPos = point.labelPos;
									visibility = VISIBLE;
									x = labelPos[0];
									y = labelPos[1];


									// assume all labels have equal height
									if (!labelHeight) {
										labelHeight = dataLabel && dataLabel.getBBox().height;
									}

									// anticollision
									if (outside) {
										if (secondPass && point.rank < overlapping) {
											visibility = HIDDEN;
										} else if ((!lowerHalf && y < lastY + labelHeight) ||
												(lowerHalf && y > lastY - labelHeight)) {  
											y = lastY + sign * labelHeight;
											x = series.getX(y, i > 1);
											if ((!lowerHalf && y + labelHeight > centerY) ||
													(lowerHalf && y -labelHeight < centerY)) {
												if (secondPass) {
													visibility = HIDDEN;
												} else {									
													overlapping++;
												}
											}
										}
									}

									if (point.visible === false) {
										visibility = HIDDEN;
									}

									if (visibility == VISIBLE) {
										lastY = y;
									}


									if (secondPass) {

										// move or place the data label
										dataLabel
											.attr({
												visibility: visibility,
												align: labelPos[6]
											})
											.animate({
												x: x + options.x + 
													({ left: connectorPadding, right: -connectorPadding }[labelPos[6]] || 0),
												y: y + options.y
											});

										// draw the connector
										if (outside && connectorWidth) {
											connector = point.connector;

											connectorPath = [
												M,
												x + (labelPos[6] == 'left' ? 5 : -5), y, // end of the string at the label
												L,
												x, y, // first break, next to the label
												L,
												labelPos[2], labelPos[3], // second break
												L,
												labelPos[4], labelPos[5] // base
											];

											if (connector) {
												connector.animate({ d: connectorPath });
												connector.attr('visibility', visibility);

											} else {		
												point.connector = connector = series.chart.renderer.path(connectorPath).attr({
													'stroke-width': connectorWidth,
													stroke: options.connectorColor || '#606060',
													visibility: visibility,
													zIndex: 3
												})
												.translate(chart.plotLeft, chart.plotTop)
												.add();
											}
										}
									}
								}
							}
						}
					}
				},

				/**
				 * Draw point specific tracker objects. Inherit directly from column series.
				 */
				drawTracker: ColumnSeries.prototype.drawTracker,

				/**
				 * Pies don't have point marker symbols
				 */
				getSymbol: function() {}

			});
			seriesTypes.pie = PieSeries;


			// global variables
			win.Highcharts = {
				Chart: Chart,
				dateFormat: dateFormat,
				pathAnim: pathAnim,
				getOptions: getOptions,
				numberFormat: numberFormat,
				Point: Point,
				Renderer: Renderer,
				seriesTypes: seriesTypes,
				setOptions: setOptions,
				Series: Series,

				// Expose utility funcitons for modules
				addEvent: addEvent,
				createElement: createElement,
				discardElement: discardElement,
				css: css,
				each: each,
				extend: extend,
				map: map,
				merge: merge,
				pick: pick,
				extendClass: extendClass
			};
			})();
			
			
		</script>

		<%= yield(:header) %>

		<style type="text/css">
			<%- @severities.each do |sev| -%>
				ul.table li div.small span.severity.sev<%= sev.sig_id %>{
					background-color: <%= sev.bg_color %>;
					color: <%= sev.text_color %>;
				}
			<%- end -%>
		</style>
		
	</head>
	
	<body>
		
		<div id="wrapper">

			<div id='header'>

				<% if Setting.company? %>
					<h1><%= Setting.find(:company) %></h1>
				<% else %>
					<h1>Snorby Reports</h1>
				<% end %>

				Date: <%= Time.now.strftime('%A %B, %Y at %I:%M %p') %>

				<%= yield(:pdf_header) %>

			</div>

			<div id="content" class='shadow container_12'>

		    <%= yield %>

			</div>

		</div>
		
		<%= yield(:footer) %>
	</body>
	
</html>